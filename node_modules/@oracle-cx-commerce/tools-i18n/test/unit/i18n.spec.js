/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

/* eslint max-lines: ['error', {max: 1000, skipBlankLines: true, skipComments: true}] */
/**
 * @jest-environment node
 */

const sourceCodeDir = '../..';
const {i18n} = require(`${sourceCodeDir}/index`);
const systemLocale = require('os-locale');
const os = require('os');

const testSkippedOnWindows = os.platform() === 'win32' ? test.skip : test;
const {EOL} = os;

/**
 * Creates a super simple sample program to test the @oracle-cx-commerce/tools-i18n internationalization utility.
 *
 * @param      {Object}  [options={}] - The same options that the I18n constructor accepts.
 * @return     {string}  - A string that can be saved as a Node program.
 */
function generateSampleProgram(options = {}, additionalLines) {
  let code = [];
  code.push("const {i18n} = require('./index')");
  code.push(`const {___} = i18n(${JSON.stringify(options)})`);
  code.push("console.log(___('Hello World!'))");
  if (additionalLines) {
    code = code.concat(additionalLines);
  }

  return code.join(EOL);
}

// Note:
//   The tests ordering is essential to allow the tests' run time optimization. Please do not change it.
//   The largest time-consuming task is the 'yarn install' operation, which we do not want to perform for every test.

describe('Configuration tests', () => {
  test('Check default configuration has the expected values', () => {
    const expectedDefaultValues = {
      directory: './locales',
      updateFile: false,
      locale: systemLocale.sync().replace('_', '-'),
      fallbackToLanguage: true,
      strings: {}
    };

    const internationalizer = i18n();
    for (const property in expectedDefaultValues) {
      expect(internationalizer[property]).toEqual(expectedDefaultValues[property]);
    }
  });

  test('Check i18n object configuration is processed correctly', () => {
    const expectedPropertiesFromConstructorOptions = {
      defaultLocalesDir: './locales',
      usLocale: 'en-US',
      directory: './temp/locales',
      updateFile: false,
      locale: 'fr-FR',
      fallbackToLanguage: false,
      strings: {}
    };

    const {defaultLocalesDir, usLocale, strings, ...options} = expectedPropertiesFromConstructorOptions;
    let internationalizer = i18n(options);
    for (const property in options) {
      expect(internationalizer[property]).toEqual(options[property]);
    }
    // Check that _falsy_ values are interpreted as `false` except for `undefined`, which is interpreted as the default value.
    internationalizer = i18n({...options, updateFile: '', fallbackToLanguage: null});
    for (const property in options) {
      expect(internationalizer[property]).toEqual(options[property]);
    }
    internationalizer = i18n({...options, updateFile: 0, fallbackToLanguage: NaN});
    for (const property in options) {
      expect(internationalizer[property]).toEqual(options[property]);
    }
  });

  test('Detect new or deleted object properties and methods', () => {
    // Fixing a failure of this tests implies to add a new test
    // or to check the new element is considered by the other tests.
    const internationalizer = i18n();
    expect(Object.keys(internationalizer).length).toBe(8);
  });

  test('Constructor fails when the encoding is included in the locale string', () => {
    expect.assertions(2);
    const cubaLocale = 'es-CU.UTF-8';
    try {
      i18n({locale: cubaLocale});
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toBe(`Invalid locale option: '${cubaLocale}'`);
    }
  });

  test('Constructor fails when an invalid locale is used', () => {
    expect.assertions(2);
    const notAnOfficialLocale = 'en-ZZ';
    try {
      i18n({locale: notAnOfficialLocale});
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toBe(`Invalid locale option: '${notAnOfficialLocale}'`);
    }
  });

  test('The different usage modes produce the same result', () => {
    const {___, t} = i18n();
    const text = 'Hello World!';

    // Simple string
    expect(___`Hello World!`).toBe(text);
    expect(___(`Hello World!`)).toBe(text);
    expect(___('Hello World!')).toBe(text);
    expect(___(text)).toBe(text);

    expect(t(`Hello World!`)).toBe(text);
    expect(t('Hello World!')).toBe(text);
    expect(t(text)).toBe(text);

    // Interpolated string
    expect(___`Hello ${'World'}!`).toBe(text);
    expect(___(`Hello ${'World'}!`)).toBe(text);
    // eslint-disable-next-line no-useless-concat
    expect(___('Hello ' + `${'World!'}`)).toBe(text);
    expect(t(`Hello ${'World'}!`)).toBe(text);
    // eslint-disable-next-line no-useless-concat
    expect(t('Hello ' + `${'World!'}`)).toBe(text);

    // Substitutions, sprintf-like
    expect(___(`Hello %s`, 'World!')).toBe(text);
    expect(___('Hello %s', 'World!')).toBe(text);
    expect(t(`Hello %s`, 'World!')).toBe(text);
    expect(t('Hello %s', 'World!')).toBe(text);
  });

  test('Truthy and Falsy values are interpreted correctly', () => {
    expect.assertions(2);

    const {___} = i18n();

    expect(
      ___`[true: ${true}, 1: ${1}, -2: ${-2}, 'a': ${'a'}, ' ': ${' '}, 'true': ${'true'}, 'false': ${'false'}, {}: ${{}}, []: ${[]}, Infinity: ${Infinity}]`
    ).toBe(
      `[true: ${true}, 1: ${1}, -2: ${-2}, 'a': ${'a'}, ' ': ${' '}, 'true': ${'true'}, 'false': ${'false'}, {}: ${{}}, []: ${[]}, Infinity: ${Infinity}]`
    );

    expect(
      ___`[undefined: ${undefined}, null: ${null}, false: ${false}, -0: ${-0}, 0: ${0}, 0.0000: ${0.0}, NaN: ${NaN}, '': ${''}]`
    ).toBe(
      `[undefined: ${undefined}, null: ${null}, false: ${false}, -0: ${-0}, 0: ${0}, 0.0000: ${0.0}, NaN: ${NaN}, '': ${''}]`
    );
  });

  test('Known issues', () => {
    const {___} = i18n();

    expect.assertions(1);
    expect(___`() => {}: ${() => {}}`)
      // .toBe(`() => {}: ${() => {}}`) // This is the correct value:
      .toBe(`() => {}: ${undefined}`); // The underlying 'sprintf-js' library processes incorrectly the function values and produces the 'undefined' string value.
  });
});

describe('Localized strings files', () => {
  // Tests fail because the 'yarn install' operation takes longer than the default timeout of five seconds.
  jest.setTimeout(100000);

  const fse = require('fs-extra');
  const path = require('path');
  const createTempDir = require('tmp-promise').dir;
  const util = require('util');
  const execFile = util.promisify(require('child_process').execFile);

  let tempDir;
  let workDir;
  let localesDir;
  let i18nConfig;
  const filename = 'hello.js';
  const usLocale = 'en-US';
  const mexicoLocale = 'es-MX';
  const germanyLocale = 'de-DE';
  const ukLocale = 'en-GB';
  const argentinaLocale = 'es-AR';
  const peruLocale = 'es-PE';
  const frenchLocale = 'fr';
  const canadaLocale = 'fr-CA';
  const belizeLocale = 'en-BZ';
  const guatemalaLocale = 'es-GT';
  const venezuelaLocale = 'es-VE';

  beforeAll(async () => {
    // Create a temporary directory to work on, which is destroyed at the end of the test.
    try {
      tempDir = await createTempDir({
        unsafeCleanup: true,
        dir: path.resolve('.'),
        prefix: 'tests-temp-dir-'
      });
    } catch (error) {
      expect(error).toBeUndefined();
    }
    expect(tempDir).toBeDefined();
    workDir = tempDir.path;

    // Set up the i18n module.
    localesDir = path.join(workDir, 'locales');
    i18nConfig = i18n({directory: localesDir});

    // Create a sample program to run.
    const filepath = path.join(workDir, filename);
    try {
      await fse.writeFile(filepath, generateSampleProgram());
    } catch (error) {
      expect(error).toBeUndefined();
    }

    // Copy the utilities module to the working (temp) directory.
    const source = `${sourceCodeDir}/.`;
    const destination = '.';
    const sourcePath = path.join(__dirname, source);
    const destPath = path.join(workDir, destination);
    try {
      await fse.copy(sourcePath, destPath, {
        filter: src => {
          const exclude = ['.test.js', '-lock.json', 'node_modules'];

          return !exclude.reduce((result, element) => result || src.includes(element), false);
        }
      });
    } catch (error) {
      expect(error).toBeUndefined();
    }
  });

  afterAll(() => {
    // Delete the temporary work directory
    tempDir.cleanup();
  });

  describe('Verifies that a string is localized without having to run a sample program', () => {
    let localesDir;
    const unaccessibleFilePermission = 0o000;
    const accessibleFilePermission = 0o777;

    beforeAll(async () => {
      localesDir = path.join(workDir, 'yetAnotherLocales');

      // Create the locales folder
      try {
        await fse.ensureDir(localesDir);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Create a sample localized strings file.
      const strings = {
        'Hello World!': '¡Hola Mundo!',
        'Hello %s!': '¡Hola %s!'
      };

      const filename = `${mexicoLocale}.json`;
      const filepath = path.join(localesDir, filename);
      try {
        await fse.writeFile(filepath, JSON.stringify(strings, null, 2));
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    afterAll(async () => {
      // Delete the locales folder
      try {
        await fse.remove(localesDir);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    test('Strings are localized', () => {
      const {___, t} = i18n({directory: localesDir, locale: mexicoLocale});
      const text = 'Hello World!';
      const expectedText = '¡Hola Mundo!';
      const expectedTextChicano = '¡Hola World!';

      // Simple string
      expect(___`Hello World!`).toBe(expectedText);
      expect(___(`Hello World!`)).toBe(expectedText);
      expect(___('Hello World!')).toBe(expectedText);
      expect(___(text)).toBe(expectedText);

      expect(t(`Hello World!`)).toBe(expectedText);
      expect(t('Hello World!')).toBe(expectedText);
      expect(t(text)).toBe(expectedText);

      // Interpolated string
      expect(___`Hello ${'World'}!`).toBe(expectedTextChicano);
      expect(___(`Hello ${'World'}!`)).toBe(expectedText);
      // eslint-disable-next-line no-useless-concat
      expect(___('Hello ' + `${'World!'}`)).toBe(expectedText);
      expect(t(`Hello ${'World'}!`)).toBe(expectedText);
      // eslint-disable-next-line no-useless-concat
      expect(t('Hello ' + `${'World!'}`)).toBe(expectedText);

      // Substitutions, sprintf-like
      expect(___(`Hello %s!`, 'World')).toBe(expectedTextChicano);
      expect(___('Hello %s!', 'World')).toBe(expectedTextChicano);
      expect(t(`Hello %s!`, 'World')).toBe(expectedTextChicano);
      expect(t('Hello %s!', 'World')).toBe(expectedTextChicano);
    });

    test('Localized strings file is updated', () => {
      const {___} = i18n({directory: localesDir, locale: mexicoLocale, updateFile: true});
      const expectedText = '¡Hola Mundo!';

      // Simple string
      expect(___`Hello World!`).toBe(expectedText);
    });

    test('Error message when Locale is invalid', () => {
      expect(() => i18n({locale: 'Not a locale'})).toThrowError(new Error("Invalid locale option: 'Not a locale'"));
    });

    testSkippedOnWindows('Error message when localized strings file is unreadable', async () => {
      // Create a sample localized strings file.
      const strings = {
        'Hello World!': '',
        'Hello %s!': ''
      };

      // Make the localized strings file unreadable.
      const filename = `${canadaLocale}.json`;
      const filepath = path.join(localesDir, filename);
      try {
        await fse.writeFile(filepath, JSON.stringify(strings, null, 2));
        await fse.chmod(filepath, unaccessibleFilePermission);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Attempt to use the naughty file.
      expect(() => i18n({directory: localesDir, locale: canadaLocale})).toThrowError(
        /^EACCES: permission denied, open/
      );

      // Delete the unreadable localized strings file.
      try {
        await fse.chmod(filepath, accessibleFilePermission);
        await fse.remove(filepath);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    testSkippedOnWindows('Error message when language-based localized strings file is unreadable', async () => {
      // Create a sample localized strings file.
      const strings = {
        'Hello World!': '',
        'Hello %s!': ''
      };

      // Make the localized strings file unreadable.
      const filename = 'en.json';
      const filepath = path.join(localesDir, filename);
      try {
        await fse.writeFile(filepath, JSON.stringify(strings, null, 2));
        await fse.chmod(filepath, unaccessibleFilePermission);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Attempt to use the naughty file.
      expect(() => i18n({directory: localesDir, locale: 'en-CA'})).toThrowError(/^EACCES: permission denied, open/);

      // Delete the unreadable localized strings file.
      try {
        await fse.chmod(filepath, accessibleFilePermission);
        await fse.remove(filepath);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });
  });

  describe('Behavior related to the "locales" folder', () => {
    test('Program runs without error when the "./locales" folder is missing and options are default', async () => {
      expect.assertions(0);

      // Run the sample program and check it fails as expected.
      try {
        await execFile('node', [filename], {cwd: workDir});
      } catch (error) {
        expect(error).toBeUndefined();
        expect(error.stdout).toBeDefined();
        expect(error.stderr).toBeFalsy();
      }
    });

    test('The message when the program exits with error because the "./locales" folder is missing and options are set to use it.', async () => {
      expect.assertions(8);

      // Create a sample program to run.
      // The 'updateFile' configuration option is set to 'true' so the localized strings file should be produced.
      const filename = 'hello_world_that_fails.js';
      const filepath = path.join(workDir, filename);
      try {
        await fse.writeFile(filepath, generateSampleProgram({updateFile: true}));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the sample program and check it fails as expected.
      try {
        await execFile('node', [filename], {cwd: workDir});
      } catch (error) {
        expect(error).toBeDefined();
        expect(error.stdout).toBeDefined();
        expect(error.stderr).toBeFalsy();

        const errorOutput = error.stdout.split(/\r?\n/);
        // Check error message
        expect(errorOutput[0]).toBe('Hello World!');
        expect(errorOutput[1]).toMatch('(i18n) Error. Failed to save the localized strings to: ');
        // Check localized strings destination file
        const localeFile = path.resolve(i18nConfig.directory, `${i18nConfig.locale}.json`);
        expect(errorOutput[1].endsWith(localeFile)).toBeTruthy();
        // Check hint message
        expect(errorOutput[2]).toMatch(/\(i18n\) Does the '[^']+' folder exist\?/);
        // Check localized strings destination directory
        expect(errorOutput[2]).toMatch(`'${i18nConfig.directory}'`);
      }
    });

    test('A new localized strings file is saved on the "./locales" folder for the default locale', async () => {
      expect.assertions(5);

      // Create the locales folder
      try {
        await fse.ensureDir(localesDir);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Create a sample program to run.
      // The 'updateFile' configuration option is set to 'true' so the localized strings file should be produced.
      const filename = 'hello_world_with_new_localized_text.js';
      const filepath = path.join(workDir, filename);
      try {
        await fse.writeFile(filepath, generateSampleProgram({updateFile: true}));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the sample program and check the message printed to the console.
      const originalText = 'Hello World!';
      try {
        // Run the sample program
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir});
        expect(stdout).toMatch(originalText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the new localized strings file exists
      const localizedStringsFilepath = path.join(localesDir, `${i18nConfig.locale}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the content of the localized strings file is correct. This file can be used as template for other locales.
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
      } catch (error) {
        expect(error).toBeUndefined();
      }
      expect(fileContent).toBeDefined();
      const localizationStrings = JSON.parse(fileContent);
      expect(localizationStrings).toEqual({[originalText]: ''});
    });

    test('A new localized strings file is saved on the "./locales" folder for the "de-DE" environment locale', async () => {
      expect.assertions(5);

      // Check the locales folder exists
      await fse.ensureDir(localesDir);

      // Create a sample program to run.
      // The 'updateFile' configuration option is set to 'true' so the localized strings file should be produced.
      const filename = 'hello_world_for_german.js';
      const filepath = path.join(workDir, filename);
      try {
        await fse.writeFile(filepath, generateSampleProgram({updateFile: true}));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Change the runtime locale to the German locale and run the sample program.
      // Then, check the message printed to the console.
      // We expect the text to be on the default locale.
      const originalText = 'Hello World!';
      const env = {...process.env, LANG: germanyLocale};
      try {
        // Run the sample program
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toMatch(originalText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the new localized strings file exists
      const localizedStringsFilepath = path.join(localesDir, `${germanyLocale}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the content of the localized strings file is correct. This file can be used as a template.
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
      } catch (error) {
        expect(error).toBeUndefined();
      }
      expect(fileContent).toBeDefined();
      const localizationStrings = JSON.parse(fileContent);
      expect(localizationStrings).toEqual({[originalText]: ''});
    });

    test('A new localized strings file is saved on the "./locales" folder for the "en-GB" configuration locale', async () => {
      // Also tests the case where a locale set on the i18n() constructor
      expect.assertions(7);

      // Check the locales folder exists
      await fse.ensureDir(localesDir);

      // Create a sample program to run.
      // The locale in the program is hard-coded to UK locale.
      const filename = 'alright_world.js';
      const filepath = path.join(workDir, filename);
      try {
        await fse.writeFile(filepath, generateSampleProgram({locale: ukLocale, updateFile: 'true'}));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the sample program.
      // Then, check the message printed to the console.
      // We expect the text to be on the configured locale.
      const originalText = 'Hello World!';
      try {
        // Run the sample program. Note how the environment variables are left untouched.
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir});
        expect(stdout).toMatch(originalText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the new localized strings file exists
      const ukLocaleWithoutEncoding = ukLocale;
      const localizedStringsFilepath = path.join(localesDir, `${ukLocaleWithoutEncoding}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the content of the localized strings file is correct. This file can be used as a template.
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
      } catch (error) {
        expect(error).toBeUndefined();
      }
      expect(fileContent).toBeDefined();
      const localizationStrings = JSON.parse(fileContent);
      expect(localizationStrings).toEqual({[originalText]: ''});

      // Modify the localization text for the single entry and save it.
      const localizedText = 'Alright World?';
      localizationStrings[originalText] = localizedText;
      try {
        await fse.writeFile(localizedStringsFilepath, JSON.stringify(localizationStrings, null, 2));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program again and check the localized text is used instead of the original one.
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir});
        expect(stdout).toMatch(localizedText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    test('No localized strings file is created when the "updateFile" configuration option is "false"', async () => {
      expect.assertions(3);

      // Create the locales folder
      await fse.ensureDir(localesDir);

      // Create a sample program to run.
      // The 'updateFile' configuration option is set to 'false' so no localized strings file should be produced.
      const filename = 'hello_world_no_template.js';
      const filepath = path.join(workDir, filename);
      try {
        await fse.writeFile(filepath, generateSampleProgram({updateFile: false, locale: argentinaLocale}));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the sample program and check the message printed to the console.
      const originalText = 'Hello World!';
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir});
        expect(stdout).toMatch(originalText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the new localized strings file does NOT exist
      const localizedStringsFilepath = path.join(localesDir, `${argentinaLocale}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(false);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });
  });

  describe('Text localization works', () => {
    test('Localization on the same language', async () => {
      expect.assertions(5);

      // Check the locales folder exists
      await expect(fse.ensureDir(localesDir)).resolves.toBeFalsy();

      if (i18n.locale !== usLocale) {
        // Create the localized strings file if the system locale is an unexpected one.
        const localizationStrings = {'Hello World!': ''};
        const usStringsFile = path.join(localesDir, `${usLocale}.json`);
        try {
          await fse.writeFile(usStringsFile, JSON.stringify(localizationStrings, null, 2));
        } catch (error) {
          expect(error).toBeUndefined();
        }
      }

      // Check the localized strings file exists
      const localizedStringsFilepath = path.join(localesDir, `${usLocale}.json`);
      await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);

      // Check the content of the localized strings file is correct. This file can be used as template for other locales.
      const fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
      const localizationStrings = JSON.parse(fileContent);
      const originalText = 'Hello World!';
      expect(localizationStrings).toEqual({[originalText]: ''});

      // Note:
      //   Any failure up to this point should have been caught by the previous tests.

      const env = {...process.env};
      if (i18n.locale !== usLocale) {
        env.LANG = usLocale;
      }

      // Modify the localization text for the single entry and save it.
      const localizedText = 'Howdy World!';
      localizationStrings[originalText] = localizedText;
      try {
        await fse.writeFile(localizedStringsFilepath, JSON.stringify(localizationStrings, null, 2));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program and check the localized text is used instead of the original one.
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toMatch(localizedText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    test('Localization to the "de-DE" locale', async () => {
      expect.assertions(7);

      // Check the locales folder exists
      await fse.ensureDir(localesDir);

      // Change the runtime locale to the German locale and run the sample program.
      // Then, check the message printed to the console.
      // We expect the text to be on the default locale.
      const originalText = 'Hello World!';
      const env = {...process.env, LANG: germanyLocale};

      // Run the sample program
      const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
      expect(stdout).toMatch(originalText);
      expect(stderr).toBeFalsy();

      // Check the new localized strings file exists
      const localizedStringsFilepath = path.join(localesDir, `${germanyLocale}.json`);
      await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);

      // Check the content of the localized strings file is correct. This file can be used as a template.
      const fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
      expect(fileContent).toBeDefined();
      const localizationStrings = JSON.parse(fileContent);
      expect(localizationStrings).toEqual({[originalText]: ''});

      // Note:
      //   Any failure up to this point should have been caught by the previous tests.

      // Modify the localization text for the single entry and save it.
      const localizedText = '[de]Hello World![de]';
      localizationStrings[originalText] = localizedText;
      try {
        await fse.writeFile(localizedStringsFilepath, JSON.stringify(localizationStrings, null, 2));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program in the German locale and check the localized text is used instead of the original one.
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toMatch(localizedText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    describe('Using positional and named arguments', () => {
      let programName;

      beforeAll(async () => {
        // Check the locales folder exists
        await fse.ensureDir(localesDir);

        // Create the localized strings file
        const localizedStringsFilepath = path.join(localesDir, `${venezuelaLocale}.json`);
        const localizedStrings = {
          'Hello World!': '',
          'ascending: %s, %s, and %s': 'descending: %3$s, %2$s, and %1$s',
          'ascending: %(one)s, %(two)s, and %(three)s': 'descending: %(three)s, %(two)s, and %(one)s',
          'count: %s, %s, and %s': 'count: %s, %s, and %s',
          'arrival: %(one)s, %(two)s, and %(three)s': 'arrival: %(one)s, %(two)s, and %(three)s',
          'list: %s, %s, and %s': '',
          'order: %(one)s, %(two)s, and %(three)s': ''
        };
        try {
          await fse.writeFile(localizedStringsFilepath, JSON.stringify(localizedStrings, null, 2));
        } catch (error) {
          expect(error).toBeUndefined();
        }

        // Create a sample program to run.
        /* eslint-disable no-template-curly-in-string */
        const additionalCode = [
          "const dict = {one: 'one', two: 'two', three: 'three'}",
          "const ordinal = {one: 'first', two: 'second', three: 'third'}",
          "console.log(`Locale '${process.env.LANG}'`)",
          "console.log('- Positional arguments')",
          // The order of these numbers is changed on the localized strings file:
          'console.log(___`ascending: ${dict.one}, ${dict.two}, and ${dict.three}`)',
          "console.log('- Named arguments')",
          // The order of these numbers is changed on the localized strings file:
          "console.log(___('ascending: %(one)s, %(two)s, and %(three)s', ordinal))",
          "console.log('- Will not change the order')",
          'console.log(___`count: ${dict.one}, ${dict.two}, and ${dict.three}`)',
          "console.log(___('arrival: %(one)s, %(two)s, and %(three)s', ordinal))",
          "console.log('- Will not localize')",
          'console.log(___`list: ${dict.one}, ${dict.two}, and ${dict.three}`)',
          "console.log(___('order: %(one)s, %(two)s, and %(three)s', ordinal))"
        ];
        /* eslint-enable no-template-curly-in-string */
        programName = 'hello-world-with-positional-and-named-arguments.js';
        const filepath = path.join(workDir, programName);
        try {
          await fse.writeFile(filepath, generateSampleProgram({}, additionalCode));
        } catch (error) {
          expect(error).toBeUndefined();
        }
      });

      test('When relocated, arguments have the expected position', async () => {
        expect.assertions(3);

        const expectedOutput = [
          'Hello World!',
          "Locale 'es-VE'",
          '- Positional arguments',
          // The order of these numbers was changed on the localized strings file:
          'descending: three, two, and one',
          '- Named arguments',
          // The order of these numbers was changed on the localized strings file:
          'descending: third, second, and first',
          '- Will not change the order',
          'count: one, two, and three',
          'arrival: first, second, and third',
          '- Will not localize',
          'list: one, two, and three',
          'order: first, second, and third',
          ''
        ];

        // Run the program in the Venezuelan locale and check the localized text is used instead of the original one.
        const env = {...process.env, LANG: venezuelaLocale};
        let stdoutLines;
        try {
          const {stdout, stderr} = await execFile('node', [programName], {cwd: workDir, env});
          expect(stdout).toBeDefined();
          expect(stderr).toBeFalsy();
          stdoutLines = stdout.split(/\r?\n/);
        } catch (error) {
          expect(error).toBeUndefined();
        }
        expect(stdoutLines).toEqual(expectedOutput);
      });

      test('When NOT relocated, arguments have the expected position', async () => {
        expect.assertions(3);

        const expectedOutput = [
          'Howdy World!',
          "Locale 'en-US'",
          '- Positional arguments',
          // The order of these numbers was NOT changed on the localized strings file:
          'ascending: one, two, and three',
          '- Named arguments',
          // The order of these numbers was NOT changed on the localized strings file:
          'ascending: first, second, and third',
          '- Will not change the order',
          'count: one, two, and three',
          'arrival: first, second, and third',
          '- Will not localize',
          'list: one, two, and three',
          'order: first, second, and third',
          ''
        ];

        // Run the program in the US locale and check the original text is used.
        const env = {...process.env, LANG: usLocale};
        let stdoutLines;
        try {
          const {stdout, stderr} = await execFile('node', [programName], {cwd: workDir, env});
          expect(stdout).toBeDefined();
          expect(stderr).toBeFalsy();
          stdoutLines = stdout.split(/\r?\n/);
        } catch (error) {
          expect(error).toBeUndefined();
        }
        expect(stdoutLines).toEqual(expectedOutput);
      });
    });

    test("A localized strings file on the locale's language is used when the exact locale is missing and the 'fallbackToLanguage' configuration option is 'true'", async () => {
      expect.assertions(4);

      // Check the locales folder exists
      await fse.ensureDir(localesDir);

      // Check the 'en-US' localized strings file exist and read its content (use it as template).
      let localizedStringsFilepath = path.join(localesDir, `${i18nConfig.locale}.json`);
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
        expect(fileContent).toBeDefined();
      } catch (error) {
        expect(error).toBeUndefined();
      }
      const localizationStrings = JSON.parse(fileContent);

      // Modify the localization text for the single entry and save it as the French locale.
      const originalText = 'Hello World!';
      const localizedText = 'Bonjour le monde!';
      localizationStrings[originalText] = localizedText;
      localizedStringsFilepath = path.join(localesDir, `${frenchLocale}.json`);
      try {
        await fse.writeFile(localizedStringsFilepath, JSON.stringify(localizationStrings, null, 2));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Create a sample program.
      const filename = 'hello_world_french.js';
      const filepath = path.join(workDir, filename);
      try {
        await fse.writeFile(filepath, generateSampleProgram({fallbackToLanguage: true, updateFile: false}));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program in the Canadian French locale and check the French-localized text ("fr") is used despite of the missing "fr-CA" file.
      const env = {...process.env, LANG: canadaLocale};
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toMatch(localizedText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the 'fr-CA' localized strings file was NOT generated.
      localizedStringsFilepath = path.join(localesDir, `${canadaLocale}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(false);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    test("The English text is used even when there is a localized strings file for the locale's language and the 'fallbackToLanguage' configuration option is 'false'", async () => {
      expect.assertions(5);

      // Check the locales folder exists
      await fse.ensureDir(localesDir);

      // Check the French ('fr') localized strings file exist and its content is right.
      let localizedStringsFilepath = path.join(localesDir, `${frenchLocale}.json`);
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
        expect(fileContent).toBeDefined();
      } catch (error) {
        expect(error).toBeUndefined();
      }
      const localizationStrings = JSON.parse(fileContent);
      const originalText = 'Hello World!';
      const localizedText = 'Bonjour le monde!';
      expect(localizationStrings[originalText]).toBe(localizedText);

      // Create a sample program.
      const filename = 'hello_world_french.js';
      const filepath = path.join(workDir, filename);
      try {
        await fse.writeFile(filepath, generateSampleProgram({fallbackToLanguage: false, updateFile: false}));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program in the Canadian French locale and check the English text is used despite of the existing "fr" file.
      const env = {...process.env, LANG: canadaLocale};
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toMatch(originalText);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the 'fr-CA' localized strings file was NOT generated.
      localizedStringsFilepath = path.join(localesDir, `${canadaLocale}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(false);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    test('The localized strings file is updated when the "updateFile" configuration option is "true" and the sample program runs', async () => {
      expect.assertions(8);

      // Check the locales folder exists.
      await fse.ensureDir(localesDir);

      // Create a sample program.
      const filename = 'hello_world_belize.js';
      const filepath = path.join(workDir, filename);
      let sampleProgram = generateSampleProgram({updateFile: true});
      try {
        await fse.writeFile(filepath, sampleProgram);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program in the 'en-BZ' locale to create a localized string file.
      const env = {...process.env, LANG: belizeLocale};
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toBeTruthy();
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the 'en-BZ' localized strings file was generated.
      const localizedStringsFilepath = path.join(localesDir, `${belizeLocale}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Add a new localized text to the program.
      const originalText = 'Hello World!';
      const addedText = 'Start working';
      sampleProgram += `${EOL}console.log(___('${addedText}'))${EOL}`;
      try {
        await fse.writeFile(filepath, sampleProgram);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program again.
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toBeTruthy();
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the 'en-BZ' localized strings file has two elements now.
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
        expect(fileContent).toBeDefined();
      } catch (error) {
        expect(error).toBeUndefined();
      }
      const localizationStrings = JSON.parse(fileContent);
      expect(Object.keys(localizationStrings)).toHaveLength(2);
      expect(localizationStrings).toEqual({[originalText]: '', [addedText]: ''});
    });

    test('The localized strings file is NOT updated when the "updateFile" configuration option is "false" and the sample program runs', async () => {
      expect.assertions(8);

      // Check the locales folder exists.
      await fse.ensureDir(localesDir);

      // Delete the 'en-BZ' localized strings file if it exists.
      const localizedStringsFilepath = path.join(localesDir, `${belizeLocale}.json`);
      try {
        if (await fse.pathExists(localizedStringsFilepath)) {
          await fse.unlink(localizedStringsFilepath);
        }
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Create a sample program.
      const filename = 'hello_world_belize.js';
      const filepath = path.join(workDir, filename);
      let sampleProgram = generateSampleProgram({updateFile: true});
      try {
        await fse.writeFile(filepath, sampleProgram);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program in the 'en-BZ' locale to create a localized string file.
      const env = {...process.env, LANG: belizeLocale};
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toBeTruthy();
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the 'en-BZ' localized strings file was generated.
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Add a new localized text to the program and set the 'updateFile' option to 'false'.
      const originalText = 'Hello World!';
      const addedText = 'Start working';
      sampleProgram = generateSampleProgram({updateFile: false});
      sampleProgram += `${EOL}console.log(___('${addedText}'))${EOL}`;
      try {
        await fse.writeFile(filepath, sampleProgram);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program again.
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toBeTruthy();
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the 'en-BZ' localized strings file has only the original element, i.e., it was NOT updated.
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
        expect(fileContent).toBeDefined();
      } catch (error) {
        expect(error).toBeUndefined();
      }
      const localizationStrings = JSON.parse(fileContent);
      expect(Object.keys(localizationStrings)).toHaveLength(1);
      expect(localizationStrings).toEqual({[originalText]: ''});
    });

    test('Tagged literals are saved properly in the localization file', async () => {
      expect.assertions(9);

      // Check the locales folder exists.
      await fse.ensureDir(localesDir);

      // Create a sample program.
      const filename = 'hello_world_peru.js';
      const filepath = path.join(workDir, filename);
      let sampleProgram = generateSampleProgram({locale: peruLocale, updateFile: true});
      sampleProgram += [
        '',
        /* eslint-disable no-template-curly-in-string */
        'console.log(___`a: ${1}`)',
        'console.log(___`a: ${1}, b: ${2}`)',
        'console.log(___`a: ${1}, b: ${2}, c: ${"three"}`)',
        'console.log(___`some percentage printed using the primitive value: ${1000000000/10000001}%%`)',
        /* eslint-enable no-template-curly-in-string */
        'console.log(___("some percentage printed using the precision modifier: %.6f%%", 1000000000/10000001))'
      ].join(EOL);
      try {
        await fse.writeFile(filepath, sampleProgram);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program in the Peru locale to create a localized string file.
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir});
        expect(stdout).toBeTruthy();
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Check the Peru-localized strings file was generated.
      const localizedStringsFilepath = path.join(localesDir, `${peruLocale}.json`);
      try {
        await expect(fse.pathExists(localizedStringsFilepath)).resolves.toBe(true);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Defined the expected values
      const keys = [
        'Hello World!',
        'a: %s',
        'a: %s, b: %s',
        'a: %s, b: %s, c: %s',
        'some percentage printed using the primitive value: %s%%',
        'some percentage printed using the precision modifier: %.6f%%'
      ];
      const localizedValues = [
        '!Hola mundo!',
        '[es]a: %s[es]',
        '[es]a: %s, b: %s[es]',
        '[es]a: %s, b: %s, c: %s[es]',
        'algún porcentaje impreso usando el value primitivo: %s%%',
        'algún porcentaje impreso usando el modificador de precisión: %.6f%%'
      ];

      // Check the Peru-localized strings file has four elements now, and they have a expected value.
      let fileContent;
      try {
        fileContent = await fse.readFile(localizedStringsFilepath, {encoding: 'utf8'});
        expect(fileContent).toBeDefined();
      } catch (error) {
        expect(error).toBeUndefined();
      }
      const localizationStrings = JSON.parse(fileContent);
      expect(Object.keys(localizationStrings)).toHaveLength(6);
      expect(localizationStrings).toEqual({
        [keys[0]]: '',
        [keys[1]]: '',
        [keys[2]]: '',
        [keys[3]]: '',
        [keys[4]]: '',
        [keys[5]]: ''
      });

      // Add the translations to the localized strings cache
      [
        localizationStrings[[keys[0]]],
        localizationStrings[[keys[1]]],
        localizationStrings[[keys[2]]],
        localizationStrings[[keys[3]]],
        localizationStrings[[keys[4]]],
        localizationStrings[[keys[5]]]
      ] = localizedValues;

      // Save the translations to the localized strings file
      try {
        await fse.writeFile(localizedStringsFilepath, JSON.stringify(localizationStrings, null, 2));
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Run the program again and check the localized text is used instead of the original one.
      const printedValues = [
        '!Hola mundo!',
        '[es]a: 1[es]',
        '[es]a: 1, b: 2[es]',
        '[es]a: 1, b: 2, c: three[es]',
        'algún porcentaje impreso usando el value primitivo: 99.999990000001%',
        'algún porcentaje impreso usando el modificador de precisión: 99.999990%',
        ''
      ];
      let stdoutLines;
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir});
        expect(stdout).toBeDefined();
        stdoutLines = stdout.split(/\r?\n/);
        expect(stderr).toBeFalsy();
      } catch (error) {
        expect(error).toBeUndefined();
      }
      expect(stdoutLines).toEqual(printedValues);
    });

    test('Exception is thrown when the localized strings file (*.json) is invalid', async () => {
      expect.assertions(2);

      // Check the locales folder exists
      await fse.ensureDir(localesDir);

      // Create an invalid localized strings file (incorrect JSON format).
      const localizedStringsFilepath = path.join(localesDir, `${guatemalaLocale}.json`);
      const invalidLocalizationStrings = "{'Hello World!': ''}";
      try {
        await fse.writeFile(localizedStringsFilepath, invalidLocalizationStrings);
      } catch (error) {
        expect(error).toBeUndefined();
      }

      // Change the runtime locale to the Guatemala locale and run the sample program.
      const env = {...process.env, LANG: guatemalaLocale};

      // Run the program in the Guatemala locale and check it stops and an error message is printed.
      try {
        const {stdout, stderr} = await execFile('node', [filename], {cwd: workDir, env});
        expect(stdout).toBeUndefined();
        expect(stderr).toBeUndefined();
      } catch (error) {
        expect(error).toBeDefined();
        expect(error.message).toMatch(
          /SyntaxError: [^ ]+[/\\]+locales[/\\]+es-GT.json: Unexpected token ' in JSON at position 1/
        );
      }
    });
  });
});
