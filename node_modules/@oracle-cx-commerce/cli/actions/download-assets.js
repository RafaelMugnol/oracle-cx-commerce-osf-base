/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const logger = require('@oracle-cx-commerce/logger/cli');
const {downloadAssets} = require('@oracle-cx-commerce/cli-shared');
const {promptConfirmOverwriteWorkspaceFiles} = require('@oracle-cx-commerce/cli-shared').cliHelperMethods;
const {getAssetDownloadZipFilePath} = require('@oracle-cx-commerce/tools-util/deployment');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});
const yauzl = require('yauzl');
const fs = require('fs-extra');

function writeAssetsToWorkspace(options, assetZipLocation, assetFolderLocation) {
  return new Promise((resolve, reject) => {
    if (options.reset) {
      fs.removeSync(assetFolderLocation, {recursive: true});
    }
    yauzl.open(assetZipLocation, {lazyEntries: true}, function (err, zipfile) {
      if (err) {
        console.log(err);
        reject(err);
      }
      zipfile.readEntry();
      zipfile
        .on('entry', function (entry) {
          zipfile.openReadStream(entry, function (err, readStream) {
            if (err) {
              console.log(err);
              reject(err);
            }
            readStream.on('end', function () {
              zipfile.readEntry();
            });

            const {fileName} = entry;
            logger.verbose(fileName);
            const fileLocation = path.resolve(assetFolderLocation, fileName);
            const dirToCreate = path.dirname(fileLocation);
            fs.mkdirpSync(dirToCreate);
            readStream.pipe(fs.createWriteStream(fileLocation));
            //zipfile.readEntry();
          });
        })
        .on('close', function () {
          resolve();
        });
    });
  });
}

module.exports = async (appName, options) => {
  try {
    let assetDownloadLocation;
    if (options.fromFile) {
      logger.info(___`Loading assets for app ${appName} from ${options.fromFile}`);
      if (!fs.existsSync(options.fromFile)) {
        throw new Error(___`Specified zip file from which to load assets, ${options.fromFile}, doesn't exist.`);
      }
      assetDownloadLocation = options.fromFile;
    } else {
      // Download the zip to either the user-specified location or to a folder in the appDir
      assetDownloadLocation =
        options.dest || getAssetDownloadZipFilePath(options.appServerAdmin, appName, !options.live);
      logger.info(___`Downloading assets for app ${appName} from ${options.appServerAdmin}...`);
      await downloadAssets({
        appName,
        appKey: options.appKey,
        preview: !options.live,
        appServerAdmin: options.appServerAdmin,
        downloadLocation: assetDownloadLocation
      });
      logger.info(___`Successfully downloaded assets to ${assetDownloadLocation}`);
    }
    // If user didn't want the files to overwrite their local assets, and just wanted to fetch a zip, stop here
    if (!options.import) {
      return;
    }
    const confirm = await promptConfirmOverwriteWorkspaceFiles(options);
    if (!confirm) {
      return;
    }

    //this is the location to unzip the assets. ths default is the application's assets folder
    const assetsLocation = path.resolve(options.appDir, 'assets');
    await writeAssetsToWorkspace(options, assetDownloadLocation, assetsLocation);
  } catch (error) {
    // log the errors
    if (error.response && error.response.status === 404) {
      logger.info(___`Application assets not found`);
    } else {
      throw error;
    }
  }
};
