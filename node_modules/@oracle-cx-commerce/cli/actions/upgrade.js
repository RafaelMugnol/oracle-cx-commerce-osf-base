/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
/* eslint-env node */

const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');
const semver = require('semver');
const {promisify} = require('util');
const {exec} = require('child_process');
const logger = require('@oracle-cx-commerce/logger/cli');
const fetch = require('@oracle-cx-commerce/http-client');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});
const {isOracleCommerce, getOCCRegistry, getOCCVersion, occServerSatisfiesMinVersion} = require('../utils');

const OCC_DEFAULT_MIN_VERSION = '20.3';

/**
 * Returns the current OCC server version based on the server values in options
 * @param {object} options an object containing values used to fetch the server version, namely
 *    'live', 'appServer', and 'appServerAdmin'
 * @returns {string} the OCC server version, e.g. '20.3.5-SNAPSHOT'
 * @throws If the OCC version could not be fetched.
 */
const getOCCServerVersions = async options => {
  try {
    const occVersion = await getOCCVersion(options);

    return occVersion;
  } catch (error) {
    if (options.force) {
      logger.warn(___`Could not get OCC version: ${error.message}`);
      logger.info(___`Continuing due to '--force' option`);

      return;
    }
    logger.error(___`${"'occ upgrade'"} could not determine OCC server version, aborting upgrade.`);
    logger.info(
      ___`If you want to upgrade without checking the OCC server version, use ${"'--no-verifyOcc'"} on the 'occ upgrade' command`
    );
    throw error;
  }
};

/**
 * Fetches available OSF versions from the registry and returns metadata about them.
 * @returns {Array<object>} a map of available OSF versions from the registry, osfVersion -> packageJson of occ-metadata
 * @throws if the registry couldn't be contacted or its response was malformed
 */
const getAvailableOSFVersions = async options => {
  try {
    // Hard-coding the package name below makes me nervous... Is there a better way?
    const packageToCheck = '@oracle-cx-commerce/occ-metadata';
    // Determine the registry to hit
    const registry = await getOCCRegistry();

    // Get the various versions of occ-metadata available
    const response = await fetch(`${registry}${packageToCheck}`);
    if (!response.ok) {
      throw new Error(___`Couldn't contact registry ${registry}: ${response.status} ${response.statusText}`);
    }
    const versionMetadata = await response.json();
    if (!versionMetadata.versions) {
      logger.debug(versionMetadata);
      throw new Error(
        ___`Registry metadata response did not contain expected ${"'versions'"} map - no versions listed for ${packageToCheck}`
      );
    }
    // Now get the engines blocks we need to check from cli-shared, for additional compatibility checks
    const response2 = await fetch(`${registry}@oracle-cx-commerce/cli-shared`);
    const engineRestrictions = ((await response2.json()) || {}).versions;
    if (!response2.ok || !engineRestrictions) {
      logger.warn(
        ___`Could not get registry info on the 'cli-shared' package - will not be able to check for engine (Node, yarn, etc.) compatibility`
      );
    } else {
      Object.keys(versionMetadata.versions).forEach(version => {
        versionMetadata.versions[version].engines = engineRestrictions[version].engines;
      });
    }

    return versionMetadata.versions;
  } catch (error) {
    const errorMsg = ___`${"'occ upgrade'"} couldn't fetch the latest OSF version info from the registry: ${
      error.message
    }`;
    if (options.force) {
      logger.warn(errorMsg);
      logger.info(___`Continuing due to ${"'--force'"} option`);

      return {};
    }
    logger.error(errorMsg);
    throw error;
  }
};

/**
 * Determines the version to which we should upgrade based on a number of parameters
 * @param {string} [givenVersion] The version the user wanted to upgrade to, if one is provided
 *   May NOT be a version range, MUST be a fully qualified version or unspecified
 * @param {string} currentOSFVersion the current version of OSF in use
 * @param {string} [occVersion] the OCC version the OSF version should be in sync with, if any
 * @param {object} osfVersions a map of available OSF versions from the registry, osfVersion -> packageJson of occ-metadata
 * @param {object} options cli options, notably the 'latest', 'verifyOcc' and options related to the OCC server/version
 * @returns {string} the version to which all OSF packages should be updated
 * @throws if it can't determine a valid OSF version based on the parameters provided
 */
const determineUpgradeVersion = (givenVersion, currentOSFVersion, occVersion, osfVersions, options = {}) => {
  // We never expect to actually get LOCAL_NODE_VERSION from options, it's just here for unit testing purposes
  const {verifyOcc, latest, LOCAL_NODE_VERSION = process.version} = options;
  // If given a version string, check if the given OSF version supports the version of OCC
  //   If the given version is incompatible with the OCC version, throw an error
  //   Else, the given version is compatible with the OCC version, return given version
  if (givenVersion) {
    // If there's an entry for the given version in the registry's available versions
    const versionInfo = osfVersions[givenVersion];
    if (versionInfo) {
      // If we're not forcing the change and we have the information to check, try to check for Node compatibility
      if (!semver.satisfies(LOCAL_NODE_VERSION, (versionInfo.engines || {}).node || '>=10')) {
        const nodeIncompatibilityMsg = ___`Version ${givenVersion} of OSF requires a different Node version (${osfVersions[givenVersion].engines.node}) than the one you have (${LOCAL_NODE_VERSION}).`;
        if (!options.force) throw new Error(nodeIncompatibilityMsg);
        logger.warn(nodeIncompatibilityMsg);
        logger.info(___`Continuing due to ${"'--force'"} flag`);
      }

      // If there's no OCC version, no reason to check beyond this point
      if (!occVersion || !verifyOcc) return givenVersion;

      const occMinVersion =
        versionInfo.occ && versionInfo.occ.minVersion ? versionInfo.occ.minVersion : OCC_DEFAULT_MIN_VERSION;
      if (!occServerSatisfiesMinVersion(occVersion, occMinVersion)) {
        // OCC version is less than the occ.minVersion for the given version, throw error
        const errorMsg = ___`Your OCC Server version, ${occVersion} is too low to support OSF version ${givenVersion}.`;
        if (!options.force) {
          throw new Error(
            ___`${errorMsg} To use OSF version ${givenVersion}, upgrade to OCC version ${occMinVersion} or higher. To ignore this error, use the ${"'--no-verifyOcc'"} flag.`
          );
        }
        // If forcing, just log the warning and continue
        logger.warn(errorMsg);
        logger.info(___`Continuing due to ${"'--force'"} flag`);
      }
      // All good, the given version has a min OCC version less than our server's OCC version
      // Fall through to return the givenVersion below
    } else if (!options.force) {
      throw new Error(
        ___`Version ${givenVersion} of OSF (specifically ${'@oracle-cx-commerce/occ-metadata'}) not found on the registry.`
      );
    }
    // Else, if options.force, ignore the error. We've already complained about not being able to contact the registry

    return givenVersion;
  }

  let supportedOSFVersions = Object.keys(osfVersions);
  const versionRestrictions = [___`is on the registry`]; // For logging, later.
  if (verifyOcc && occVersion) {
    // If we aren't ignoring OCC, filter the available OSF versions to those that would work with OCC
    supportedOSFVersions = supportedOSFVersions.filter(version =>
      occServerSatisfiesMinVersion(occVersion, (osfVersions[version].occ || {}).minVersion || OCC_DEFAULT_MIN_VERSION)
    );
    versionRestrictions.push(___`can run against your OCC server version (${occVersion})`);
  }

  supportedOSFVersions = supportedOSFVersions.filter(version => {
    const nodeVersionRestriction = ((osfVersions[version] || {}).engines || {}).node || '>=10';
    if (semver.satisfies(LOCAL_NODE_VERSION, nodeVersionRestriction)) {
      return true;
    }
    logger.debug(
      ___`Ruling out upgrade to OSF v${version} because it requires Node version matching ${nodeVersionRestriction}, incompatible with local Node.js version: ${LOCAL_NODE_VERSION}`
    );

    return false;
  });
  versionRestrictions.push(___`supports your version of Node.js (${LOCAL_NODE_VERSION})`);

  // Determine the version limiter based on options
  // Default is greater than/equal to current version but within major version ('^')
  // But we'll check for that later, so just look for within current version for now ('~')
  const versionLimiter = latest ? '*' : `~${currentOSFVersion.split('.')[0]}`;
  if (!latest) versionRestrictions.push(___`is within your current major version (${currentOSFVersion})`);

  const versionToReturn = semver.maxSatisfying(supportedOSFVersions, versionLimiter, {includePrerelease: true});

  if (!versionToReturn) {
    const errorMsg = ___`Could not find OSF version that ${versionRestrictions.join(___` and `)}.`;
    throw new Error(errorMsg);
  }
  logger.verbose(___`Latest OSF version that ${versionRestrictions.join(___` and `)}: ${versionToReturn}`);

  // Let the user know if their new version of OSF allows them to upgrade Node.JS
  const currentNodeRestriction = ((osfVersions[currentOSFVersion] || {}).engines || {}).node;
  const newNodeRestriction = ((osfVersions[versionToReturn] || {}).engines || {}).node;
  if (currentNodeRestriction && newNodeRestriction && currentNodeRestriction !== newNodeRestriction) {
    logger.info(
      ___`The version of OSF you're updating to, v${versionToReturn}, supports different versions of Node.js than your current OSF version does.`
    );
    logger.info(
      ___`You are currently running version ${LOCAL_NODE_VERSION} of Node.js, while the new OSF version allows: ${newNodeRestriction}.`
    );
    // Q: TODO: Should we be more forceful about encouraging users to upgrade? Maybe some check on every CLI command?
  }

  // Return the latest OSF version which is supported by OCC and within the major version
  return versionToReturn;
};

/**
 * Throws an error if the currentOSFVersion is less than the version to upgrade to,
 * unless the acceptDowngrade option was set
 * @param {string} currentOSFVersion the current version of OSF in use
 * @param {string} upgradeOSFVersion the version of OSF which is being considered as an upgrade target
 * @param {string} occVersion the version of OCC to which the OSF version is being compared, if any (used for logging)
 * @param {object} options an object of boolean options, notably acceptDowngrade (which in this case turns a fatal error into an info message)
 * @returns {boolean} true if a downgrade was detected (but acceptDowngrade or force means it shouldn't throw an error), false if no downgrade
 * @throws if the currentOSFVersion is less than the version to upgrade to and options.acceptDowngrade and options.force are false
 */
const checkForDowngrade = (currentOSFVersion, upgradeOSFVersion, occVersion, options = {}) => {
  const {verifyOcc, acceptDowngrade, force} = options;
  // If we would downgrade the OSF version, look for the 'acceptDowngrade' flag or throw an error
  if (semver.lt(upgradeOSFVersion, currentOSFVersion)) {
    if (acceptDowngrade || force) {
      logger.info(
        ___`This will *DOWNGRADE* your current OSF version from ${currentOSFVersion} to ${upgradeOSFVersion}${
          occVersion ? ___` (in order to match your OCC server version ${occVersion})` : ''
        }`
      );
    } else {
      const allowed = verifyOcc && occVersion ? ___`allowed by your OCC server version (${occVersion}) ` : '';
      logger.error(
        ___`Latest matching OSF version on the registry ${allowed}is *OLDER* than your current OSF version (${upgradeOSFVersion} < ${currentOSFVersion})`
      );
      logger.info(___`To accept this downgrade, add the ${"'--acceptDowngrade'"} flag to 'occ upgrade'`);
      if (verifyOcc && occVersion) {
        logger.info(
          ___`Alternatively, try using a different OCC server (${"'--serverEnv'"} or ${"'--appServerAdmin'"}) or ignore the OCC server version check (${"'--no-verifyOcc'"})`
        );
      }
      throw new Error(
        ___`OSF would be downgraded to ${upgradeOSFVersion} from ${currentOSFVersion} due to OCC server version v${occVersion}`
      );
    }

    return true;
  }

  return false;
};

/**
 * Given a path to a package.json, upgrades the @oracle-commerce dependencies
 * listed in that package.json. Returns the number of changes made to the given file.
 * @param {string} packageJsonLocation path to a package.json whose @oracle-commerce dependencies should be upgraded.
 * @param {string} targetVersion The version or version string to upgrade @occ packages to
 * @param {Object} options the options passed from the command line, primarily dry-run and verbose
 * @param {Function} log the log function to use for verbose, per-change output
 * @returns {Number} the number of dependency entries that were changed (or would be changed, if this is a dry run) in the given package.json file
 */
const upgradeOracleCommerceDeps = async (packageJsonLocation, targetVersion, options, log) => {
  const packageJson = JSON.parse(await fs.readFile(packageJsonLocation, {encoding: 'utf-8'}));
  let changedDependencies = 0;
  if (!packageJson.dependencies && !packageJson.devDependencies && !packageJson.peerDependencies) {
    return 0;
  }
  const logMessage = [`${packageJson.name}:`];

  // Given a map (obj) of dependencies, return a new map with all OSF dependencies updated to targetVersion
  const updateDependencyMap = dependencyMap =>
    Object.keys(dependencyMap)
      .filter(dependency => isOracleCommerce(dependency))
      .reduce((newMap, dependency) => {
        // Change the dependency definition and add to the log message
        if (dependencyMap[dependency] !== targetVersion) {
          newMap[dependency] = targetVersion;
          logMessage.push(`${dependency} ${dependencyMap[dependency]} => ${targetVersion}`);
          changedDependencies += 1;
        }

        return newMap;
      }, {});

  // Update the dependencies, devDependencies, and peerDependencies
  if (packageJson.dependencies) {
    Object.assign(packageJson.dependencies, updateDependencyMap(packageJson.dependencies));
  }
  if (packageJson.devDependencies) {
    Object.assign(packageJson.devDependencies, updateDependencyMap(packageJson.devDependencies));
  }
  if (packageJson.peerDependencies) {
    // updateDependencyMap will set them all to the strict version, when it's common for peer dependencies to be ranges
    Object.assign(packageJson.peerDependencies, updateDependencyMap(packageJson.peerDependencies));
  }
  if (changedDependencies) {
    // Log the message (will be verbose level if !dryRun, else info)
    log(logMessage.join('\n\t'));
    if (!options.dryRun) {
      // Modify the package.json file. This is not a drill, repeat: this is not a drill.
      await fs.writeFile(packageJsonLocation, `${JSON.stringify(packageJson, null, 2)}\n`);
      logger.verbose(___`Updated ${changedDependencies} dependencies of ${packageJson.name}`);
    }
  }

  return changedDependencies;
};

const upgrade = async (givenVersion, options) => {
  const {dryRun, verifyOcc} = options;
  // Options Validation
  if (!givenVersion && options.force) {
    options.force = false;
    logger.info(___`${"'--force'"} option used but no version given. Ignoring ${"'--force'"} option`);
  }
  if (options.latest && givenVersion) {
    // This scenario is contradictory - the user is telling us to use both the latest and a specific version
    logger.info(
      ___`${"'--latest'"} option and given version '${givenVersion}' were supplied. Using '${givenVersion}', ignoring ${"'--latest'"}.`
    );
  }
  if (givenVersion && !semver.clean(givenVersion)) {
    // If we can't interpret what the version should be from what the user provided, throw an error
    throw new Error(
      ___`Could not interpret string '${givenVersion}' to a semver-compliant version. Semver ranges are not allowed, the given version must be exact.`
    );
  }
  // Clean up the givenVersion (or set it to null if one wasn't provided)
  givenVersion = semver.clean(givenVersion || '');

  // Currently this needs to be run from the root of the workspace, but it should be addressed in the main CLI (and a different story)

  // Determine current OSF version
  const currentOSFVersion = require('@oracle-cx-commerce/occ-metadata/package.json').version;
  logger.verbose(___`Your current OSF version, based on the version of the CLI/metadata, is: ${currentOSFVersion}`);

  // Fetch OCC version unless told to skip it
  const occVersion = verifyOcc ? await getOCCServerVersions(options) : null;

  // Commented out check on current OSF-OCC mismatch, since the user is addressing it by running this tool
  // const currentMinOcc = getMinimumRequiredOCCVersion();
  // if (!occServerSatisfiesMinVersion(occVersion, currentMinOcc)) {
  //   logger.warn(
  //     ___`Your current OSF version, ${currentOSFVersion}, requires a higher version of OCC (${currentMinOcc}) than what's on ${options.appServerURL}: ${occVersion}.`
  //   );
  // }

  const osfVersions = await getAvailableOSFVersions(options);
  const version = determineUpgradeVersion(givenVersion, currentOSFVersion, occVersion, osfVersions, options);
  const isDowngrade = checkForDowngrade(currentOSFVersion, version, occVersion, options);

  // Redirect some verbose output to info if running with dry run (since the whole point of that option is to log)
  const log = dryRun ? logger.info : logger.verbose;

  // Get all the packages in the workspace then update them to the version determined above
  const allPackages = await promisify(glob)('**/package.json', {
    ignore: ['**/node_modules/**', ...(options.ignore || [])]
  });
  log(___`Looking at the dependencies of ${allPackages.length} package.json files`);
  const upgradeResults = await Promise.all(
    allPackages.map(jsonPath => upgradeOracleCommerceDeps(jsonPath, version, options, log))
  );
  // upgradeResults is an array of integers, where each entry represents a package json
  // and the value is the # of dependencies changed in that package.json

  const updatedFiles = upgradeResults.filter(val => val !== 0); // filter upgradeResults to just changed packages
  const updatedDependencies = updatedFiles.reduce((sum, curr) => sum + curr, 0); // reduce across the array to get the total # of changes
  if (updatedFiles.length === 0) {
    logger.info(___`All packages already up to date (v${version}), no changes to make`);
  } else {
    // Print a message listing how many dependencies/package.json files were updated
    logger.info(
      ___`${dryRun ? ___`Would modify` : ___`Modified`} ${updatedDependencies} dependencies across ${
        updatedFiles.length
      } package.json files to be v${version}`
    );
  }

  // Alert that we're done making modifications, and will run `yarn`
  if (!dryRun) {
    logger.info(___`Done. Running \'yarn\' to download updated packages.`);
    await new Promise((resolve, reject) => {
      exec('yarn', (err, stdout, stderr) => {
        if (err) {
          logger.error(err);
          logger.error(`stderr: ${stderr}`);
          logger.error(`stdout: ${stdout}`);
          reject(err);

          return;
        }
        logger.info(___`Successfully installed updated packages.`);
        resolve();
      });
    });
    logger.info(___`Updating workspace files.`);
    try {
      // Require and run `upgrade-files` here, so that it's after the CLI has been upgraded by yarn
      // Clear out the require cache, so that upgrade-files and its dependencies are loaded with the new (updated) versions.
      Object.keys(require.cache).forEach(key => delete require.cache[key]);
      // Clear out the cache of package/file paths
      Object.keys(module.constructor._pathCache).forEach(key => delete module.constructor._pathCache[key]);
      // Create a new shell for running upgrade files so there aren't issues with having cached (now outdated) paths/files
      await new Promise((resolve, reject) => {
        exec(`node -e "require('@oracle-cx-commerce/cli/actions/upgrade-files')()"`, (err, stdout, stderr) => {
          if (err) {
            logger.error('Could not update workspace files');
            logger.error(err);
            logger.error(`stderr: ${stderr}`);
            logger.error(`stdout: ${stdout}`);
            reject(err);

            return;
          }
          logger.info(stdout);
          logger.info(___`Successfully updated workspace files.`);
          resolve();
        });
      });
    } catch (error) {
      logger.warn(error.message);
      logger.warn(
        ___`Unable to ${isDowngrade ? 'downgrade' : 'upgrade'} workspace files to those in version '${version}' of OSF`
      );
      if (error.message.match('upgrade-files') && isDowngrade)
        logger.warn(___`You may have downgraded to a version without the capability to modify workspace files.`);
      logger.warn(___`Some scripts in package.json may not work as expected.`);
      logger.verbose(error.stack);
    }
  } else {
    logger.info(___`${'occ upgrade --dryRun'} complete`);
  }
};

module.exports = {upgrade, determineUpgradeVersion, checkForDowngrade, upgradeOracleCommerceDeps};
