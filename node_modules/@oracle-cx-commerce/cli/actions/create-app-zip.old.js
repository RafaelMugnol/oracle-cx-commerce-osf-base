/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const fs = require('fs-extra');
const path = require('path');
const archiver = require('archiver');
const glob = require('glob');
const logger = require('@oracle-cx-commerce/logger/cli');
const lockfile = require('@yarnpkg/lockfile');
const {execSync} = require('child_process');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});
const {assertFolderExistSync} = require('@oracle-cx-commerce/tools-util');
const {getRollupConfigurationLocation} = require('@oracle-cx-commerce/cli-shared').cliHelperMethods;
const {isOracleCommerce} = require('../utils');

/** The file system root, used to determine when we've recurred all the way up the tree */
const FS_ROOT = path.parse(process.cwd()).root;

/**
 * Given a file in a package, recurs up the file system and returns the package's
 * root (the folder where its package.json is)
 * @param {string} filePath the path to any file within the package
 * @returns {string} the absolute path of the encapsulating package
 * @throws if the given file path was not inside a package
 */
function getPackageRoot(filePath) {
  // If we're already at the root, return
  if (filePath.endsWith('package.json')) return path.dirname(filePath);
  // Otherwise recur up the file system until we reach the root of the file system or find the package json
  let recurFilePath = path.dirname(filePath);
  while (!fs.readdirSync(recurFilePath).find(fPath => fPath.endsWith('package.json'))) {
    if (recurFilePath === FS_ROOT || recurFilePath.endsWith('node_modules')) {
      // Reached the root of the file system without finding a package.json
      throw new Error(
        ___`Attempted to find root of package containing "${filePath}", could not locate package.json. "${filePath}" may not be located in a Node.JS package`
      );
    }
    recurFilePath = path.dirname(recurFilePath);
  }

  // Return the folder where package.json was located, the package's root
  return recurFilePath;
}

/**
 * Turns an array of dependency names into an array of paths to dependencies,
 * resolved from the given packagePath. Note that a dependency can have two paths,
 * one resolved from the workspace level and one from the given package path.
 * @param {Array<string>} dependencies the Array of dependency names which should have their paths gotten.
 * @param {string} packagePath the path of the package from which dependencies should be resolved
 * @returns {Object} an Object with two values:
 *   - dependencyPaths, an Array of string paths to the package resolved from the given package path.
 *   - unresolvedNames, an Array of strings, names of dependencies which could not be resolved.
 */
function getDependencyPaths(dependencies, packagePath) {
  const dependencyPaths = [],
    unresolvedNames = [];

  dependencies.forEach(dependencyName => {
    try {
      // Get the absolute path of the dependency's package.json, resolved from packagePath, then cut off '/package.json'
      const localPackagePath = require
        .resolve(`${dependencyName}${path.sep}package.json`, {paths: [packagePath]})
        .slice(0, -13);
      dependencyPaths.push(localPackagePath);
      try {
        // Also try to get the dependency resolved from the workspace, in case Yarn installed a redundant version of it.
        const workspacePackagePath = require.resolve(`${dependencyName}${path.sep}package.json`).slice(0, -13);
        if (workspacePackagePath !== localPackagePath) dependencyPaths.push(workspacePackagePath);
      } catch (error) {
        // Attempt to get the path to the package by its "main" export
        if (error.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {
          logger.debug(
            ___`Could not find "package.json" for "${dependencyName}" - it may not be exported. Attempting to resolve the package's root folder through its "main" export.`
          );
          try {
            // We found the package, but the package.json of the package isn't exported - get its package root the hard way
            const workspacePackagePath = getPackageRoot(require.resolve(dependencyName));
            if (workspacePackagePath && workspacePackagePath !== localPackagePath) {
              logger.debug(___`Found package.json for ${dependencyName}`);
              dependencyPaths.push(workspacePackagePath);

              return;
            }
          } catch {
            // _really_ couldn't find it. Probably not an issue, unless the package has exports defined but no main export.
            logger.verbose(___`Could not find the "package.json" or "main" export of "${dependencyName}"`);
          }
        }
        // logger.debug(___`Package ${dependencyName} unresolvable from workspace node_modules level. This isn't necessarily an issue.`)
      }
    } catch (error) {
      // If we couldn't resolve it from the package that required it, we won't be able to resolve it from the workspace
      // TODO revisit the above assumption when implementing features CCSF-16515/CCSF-17979, it may not hold after those go in
      if (error.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {
        logger.debug(___`Could not find "package.json" of package "${dependencyName}" - it may not be exported.`);
        // We found the package, but the package.json of the package isn't exported - get its package root the hard way
        try {
          const packageRoot = getPackageRoot(require.resolve(dependencyName, {paths: [packagePath]}));
          // If we found the root and it's not the root of the workspace or the root of the original package, add it to the dependency paths list
          if (
            packageRoot &&
            path.resolve(packageRoot) !== path.resolve(process.cwd()) &&
            path.resolve(packageRoot) !== path.resolve(packagePath)
          ) {
            logger.debug(___`Found "package.json" for "${dependencyName}"`);
            dependencyPaths.push(packageRoot);

            return;
          }
        } catch (error) {
          logger.verbose(___`Could not find the "package.json" or "main" export of "${dependencyName}"`);
          const resolvedFromDependent = path.resolve(packagePath, 'node_modules', dependencyName);
          if (fs.existsSync(path.join(resolvedFromDependent, 'package.json'))) {
            logger.verbose(___`Found "${resolvedFromDependent}", guessing that is the package for ${dependencyName}.`);
            dependencyPaths.push(resolvedFromDependent);
          }
          const resolvedFromWorkspace = path.resolve(process.cwd(), 'node_modules', dependencyName);
          if (
            resolvedFromDependent !== resolvedFromWorkspace &&
            fs.existsSync(path.join(resolvedFromWorkspace, 'package.json'))
          ) {
            logger.verbose(___`Found "${resolvedFromWorkspace}", guessing that is a package for "${dependencyName}".`);
            dependencyPaths.push(resolvedFromWorkspace);
          }
          if (dependencyPaths.length) return;
          // We seriously couldn't find it.
        }
      }
      logger.debug(error);
      logger.verbose(
        ___`Unable to get the path to the "package.json" of "${dependencyName}" from its dependent "${packagePath}", it may not be in the workspace. Will not be able to get its dependencies.`
      );
      unresolvedNames.push(dependencyName);
    }
  });

  return {dependencyPaths, unresolvedNames};
}

/**
 * Returns whether the given package is local (symlinked from node_modules using
 * npm link or yarn workspaces) or not.
 *
 * @param {String} pkgPath The name of or absolute path to the package to check
 * @returns {boolean} a boolean indicating whether the package is local or was installed from somewhere
 */
function isLocal(pkgPath) {
  // If we were passed a path, return if it has node_modules in it after
  // resolving symlinks (whether it's locally developed)
  if (pkgPath.startsWith(path.sep) || fs.existsSync(pkgPath)) {
    return !fs.realpathSync(pkgPath).match('node_modules');
  }
  logger.verbose(___`Could not find "${pkgPath}" to determine if it was local or not.`);
  logger.debug(___`Marking it as local, so it will be included in the zip by default.`);

  return true;
}

/**
 * Returns whether the given package.json is a yarn workspace.
 * @param {Object} pkgJson The package.json (in-memory file) to check if it's a workspace
 * @returns a boolean, whether the given pkgJson represents a yarn workspace
 */
function isWorkspace(pkgJson) {
  return pkgJson.workspaces ? true : false;
}

const uninstalledOptionals = [];
/**
 * Given a package's optional dependencies, returns an array of the names of
 * optional dependencies which were actually installed.
 * @param {Object} optionalDependenciesMap the map/object of optional dependencies to check
 * @param {string} packagePath the path to the package requiring those optional dependencies
 * @returns {Object<Array<string>>} two Arrays of the optional dependencies, one of "installed" dependencies, and the other of "notInstalled" ones
 */
function filterOptionalDependencies(optionalDependenciesMap, packagePath) {
  const installed = [],
    notInstalled = [];
  Object.keys(optionalDependenciesMap).forEach(optionalDep => {
    try {
      require.resolve(`${optionalDep}${path.sep}package.json`, {paths: [packagePath]});

      installed.push(optionalDep);
    } catch {
      // TODO really, should back up with "getPackageRoot" here, in case the optional doesn't export its package.json
      logger.verbose(___`Could not find optional dependency installed in workspace: ${optionalDep}.`);

      notInstalled.push(optionalDep);
    }
  });

  return {installed, notInstalled};
}

/**
 * Adds a package's dependencies (and all of their dependencies, etc.) to the
 * given "existing" Set.
 * @param {Set} existing a Set, to which the given package's dependencies should be added.
 * @param {String} packagePath the path to the package whose dependencies should be added to the Set.
 * @returns {Set} the Set with added dependencies
 * @throws an error if we're
 *  - unable to load package.json for a given package - such packages should be filtered out and not recurred on
 *  - unable to resolve a package that is a dependency (not dev/optional) of the given package
 */
function getAllDependencies(existing, packagePath) {
  // If we've already seen the package path in the Set, skip recursion on it.
  if (existing.has(packagePath)) return existing;
  let pkgJson = {};
  try {
    pkgJson = require(path.resolve(packagePath, 'package.json'));
  } catch (error) {
    logger.debug(error);
    // This shouldn't really happen, unless the package is present (resolvable) but not a valid package (no package.json)
    throw new Error(
      ___`Unable to load 'package.json' in '${packagePath}'. Check if it's a valid NPM package, with a 'package.json', and re-run with '--verbose' for more info`
    );
  }
  existing.add(packagePath);
  const pkgName = pkgJson.name || '';

  // If it has dependencies collect all of those into the existing Set.
  // Note: we don't include peer dependencies because we assume peer
  // dependencies will be 'normal' dependencies of some package being
  // deployed/templatized.
  let dependencies = pkgJson.dependencies ? Object.keys(pkgJson.dependencies) : [];

  // If it's a local package (or an @oracle-cx-commerce package, since we're
  // tracking those separately and won't upload them) add devDependencies if they exist
  // if (pkgJson.devDependencies && (isLocal(packagePath) || isOracleCommerce(pkgName))) {
  //   dependencies = dependencies.concat(Object.keys(pkgJson.devDependencies));
  // }

  if (pkgJson.optionalDependencies) {
    // Ignore trying to get optional dependencies we can't find (they may be OS-Specific).
    const {installed, notInstalled} = filterOptionalDependencies(pkgJson.optionalDependencies, packagePath);
    dependencies = dependencies.concat(...installed);
    // Add the notInstalled dependencies to existing... Technically, if being thorough here, would need
    // to add their (uninstalled) dependencies as well. See https://jira-oracom.oci.oraclecorp.com/jira/browse/CCSF-21915
    uninstalledOptionals.push(...notInstalled.map(optional => `${optional}@${pkgJson.optionalDependencies[optional]}`));
  }

  // Once we have the dependency names, get their paths and recursively add them to existing.
  const result = getDependencyPaths(dependencies, packagePath);
  let {dependencyPaths} = result;
  const {unresolvedNames} = result;
  // If the package has bundled dependencies, remove those dependency paths
  // internal to the current package from the list of dependency paths to
  // recur on (since they're included in the package that's bundling them).
  if (pkgJson.bundledDependencies) {
    logger.debug(___`${pkgName} has bundled dependencies ${pkgJson.bundledDependencies}`);
    dependencyPaths = dependencyPaths.filter(depPath => {
      if (depPath.match(packagePath)) {
        logger.verbose(___`Not recurring on "${depPath}" as it's bundled (and probably duplicated in node_modules)`);

        return false;
      }

      return true;
    });
  }

  unresolvedNames.forEach(dependencyName => {
    // We couldn't resolve the package - inform the user if it's not an Oracle
    // Commerce devDependency (which needn't have been installed for a valid installation)
    if (!(isOracleCommerce(pkgName) && pkgJson.devDependencies && pkgJson.devDependencies[dependencyName])) {
      throw new Error(
        ___`Could not resolve location for "${dependencyName}", required by "${pkgName}". Please check if "${dependencyName}" is installed, and re-install it with 'yarn --force' if necessary.`
      );
    }
  });

  dependencyPaths.reduce(getAllDependencies, existing);

  return existing;
}

/**
 * Given an application's directory, returns an Object with information about the
 * app's external, not rolled-up dependencies.
 * @param {String} appDir The path to the application directory. e.g. /.../packages/apps/blank-store
 * @returns {Object} an Object with two entries
 *  - externalDependencies, a Set of all external (not rolled-up) dependencies
 *    that should be sent up in a lite deployment.
 *  - externalPkgs, a Map from external package name -> version. This will be
 *    used to determine what packages/versions to install server side in a lite deployment.
 * @throws if it's unable to determine the list of packages that will be required by server.js (can't resolve rollup config)
 */
function getExternalDependencies(appDir) {
  // A set of all external (not rolled-up) dependencies that should be sent up.
  const externalPaths = new Set(),
    // A map from external (not bundled) package name -> version. This will be
    // used to determine what packages (and which versions) to install server
    // side for a "lite" deployment.
    externalPkgs = new Map();

  try {
    // Attempt to find and load rollup config to get the external package names.
    const appPackageJsonPath = path.resolve(appDir, 'package.json');
    const rollupConfigLocation = getRollupConfigurationLocation(appDir);
    const rollupConfigs = require(rollupConfigLocation);
    const externalNames = new Set();
    // Try to get the built-ins and remove them from the external list, since we
    // know they'll be present on the server
    let builtIns = new Set();
    try {
      builtIns = new Set(require('builtin-modules'));
    } catch (error) {
      logger.info(
        ___`Unable to load "builtin-modules" package. You may see extra log messages warning of not finding them, but those can be safely ignored.`
      );
    }
    // Collect the external packages (but not built-ins) from each config in externalNames
    rollupConfigs.forEach(config => {
      (config.external || []).forEach(externalPackage => {
        if (!builtIns.has(externalPackage)) {
          externalNames.add(externalPackage);
        }
      });
    });
    // Also add @oracle-cx-commerce/cli and react-app here since they're required
    // to run most @oracle-cx-commerce apps.
    externalNames.add('@oracle-cx-commerce/cli');
    externalNames.add('@oracle-cx-commerce/react-app');
    externalNames.add('@oracle-cx-commerce/occ-metadata');
    const packageNameRegex = /(?<packageName>(?<scope>@[^/]+\/)?[^/]+)(?<childFile>\/?.*)/;
    externalNames.forEach(externalName => {
      try {
        // Find the versions of each external package that'd be called from
        // the app directory and add those versions to the externalPkgs map
        // (to be installed during a lite deployment)
        let externalPackagePath = getDependencyPaths([externalName], appPackageJsonPath).dependencyPaths.pop();
        if (!fs.existsSync(externalPackagePath)) {
          // Since we couldn't find the desired package.json, see if this is a
          // child file of some package
          const {packageName, childFile} = externalName.match(packageNameRegex).groups;
          if (childFile && !externalNames.has(packageName)) {
            logger.verbose(___`Adding root package "${packageName}" instead of its child file "${externalName}"`);
            externalPackagePath = getDependencyPaths([packageName], appPackageJsonPath).dependencyPaths.pop();
            externalName = packageName;
          } else if (childFile && externalNames.has(packageName)) {
            logger.verbose(
              ___`Skipping child file "${externalName}" as its root package "${packageName}" is already an external file`
            );

            return;
          }
        }
        const {version} = require(path.join(externalPackagePath, 'package.json'));
        externalPkgs.set(externalName, version);
        externalPaths.add(externalPackagePath);
      } catch (error) {
        logger.verbose(
          ___`Could not locate metadata for external package "${externalName}". It may be inside another package (which should also be external).`
        );
        externalPkgs.set(externalName);
        logger.debug(error);
      }
    });
    // TODO also need to ensure we get all things the app might `require` in
    // its index.js. What if they replace @oracle-cx-commerce/react-app and overwrite
    // createApp?
  } catch (error) {
    logger.error(
      ___`Could not find rollup-config depended on by "${appDir}". Will be unable to ascertain external packages. Lite deployment will probably fail.`
    );
    throw error;
  }

  return {
    externalPkgs,
    externalDependencies: [...externalPaths].reduce(getAllDependencies, new Set())
  };
}

/**
 * Given a Set of dependencies (or a string pointing to a folder whose
 * dependencies should be fetched), determines which of those dependencies
 * @oracle-cx-commerce packages also depend on, and from that whether those dependencies
 * can be fetched from the oracle-commerce registry instead of being deployed or
 * if @oracle-cx-commerce packages will be using updated dependencies.
 *
 * Does not throw errors, since if this function fails the worst case is simply including
 * in the deployment packages that could be fetched from the registry.
 * @param {Set} dependencies the Set of dependencies to evaluate, or a (string)
 *    path to a package whose dependencies should be evaluated
 * @returns {Object} an Object with two Sets:
 *   - oracleCommerceDependencies, a Set of dependency paths whose exact
 *    versions are present in the oracle-cx-commerce registry
 *   - updatedOracleCommerceDependencies, a Set of dependency paths for packages
 *    used by @oracle-cx-commerce but whose versions are not in the registry
 */
function getOracleCommerceDeps(dependencies, appDir) {
  if (typeof dependencies === 'string') {
    dependencies = getAllDependencies(new Set(), dependencies);
  } else if (!(dependencies instanceof Set)) {
    throw new Error(`getOracleCommerceDependencies expects a string or a set, not a ${typeof dependencies}`);
  }
  // Two sets for tracking which dependencies are downstream of Oracle Commerce packages
  // One of original, un-upgraded @oracle-cx-commerce dependencies (which are in the registry)
  const oracleCommerceDependencies = new Set(),
    // And one of packages @oracle-cx-commerce depends on but which were upgraded locally.
    updatedOracleCommerceDependencies = new Set();

  // Try to get the manifest of exact dependency names & versions used by @oracle-cx-commerce
  let oracleCommerceManifest, occVersion;
  try {
    // Resolve the occ metadata package used by this app and check that it's in the app's or the workspace's dependency graph
    const occMetadataLocation = getDependencyPaths(['@oracle-cx-commerce/occ-metadata'], appDir).dependencyPaths.pop();
    if (!occMetadataLocation || !dependencies.has(occMetadataLocation)) {
      throw new Error(
        ___`App does not depend on a version of the '@oracle-cx-commerce/occ-metadata' package - will not be able to validate if it's on a given release of the OCC Framework.`
      );
    }
    occVersion = require(`${occMetadataLocation}/package.json`).version;

    oracleCommerceManifest = require(`${occMetadataLocation}/occ.manifest.json`);
  } catch (error) {
    // Having this function fail isn't really a fatal error - it just means we won't be able to exclude OCC dependencies (so the app zip will be larger)
    if (!occVersion) {
      logger.warn(error.message);
    } else if (!oracleCommerceManifest) {
      logger.verbose(
        ___`Unable to load manifest of packages ("@oracle-cx-commerce/occ-metadata/occ.manifest.json"). Will not be able to accurately exclude oracleCommerceDependencies from app zip.`
      );
    }
    // logger.debug(error);

    return {oracleCommerceDependencies, updatedOracleCommerceDependencies};
  }

  dependencies.forEach(packagePath => {
    try {
      const {name, version} = require(path.join(packagePath, 'package.json'));
      const privatePkg = require(path.join(packagePath, 'package.json')).private;
      // Get the manifest entry, e.g. @babel/cli -> [ "7.4.4", "7.4.5" ]
      const manifestEntry = oracleCommerceManifest.dependencies[name];
      // Skip adding private packages to this list, even if they start with @oracle-cx-commerce, so they'll always get deployed
      if (isOracleCommerce(name) && !privatePkg) {
        oracleCommerceDependencies.add(packagePath);
        // If the package starts with @oracle-cx-commerce, note if it's not part of the recognized OCC version
        const manifestVersion = oracleCommerceManifest.oracleCommerce[name];
        if (manifestVersion !== version) {
          logger.warn(
            ___`App may be depending on a partially-upgraded version of the framework. Locally-used version of package "${name}" is at version ${version}, while the version of that package used in version ${occVersion} of the OCC Framework, per the metadata package, is ${manifestVersion}.`
          );
          // Instruct user to run some sort of command that lists the versions of @oracle-cx-commerce packages that
          // should be used in apps in this workspace (by reading the manifest)
          logger.info(
            ___`Recommended action: run 'occ upgrade ${occVersion}' to sync your OSF packages to the same release. Add the '--dryRun' flag to that command to preview changes.`
          );
        }
      } else if (manifestEntry) {
        // If the local name is in the manifest then it's an oracle commerce dependency, and if the local version of
        // that package is in the manifest, it will be the same version OSF was tested with and will be in the registry.
        if (manifestEntry.includes(version)) {
          oracleCommerceDependencies.add(packagePath);
        } else {
          updatedOracleCommerceDependencies.add(`${name}@${version}`);
        }
      }
      // Else skip this dependency as no version of it is verified to be in the registry.
    } catch (error) {
      // Again, not a fatal error, just means we'll upload some packages unnecessarily (they could be fetched from the registry)
      logger.error(
        ___`Unable to load package.json at ${path.join(packagePath, 'package.json')}. Will not find its dependencies.`
      );
      logger.debug(error);
    }
  });

  return {oracleCommerceDependencies, updatedOracleCommerceDependencies};
}

let cachePath;

// eslint-disable-next-line spellcheck/spell-checker
/**
 * Attempts to divine the location of the yarn cache (likely, by default, "./.yarncache")
 * and return it to the caller. Returns undefined if it could not find .yarnrc.
 * * Note the double quotes around a relative path. .yarncache, ./.yarncache, or './.yarncache' won't work (yarn throws an error).
 * However, node trips over double quotes, so we should remove them before trying to use them in a path (before returning the string).
 * @returns {string} the string to the location of the yarn cache folder
 * @throws if a yarn cache could not be found
 */
const getCachePath = () => {
  if (cachePath) return cachePath;

  // If there's a .yarnrc, where an offline cache location is defined, read and return the cache location.
  if (fs.existsSync('.yarnrc')) {
    const yarnrc = fs.readFileSync('.yarnrc', 'utf8');
    // Remove double quotes from the return value because (while required by yarn)
    // they aren't interpreted correctly by Node.
    const cacheLocation = yarnrc
      .match(/yarn-offline-mirror (?<cacheLocation>.+)/)
      .groups.cacheLocation.replace(/"/g, '');
    if (!fs.existsSync(cacheLocation)) {
      // This should never happen, so long as the user is using yarn - yarn creates the yarn cache before passing on
      // control to the `occ` process. If they delete the .yarncache and then run `occ deploy` directly, though, we could end up here
      throw new Error(
        ___`Local yarn cache location defined as '${cacheLocation}', but could not find that folder. Try running '${'yarn install --force'}'`
      );
    }

    cachePath = cacheLocation;

    return cachePath;
  }
  // Will likely encounter error for not finding .yarnrc to be included in the zip before reaching here...
  throw new Error(
    ___`Could not find '.yarnrc' - will not be able to determine cache location, or load cached packages for deployment.`
  );
};

const UPDATE_CACHE_MESSAGE = ___`Try running "${'yarn cache clean && yarn --force'}" to force yarn to reinstall all dependencies. You may also need to add the "${'--update-checksums'}" flag.`;

/**
 * Using a package's name and (specific) version, returns the file path for the
 * cached version of that package (if it is indeed cached).
 * @param {string} name the name of the package
 * @param {string} version the version of the package
 * @returns {string} the path to the cached package
 * @throws if the cached package could not be found.
 */
const getCachedFilePath = (name, version) => {
  const cacheName = `${name.replace('/', '-')}-${version}.tgz`;
  const cachePackagePath = path.resolve(getCachePath(), cacheName);

  if (fs.existsSync(cachePackagePath)) {
    return cachePackagePath;
  }
  // Attempt to find/construct the necessary tarball from the cache...
  try {
    const yarnCacheDir = execSync('yarn cache dir').toString().trim();
    logger.verbose(___`Attempting to retrieve ${cacheName} from Yarn's global cache`);
    // If we can get the yarn cache directory from the settings, see if there's a folder for the package
    if (fs.existsSync(yarnCacheDir)) {
      // All entries in the yarn cache start with "npm", no matter where they came from, strangely.
      // eslint-disable-next-line spellcheck/spell-checker
      // From name '@babel/core_ui', version 1.2.3, create regex /^npm-@babel-core-ui-1.2.3/
      const cachedPackageFolderPattern = cacheName
        .replace(/[^@a-z0-9.]+/g, '-')
        .replace('@', '\\@')
        .slice(0, -4);
      const rgx = new RegExp(`^npm-${cachedPackageFolderPattern}`);
      const found = fs.readdirSync(yarnCacheDir).find(packageDir => rgx.test(packageDir)); // Get the global cache folder
      const foundPackageDir = found ? path.join(yarnCacheDir, found, 'node_modules', name) : ''; // Dig into the cache folder
      // If there is a folder for that package and it has a .yarn-tarball.tgz, take that and put it in .cache
      if (foundPackageDir && fs.existsSync(path.join(foundPackageDir, '.yarn-tarball.tgz'))) {
        fs.copyFileSync(path.join(foundPackageDir, '.yarn-tarball.tgz'), cachePackagePath);

        return cachePackagePath;
      }
      // Otherwise, if there's a package.json, we should be able to run "pack", create the .tgz and move it to the .yarn-cache
      if (foundPackageDir && fs.existsSync(path.join(foundPackageDir, 'package.json'))) {
        execSync(`yarn pack --ignore-scripts --filename ${cacheName}`, {cwd: foundPackageDir});
        fs.moveSync(path.join(foundPackageDir, cacheName), cachePackagePath);

        return cachePackagePath;
      }
      // Q: Should also be willing to extract from node_modules folder? Less clean even than cache
      // If neither of those worked, throw an error as usual...
      logger.debug(___`Failed to retrieve ${cachedPackageFolderPattern} from Yarn's global cache`);
    }
  } catch (e) {
    // Swallow rebuilding cache error to show the more relevant problem: needing to rebuild cache in the first place
    logger.debug(___`Rebuilding cache from global failed`);
    logger.debug(e);
  }
  throw new Error(
    ___`Caching is enabled but could not find cached file for ${name}@${version} in ${getCachePath()}. ${UPDATE_CACHE_MESSAGE}`
  );
};

/**
 * Given a dependency path resolved with getDependencies above, returns the path
 * which should be included in the zip (a .tgz file from the yarn cache).
 * @param {string} dependencyPath the path to the folder in node_modules
 *    containing a package to be included.
 * @returns {string} the path to the file to be included in the zip
 * @throws if the package is not local and its cached path could not be found
 */
const getDependencyPathToSave = dependencyPath => {
  // If the cache location is defined (caching is enabled) try to get the
  // .tgz file there.
  if (!isLocal(dependencyPath)) {
    const dependencyJson = require(path.resolve(dependencyPath, 'package.json'));

    // When yarn caches packages it replaces / in their names with a - (e.g. @oracle-cx-commerce/cli@20.1.0 -> @oracle-cx-commerce-cli-20.1.0.tgz)
    return getCachedFilePath(dependencyJson.name, dependencyJson.version);
  }

  // If some part of getting the cache failed, return the original dependency path
  // so we'll fall back to storing the node_modules folder at least.
  return dependencyPath;
};

const lockfilePath = path.resolve(process.cwd(), 'yarn.lock');
let parsedLockfile;
/**
 * Even if we're unable to resolve uninstalled optional dependencies, it's not
 * necessarily a fatal error for the deployment - yarn may not attempt to resolve
 * it server-side, in which case we can ignore the error.
 * @param {string} uninstalledOptional the name and version spec of the uninstalled optional package
 * @returns {string?} If the optional package was at least cached, returns the path to the cached package
 *    If it was unable to resolve the package for whatever reason (bad yarn.lock, not downloaded, etc.) logs an error
 * @throws if it couldn't parse the yarn lockfile or the optional dependency couldn't be found from its cache location
 */
function resolveUninstalledOptional(uninstalledOptional) {
  try {
    // Fill in the lockfile
    if (!parsedLockfile) {
      if (fs.existsSync(lockfilePath)) {
        parsedLockfile = lockfile.parse(fs.readFileSync(lockfilePath, {encoding: 'utf8'}));
        if (parsedLockfile.type !== 'success') {
          // Have not yet found scenario in which parse returns fail rather than throwing syntax error, but I suppose it's possible
          throw new Error(___`Could not parse yarn lockfile at "${lockfilePath}".`);
        }
      } else {
        // This shouldn't happen so long as we're planning on including the lockfile in the zip and it hasn't somehow been moved (nested workspaces?)
        parsedLockfile = {type: 'fail'};
        throw new Error(___`Could not locate yarn lockfile in default location '${lockfilePath}'.`);
      }
    }
    if (parsedLockfile.type !== 'success') {
      // Already failed to parse on a previous run, already warned about it, just note in debug
      logger.debug(___`Could not parse lockfile "${lockfilePath}"`);

      return;
    }

    // Get the version of the optional file from the lockfile
    const {packageName} = uninstalledOptional.match(/@?(?<packageName>[^@]+)@/).groups;
    const resolvedVersion = (parsedLockfile.object[uninstalledOptional] || {}).version;
    // Resolve the cache location, return it if found or throw error if not.
    const cachedPackagePath = getCachedFilePath(packageName, resolvedVersion);

    return cachedPackagePath;
  } catch (error) {
    logger.error(
      ___`Could not resolve optional dependency "${uninstalledOptional}". This may cause an error when installing the deployment.`
    );
    logger.error(UPDATE_CACHE_MESSAGE);
    // It's probably a bad error if we need the optional dependency and can't find it. See CCSF-21898.
    // HOWEVER, since the controller will attempt to install the app with `--ignore-optional` if it fails initially, maybe not an issue?
    // Still, best to make it very visible to the user.
    logger.error(error.message);
    // TODO this method could be split into two: resolve the version of the optional from yarn.lock, then resolve from the cache if and only if it won't be in the registry (it's not an Oracle Commerce Dep...)
  }
}

/**
 * This function creates an archive file for the app at path specified by appDir.
 * Its file structure is specified by a config file at [options.type]-config.json.
 *
 * @param {String} appName The name of the application.
 * @param {Object} options The command line options including type, for the type of
 *      archive to generate, and dest, for the destination directory of the
 *      resulting archive file.
 * @param {Function} archiveCallBack A function that will be called with the generated archive prior to
 *      being finalized. The caller may modify the archive at this point.
 * @returns {Promise} a promise to be resolved with the path to the resulting archive file.
 */
module.exports = (appName, options, archiveCallBack) => {
  logger.warn(___`DEPRECATED: Using old deployment mechanism`);

  return new Promise((resolve, reject) => {
    const {appDir} = options;
    // Determine which zip config to use - deploy/output will have passed in deploy.json, else use template
    const zipConfigPath = options.zipConfigPath || './../config/template.json';
    // Check app directory is accessible.
    assertFolderExistSync(options.appDir, `Cannot access application folder: ${options.appDir}`);

    const config = require(zipConfigPath);
    const zipName = `${appName}`;

    // Check for custom config and combine properties
    if (fs.existsSync(`config${path.sep}template-config.json`)) {
      const customConfig = require(`${process.cwd()}${path.sep}config${path.sep}template-config.json`);

      config.includes = customConfig.includes ? config.includes.concat(customConfig.includes) : config.includes;

      config.ignore = customConfig.ignore ? config.ignore.concat(customConfig.ignore) : config.ignore;
    }

    // Add to the ignore/include lists any globs added on the CLI
    if (options.ignore) {
      config.ignore = config.ignore.concat(options.ignore);
    }

    if (options.include) {
      config.includes = config.includes.concat(options.include);
    }

    // If destination was specified at command line
    const dest = options.dest || path.resolve(appDir, '.occ', 'templates');

    // Create dest directory if it does not exist
    fs.mkdirpSync(dest);

    // Remove zip if it already exists
    if (fs.existsSync(`${dest}${path.sep}${zipName}.zip`)) {
      fs.removeSync(`${dest}${path.sep}${zipName}.zip`);
    }

    // Check if app directory exists
    if (!fs.existsSync(appDir)) {
      reject(___`Could not find app "${appDir}"`);

      return;
    }

    const output = fs.createWriteStream(`${dest}${path.sep}${zipName}.zip`);
    const archive = archiver('zip');

    // When zip generation completes, resolve promise with path to resulting zip file
    output.on('close', function () {
      logger.info(___`${zipName}.zip created - ${path.resolve(dest)}.`);

      resolve(`${dest}${path.sep}${zipName}.zip`);
    });

    archive.on('error', function (err) {
      reject(err);
    });

    archive.pipe(output);

    /**
     * Adds the file(s) specified by source to the workspace archive if they don't match a pattern
     * in the ignore list, and logs this if the verbose flag is set.
     *
     * @param {String} source the file or directory to include in the archive
     * @throws if the "source" could not be found and added to the zip.
     */
    function addToWorkspaceZip(source) {
      let filePattern = source;
      // If this isn't a pattern or specific file, and is a directory, add all its contents
      if (fs.existsSync(source) && fs.lstatSync(source).isDirectory()) {
        filePattern = source.endsWith(path.sep) ? `${source}**` : `${source}${path.sep}**`;
      }

      // Add all the items matching the glob. If there aren't any throw a warning.
      const results = glob.sync(filePattern, {ignore: config.ignore, dot: true});
      if (results.length) {
        logger.verbose(___`Including '${source}'`);
        results.forEach(item => {
          archive.file(item, {name: `workspace${path.sep}${item}`});
        });
      } else {
        throw new Error(
          ___`Could not find file, pattern, or directory matching '${source}', to be included in the zip. Please ensure a matching file or folder exists on disk.`
        );
      }
    }

    // Include the app directory
    addToWorkspaceZip(appDir);

    // Include files specified in includes list
    config.includes.forEach(item => addToWorkspaceZip(item));

    // Find *all* dependencies of the app and its workspace
    const allDependencies = getAllDependencies(new Set(), path.resolve(appDir));
    const workspaceJsonPath = path.resolve(process.cwd(), 'package.json');
    if (fs.existsSync(workspaceJsonPath) && isWorkspace(require(workspaceJsonPath))) {
      getAllDependencies(allDependencies, workspaceJsonPath.slice(0, -12));
    }

    // If we're doing a lite deployment, get those dependencies of the external packages
    // A set of all external (not rolled-up) dependencies that should be sent up.
    let externalDependencies = new Set(),
      // A map from external (not bundled) package name -> version. This will be
      // used to determine what packages (and which versions) to install server
      // side for a "lite" deployment.
      externalPkgs = new Map();
    if (options.deployType === 'lite') {
      process.env.OCC_APP_DIR = appDir;
      ({externalPkgs, externalDependencies} = getExternalDependencies(path.resolve(appDir)));
    }
    // Delete the appDir and the root of the workspace (we know they'll be included)
    allDependencies.delete(path.resolve(appDir));
    allDependencies.delete(path.resolve(process.cwd()) + path.sep);

    // Do a full deployment if requested on the command line or if we couldn't
    // ascertain external packages.
    const fullDeployment = options.deployType !== 'lite' || externalPkgs.size === 0;

    // Filter out the oracleCommerceDependencies (they'll be on the registry)
    const dependenciesToSave = fullDeployment ? allDependencies : externalDependencies;
    // If this is a lite deployment, ensure we're still sending up all local dependencies.
    if (!fullDeployment) {
      allDependencies.forEach(packagePath => {
        if (isLocal(packagePath) && !isOracleCommerce(require(path.join(packagePath, 'package.json')).name || '')) {
          dependenciesToSave.add(packagePath);
        }
      });
    }

    let oracleCommerceDependencies = new Set();
    let updatedOracleCommerceDependencies = new Set();
    if (!process.env.OCC_INCLUDE_ALL_PACKAGES) {
      // Note which dependencies of @oracle-cx-commerce packages are available on the registry/were updated
      // Two sets for tracking which dependencies are downstream of Oracle Commerce packages
      // One of original, un-upgraded @oracle-cx-commerce dependencies
      // And one of packages @oracle-cx-commerce depends on but which were upgraded locally.
      const deps = getOracleCommerceDeps(dependenciesToSave, path.resolve(appDir));
      oracleCommerceDependencies = deps.oracleCommerceDependencies;
      updatedOracleCommerceDependencies = deps.updatedOracleCommerceDependencies;
    }

    let dependenciesSkipped = 0;
    for (const dependencyPath of dependenciesToSave) {
      // Remove dependencies from the list to add to the zip if they're available from the production registry
      // (in oracleCommerceDependencies) or this is a localDevApp and the dependency is from an external source
      if (oracleCommerceDependencies.has(dependencyPath) || (options.localDevApp && !isLocal(dependencyPath))) {
        dependenciesToSave.delete(dependencyPath);
        dependenciesSkipped++;
      }
    }

    logger.info(___`Adding ${dependenciesToSave.size} dependencies to the app zip.`);
    logger.verbose(
      ___`${dependenciesSkipped} dependencies were not added due to also being dependencies of @oracle-cx-commerce (they can be fetched from the registry).`
    );
    if (updatedOracleCommerceDependencies.size) {
      // Warn that they've updated some internal @oracle-cx-commerce dependencies.
      logger.verbose(
        ___`Using updated versions of the following ${
          updatedOracleCommerceDependencies.size
        } @oracle-cx-commerce 4th party dependencies: \n\t${[...updatedOracleCommerceDependencies].sort().join('\n\t')}`
      );
    }

    dependenciesToSave.forEach(itemPath => {
      const itemName = fs.existsSync(`${itemPath}${path.sep}package.json`)
        ? require(`${itemPath}${path.sep}package.json`).name
        : '';

      // Add the dependency to the zip, ignoring occ dependencies
      // Resolve the path to the current directory instead of the absolute before adding it to the zip.
      const depPath = getDependencyPathToSave(itemPath);
      if (fs.existsSync(depPath)) {
        const depDestination = depPath.replace(`${process.cwd()}${path.sep}`, '');

        addToWorkspaceZip(depDestination);
      } else {
        throw new Error(
          ___`Could not find file or directory named '${depPath}' for dependency '${
            itemName || itemPath
          }'. A new 'yarn install' may be required`
        );
      }
    });

    // Add uninstalled optional dependencies (cached versions of them) to the zip
    // Do so only if this *isn't* a localDevApp deploy (since in that case we only care
    // about local packages, which by definition would be installed)
    if (!options.localDevApp) {
      uninstalledOptionals.forEach(item => {
        const itemPath = resolveUninstalledOptional(item);
        if (fs.existsSync(itemPath)) {
          const depDestination = itemPath.replace(`${process.cwd()}${path.sep}`, '');
          addToWorkspaceZip(depDestination);
        }
        // Else error logged in resolveUninstalledOptional
      });
    }

    // give caller a chance to modify the archive
    if (archiveCallBack) {
      if (fullDeployment) {
        // Omit the external object from the deployment json if we're doing a full deployment
        // TODO should have some other way of notifying the controller of a lite deployment, so we can always include it?
        archiveCallBack(archive);
      } else {
        // Convert the Map of external packages (to be installed server-side) to
        // a stringifiable object for inclusion in the deployment.json.
        const externalObject = {};
        for (const [name, version] of externalPkgs.entries()) {
          if (version === undefined) {
            logger.verbose(___`No version found for external package ${name}. It may be internal to another package.`);
          } else {
            externalObject[name] = version;
          }
        }
        archiveCallBack(archive, externalObject);
      }
    }
    archive.finalize();
  });
};
