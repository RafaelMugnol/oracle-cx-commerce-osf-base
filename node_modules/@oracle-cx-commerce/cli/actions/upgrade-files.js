/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */
// Clear out the cache of package/file paths
// They may have changed in the upgrade, if yarn decided to start hoisting when it didn't before or vice versa
Object.keys(module.constructor._pathCache).forEach(key => delete module.constructor._pathCache[key]);

const fse = require('fs-extra');
const path = require('path');
const logger = require('@oracle-cx-commerce/logger/cli');
const {resolveAcceleratorTemplate} = require('@oracle-cx-commerce/accelerator-templates');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});
const {getFilesFromDeployment} = require('@oracle-cx-commerce/tools-util/deployment');
/** The name of the accelerator template from which upgraded workspace files should be extracted */
const TEMPLATE = require('@oracle-cx-commerce/cli-shared').defaults.appName;

// Below could instead be written into @occ/occ-metadata/package.json.occ, or somewhere visible from the registry
/** Which files should be upgraded when someone upgrades to this release. This list is *cumulative* across releases,
 * since it needs to be upgrade someone from * to this version, without them needing to pick up all upgrades along the way. */
const FILES_TO_UPGRADE = [
  'package.json',
  'nodemon-dev.json',
  '.husky/commit-msg',
  '.husky/pre-push',
  '.husky/_/husky.sh',
  '.husky/_/.gitignore'
];

// eslint-disable-next-line spellcheck/spell-checker
/**
 * Given a file, copies that file to ${file}.bkp, or (if that backup already exists)
 * the ${file}.bkp# where # is the lowest number greater than 0 such that the filename is
 * unique.
 * i.e. if my.file exists and my.file.bkp exists, this function will copy my.file to my.file.bkp1
 * @param {string} file the name of a file which should be copied (a backup created)
 * @return {string} the name of the new file (the backup)
 */
async function createBackup(file) {
  // Suggest a new name for the file of `${file}.bkp`
  let newName = `${file}.bkp`;
  // If that file is already present, suggest adding a '1' to the end,
  // and increment that number until we find a free filename
  if (await fse.exists(newName)) {
    let inc = 1;
    while (await fse.exists(newName)) {
      newName = `${file}.bkp${inc++}`;
    }
  }
  // Copy the file and return its new name
  await fse.copyFile(file, newName);
  logger.info(___`Copied '${file}' to '${newName}'`);

  return newName;
}

/**
 * Gets files from the default accelerator template and adds/upgrades the files in the
 * current workspace with the versions from the accelerator template. Creates backups
 * of the current workspace files as needed. If the current files and template files
 * are already identical, performs no changes.
 *
 * Files to be added/upgraded are defined as a constant (@see FILES_TO_UPGRADE earlier in this file).
 */
module.exports = async () => {
  try {
    // Extract file contents from the template, ascertain they all exist
    const filesWithContents = await getFilesFromDeployment(FILES_TO_UPGRADE, resolveAcceleratorTemplate(TEMPLATE));

    // Check if there are current versions of those files in the workspace
    // Convert list of files to upgrade to a map of {toBackup: [file1, file2], new: [file3, file4]}
    const sortedFilesToUpgrade = await FILES_TO_UPGRADE.reduce(
      async (acc, file) => {
        acc = await acc;
        // Determine if the file needs to be added, updated, or is already up-to-date
        if (!(await fse.exists(file))) {
          // The file is new - it should just be added to the workspace.
          acc.new.push(file);
        } else if (filesWithContents[file] !== (await fse.readFile(file, {encoding: 'utf8'}))) {
          // The file exists AND it's different from the file in the template
          // We should back up the current version of the file
          acc.toBackup.push(file);
        }
        // else file is up-to-date already

        return acc;
      },
      {toBackup: [], new: []}
    );

    // Log the files to be updated and where old versions will be stored
    if (sortedFilesToUpgrade.toBackup.length) {
      logger.info(
        ___`Files to upgrade (existing files will be copied to '<filename>.bkp'):\n${sortedFilesToUpgrade.toBackup.join(
          '\n'
        )}`
      );
    }
    if (sortedFilesToUpgrade.new.length) logger.info(___`Files to add:\n${sortedFilesToUpgrade.new.join('\n')}`);

    // If there are some files to add/update, do so, otherwise just exit.
    if (sortedFilesToUpgrade.new.length || sortedFilesToUpgrade.toBackup.length) {
      // For each file that does exist, move it to .bkp#
      await Promise.all(sortedFilesToUpgrade.toBackup.map(file => createBackup(file)));
      // Add the new and upgraded files to the correct locations in the workspace
      await Promise.all(Object.keys(filesWithContents).map(file => fse.outputFile(file, filesWithContents[file])));
      logger.info(___`Workspace files updated after backing up existing copies.`);
    } else {
      logger.info(___`All workspace files already up-to-date, no changes made.`);
    }
  } catch (error) {
    logger.error(___`Upgrading files failed`);
    logger.error(error.message);
    logger.debug(error);
    throw error;
  }
};
