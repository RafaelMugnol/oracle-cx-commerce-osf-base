/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const fs = require('fs');
const path = require('path');
const fse = require('fs-extra');
const os = require('os');
const {listFiles} = require('@oracle-cx-commerce/tools-util/files');
const {uploadSearchConfig} = require('@oracle-cx-commerce/cli/actions/endpoint/search-config');
const {guidedSearch} = require('@oracle-cx-commerce/cli/actions/endpoint/guided-search');
const {mockConsole} = require('@oracle-cx-commerce/test/utils/console');
const {createTestApp} = require('@oracle-cx-commerce/test/utils/temp-app');
const {mockFetchResponse, clearMockResponses, Response} = require('node-fetch');

const fsp = fs.promises;
const applications = ['cloudlake'];
const searchConfigDirectory = 'config/search/config/pages';
const searchConfigPath = appDir => path.join(appDir, searchConfigDirectory);
// eslint-disable-next-line no-bitwise
const existsAndAccessibleMode = fs.constants.F_OK | fs.constants.R_OK;

const testSkippedOnWindows = os.platform() === 'win32' ? test.skip : test;

const cliOptionsBase = {
  appServerAdmin: 'http://localhost:9080',
  appKey: 'app.key=='
};

const mock = {
  responses: {
    200: {
      json: {
        ok: true,
        status: 200,
        statusText: 'OK',
        headers: {'Content-Type': 'application/json'}
      }
    },
    201: {
      ok: true,
      status: 201,
      statusText: 'Created',
      headers: {'Content-Type': 'application/json'}
    },
    202: {
      ok: true,
      status: 202,
      statusText: 'Accepted',
      headers: {'Content-Type': 'application/json'}
    },
    404: {
      json: {
        ok: false,
        status: 404,
        statusText: 'Not Found',
        headers: {'Content-Type': 'application/json'}
      }
    }
  },
  load: {
    login: {
      response: {
        200: () => {
          mockFetchResponse(
            'http://localhost:9080/ccadmin/v1/login',
            new Response(
              '{"access_token":"secret.token==","token_type":"bearer","expires_in":900}',
              mock.responses[200].json
            ),
            {method: 'POST', body: 'grant_type=client_credentials'}
          );
        }
      }
    },
    getSearchConfig: page => ({
      response: {
        200: cliOptions => {
          const searchConfiguration = page.match(/^[/]?osf$/)
            ? guidedSearch.admin.pageConfig
            : require(path.join(cliOptions.appDir, searchConfigDirectory, guidedSearch.admin.siteHome, `${page}.js`));

          mockFetchResponse(
            `http://localhost:9080/gsadmin/v1/cloud/pages/Default/${page.replace(/^\//, '')}`,
            new Response(JSON.stringify(searchConfiguration), mock.responses[200].json)
          );
        },
        404: () => {
          mockFetchResponse(
            `http://localhost:9080/gsadmin/v1/cloud/pages/Default/${page.replace(/^\//, '')}`,
            new Response('{}', mock.responses[404].json)
          );
        }
      }
    }),
    deleteSearchConfig: page => ({
      response: {
        202: () => {
          mockFetchResponse(
            `http://localhost:9080/gsadmin/v1/cloud/pages/Default/${page.replace(/^\//, '')}`,
            new Response('{}', mock.responses[202].json),
            {method: 'DELETE'}
          );
        }
      }
    }),
    postSearchConfig: page => ({
      response: {
        201: cliOptions => {
          const searchConfiguration = page.match(/^[/]?osf$/)
            ? guidedSearch.admin.pageConfig
            : require(path.join(cliOptions.appDir, searchConfigDirectory, guidedSearch.admin.siteHome, `${page}.js`));

          mockFetchResponse(
            `http://localhost:9080/gsadmin/v1/cloud/pages/Default/${page.replace(/^\//, '')}`,
            new Response('{}', mock.responses[201].json),
            {
              method: 'POST',
              body: searchConfiguration
            }
          );
        }
      }
    })
  },
  clear: () => clearMockResponses()
};

describe('The GS page configuration files are stored in the OSF-based accelerator apps.', () => {
  describe.each(applications)(`The '%s' app has a '${searchConfigDirectory}' folder`, appName => {
    const cliOptions = {...cliOptionsBase};
    let tempDir;

    beforeAll(async () => {
      try {
        tempDir = await createTestApp(appName);
      } catch (error) {
        expect(error).toBeUndefined();
      }
      cliOptions.appDir = tempDir.path;

      // Create additional config files.
      try {
        const source = path.join(tempDir.path, searchConfigDirectory, 'Default/osf/catalog.js');
        let destination = source.replace('catalog', 'store-locations');
        await fse.copy(source, destination);
        destination = source.replace('catalog', 'articles');
        await fse.copy(source, destination);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    afterAll(() => {
      // Delete the temporary work directory
      tempDir.cleanup();
    });

    test('The application folder exists and is accessible', async () => {
      await expect(fsp.access(cliOptions.appDir, existsAndAccessibleMode)).resolves.toBeUndefined();
    });

    test('The search configuration folder exists and is accessible', async () => {
      await expect(fsp.access(searchConfigPath(cliOptions.appDir), existsAndAccessibleMode)).resolves.toBeUndefined();
    });

    test('The search configuration folder contains at least one configuration file in JS format', async () => {
      const siteHomeSearchConfigPath = path.join(searchConfigPath(cliOptions.appDir), guidedSearch.admin.siteHome);
      const files = await listFiles({directory: siteHomeSearchConfigPath, recursive: true});

      const arrayContainingAJsFile = expect.arrayContaining([expect.stringMatching(/.+\.js/)]);
      const jsFiles = files.filter(file => file.endsWith('.js'));

      expect(files).toEqual(arrayContainingAJsFile);
      expect(jsFiles.length).toBeGreaterThanOrEqual(1);

      const firstFilePath = path.resolve(jsFiles[0]);
      const firstFileContent = require(firstFilePath);
      const basicGSConfig = {
        ...guidedSearch.admin.pageConfig,
        contentItem: {'@type': 'GuidedSearchService'}
      };

      expect(firstFileContent).toMatchObject(basicGSConfig);
    });

    testSkippedOnWindows(
      'The search configuration files are stored in a directory hierarchy that matches their corresponding search service URLs',
      async () => {
        const fileList = await listFiles({directory: searchConfigPath(cliOptions.appDir), recursive: true});
        const searchConfigSite = path.join(searchConfigPath(cliOptions.appDir), guidedSearch.admin.siteHome);
        const configFiles = fileList
          .filter(filename => filename.endsWith('.js'))
          .filter(filename => filename.startsWith(searchConfigSite));

        expect(configFiles.length).toBeGreaterThanOrEqual(1);
        configFiles.forEach(configFile =>
          expect(configFile).toMatch(
            new RegExp(`${searchConfigPath(cliOptions.appDir)}/${guidedSearch.admin.siteHome}/(\\w+/)+`)
          )
        );
      }
    );
  });
});

describe('Tool behavior', () => {
  const appName = 'cloudlake';

  describe('One search configuration file', () => {
    let tempDir;
    const cliOptions = {...cliOptionsBase};

    beforeAll(async () => {
      try {
        tempDir = await createTestApp(appName);
      } catch (error) {
        expect(error).toBeUndefined();
      }
      cliOptions.appDir = tempDir.path;
    });

    afterAll(() => {
      // Delete the temporary work directory
      tempDir.cleanup();
    });

    testSkippedOnWindows(
      'To upload the GS page configuration files to an OCCS environment, the developer must specify the application name and the OCC environment.',
      async () => {
        await mockConsole(['log', 'error', 'warn', 'debug'], async () => {
          mock.load.login.response[200]();
          mock.load.getSearchConfig('/osf').response[404]();
          mock.load.postSearchConfig('/osf').response[201]();
          mock.load.getSearchConfig('/osf/catalog').response[404]();
          mock.load.postSearchConfig('/osf/catalog').response[201](cliOptions);

          await expect(uploadSearchConfig(appName, cliOptions)).resolves.toBeUndefined();

          mock.clear();
        });
      }
    );
  });

  describe('Multiple search configuration files', () => {
    let tempDir;
    const cliOptions = {...cliOptionsBase};

    beforeAll(async () => {
      try {
        tempDir = await createTestApp(appName);
      } catch (error) {
        expect(error).toBeUndefined();
      }
      cliOptions.appDir = tempDir.path;

      // Create additional config files.
      try {
        const source = path.join(tempDir.path, searchConfigDirectory, 'Default/osf/catalog.js');
        let destination = source.replace('catalog', 'store-locations');
        await fse.copy(source, destination);
        destination = source.replace('catalog', 'articles');
        await fse.copy(source, destination);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    afterAll(() => {
      // Delete the temporary work directory
      tempDir.cleanup();
    });

    testSkippedOnWindows(
      'To upload the GS page configuration files to an OCCS environment, the developer must specify the application name and the OCC environment.',
      async () => {
        await mockConsole(['log', 'error', 'warn', 'debug'], async () => {
          mock.load.login.response[200]();
          mock.load.getSearchConfig('/osf').response[404]();
          mock.load.postSearchConfig('/osf').response[201]();
          mock.load.getSearchConfig('/osf/catalog').response[404]();
          mock.load.postSearchConfig('/osf/catalog').response[201](cliOptions);
          mock.load.getSearchConfig('/osf/articles').response[404]();
          mock.load.postSearchConfig('/osf/articles').response[201](cliOptions);
          mock.load.getSearchConfig('/osf/store-locations').response[404]();
          mock.load.postSearchConfig('/osf/store-locations').response[201](cliOptions);

          await expect(uploadSearchConfig(appName, cliOptions)).resolves.toBeUndefined();

          mock.clear();
        });
      }
    );
  });

  describe("Do not upload files outside the 'search/config/Default/osf' folder", () => {
    let tempDir;
    const cliOptions = {...cliOptionsBase};

    beforeAll(async () => {
      try {
        tempDir = await createTestApp(appName);
      } catch (error) {
        expect(error).toBeUndefined();
      }
      cliOptions.appDir = tempDir.path;

      // Create additional config files.
      try {
        const source = path.join(tempDir.path, searchConfigDirectory, 'Default/osf/catalog.js');
        const destination = path.join(tempDir.path, searchConfigDirectory, 'Default/another-page.js');
        await fse.copy(source, destination);
        await fse.remove(source);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    afterAll(() => {
      // Delete the temporary work directory
      tempDir.cleanup();
    });

    test("Ignore the file on 'search/config/Default/another-page'", async () => {
      await mockConsole(['log', 'error', 'warn', 'debug'], async () => {
        mock.load.login.response[200]();
        mock.load.getSearchConfig('/another-page').response[404]();

        await expect(uploadSearchConfig(appName, cliOptions)).resolves.toBeUndefined();

        mock.clear();
      });
    });
  });

  describe("Only upload files in the 'search/config/Default/osf' folder", () => {
    let tempDir;
    const cliOptions = {...cliOptionsBase};

    beforeAll(async () => {
      try {
        tempDir = await createTestApp(appName);
      } catch (error) {
        expect(error).toBeUndefined();
      }
      cliOptions.appDir = tempDir.path;

      // Create additional config files.
      try {
        const source = path.join(tempDir.path, searchConfigDirectory, 'Default/osf/catalog.js');
        const destination = path.join(tempDir.path, searchConfigDirectory, 'Default/another-page.js');
        await fse.copy(source, destination);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    afterAll(() => {
      // Delete the temporary work directory
      tempDir.cleanup();
    });

    testSkippedOnWindows("All OSF configurations are uploaded and 'another-page' is ignored", async () => {
      await mockConsole(['log', 'error', 'warn', 'debug'], async () => {
        mock.load.login.response[200]();
        mock.load.getSearchConfig('/osf').response[404]();
        mock.load.postSearchConfig('/osf').response[201]();
        mock.load.getSearchConfig('/osf/catalog').response[404]();
        mock.load.postSearchConfig('/osf/catalog').response[201](cliOptions);
        mock.load.getSearchConfig('/another-page').response[404]();

        await expect(uploadSearchConfig(appName, cliOptions)).resolves.toBeUndefined();

        mock.clear();
      });
    });
  });

  describe('Intermediate nodes are not deleted when there are remaining leaf nodes', () => {
    let tempDir;
    const cliOptions = {...cliOptionsBase};

    beforeAll(async () => {
      try {
        tempDir = await createTestApp(appName);
      } catch (error) {
        expect(error).toBeUndefined();
      }
      cliOptions.appDir = tempDir.path;

      // Create additional config files.
      try {
        const source = path.join(tempDir.path, searchConfigDirectory, 'Default/osf/catalog.js');
        let destination = source.replace('catalog', 'store-locations');
        await fse.copy(source, destination);
        destination = source.replace('catalog', 'articles');
        await fse.copy(source, destination);
        destination = path.join(tempDir.path, searchConfigDirectory, 'Default/another-page.js');
        await fse.copy(source, destination);
      } catch (error) {
        expect(error).toBeUndefined();
      }
    });

    afterAll(() => {
      // Delete the temporary work directory
      tempDir.cleanup();
    });

    testSkippedOnWindows("Keep siblings of '/Default/osf'", async () => {
      await mockConsole(['log', 'error', 'warn', 'debug'], async () => {
        mock.load.login.response[200]();
        mock.load.getSearchConfig('/osf').response[200](cliOptions);
        mock.load.deleteSearchConfig('/osf').response[202]();
        mock.load.postSearchConfig('/osf').response[201](cliOptions);
        mock.load.getSearchConfig('/osf/catalog').response[404]();
        mock.load.postSearchConfig('/osf/catalog').response[201](cliOptions);
        mock.load.getSearchConfig('/osf/articles').response[404]();
        mock.load.postSearchConfig('/osf/articles').response[201](cliOptions);
        mock.load.getSearchConfig('/osf/store-locations').response[404]();
        mock.load.postSearchConfig('/osf/store-locations').response[201](cliOptions);
        mock.load.getSearchConfig('/another-page').response[200](cliOptions);

        await expect(uploadSearchConfig(appName, cliOptions)).resolves.toBeUndefined();

        mock.clear();
      });
    });
  });
});
