/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */
const path = require('path');
const fs = require('fs-extra');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});

const {isAppJsonPresent, getAppJsonComponents} = require('./asset-validation-utils');

const {ComponentInstance, PATH_TO_COMPONENT_INSTANCES} = require('./component-instance');
const {Container, PATH_TO_CONTAINERS} = require('./container');
const {Page, PATH_TO_PAGES} = require('./page');
const {Slot, PATH_TO_SLOTS} = require('./slot');
const {GlobalResource, PATH_TO_GLOBAL_RESOURCES} = require('./global-resource');
const {GlobalResourceOverride, PATH_TO_GLOBAL_RESOURCE_OVERRIDES} = require('./global-resource-override');

function checkResourceOverridesDefinedInResources(appDir, localeType) {
  const allGlobalResourceOverrides = [];
  const resourceOverrides = path.join(appDir, 'assets', 'locales', localeType);
  const globalResources = path.join(appDir, 'src', 'locales', localeType);
  if (fs.pathExistsSync(resourceOverrides)) {
    if (!fs.pathExistsSync(globalResources)) {
      logger.warn(
        ___`Global resource overrides exist but couldn't find the corresponding global resources ${localeType} under src/locales.`
      );

      return;
    }
    const globalResourcesContent = fs.readFileSync(resourceOverrides, 'utf-8');
    const parsedGlobalResources = JSON.parse(globalResourcesContent);
    const allGlobalResourcesKeys = Object.keys(parsedGlobalResources);
    const globalResourceOverridesContent = fs.readFileSync(globalResources, 'utf-8');
    const parsedGlobalResourceOverrides = JSON.parse(globalResourceOverridesContent);
    const allGlobalResourceOverridesKeys = Object.keys(parsedGlobalResourceOverrides);
    allGlobalResourceOverridesKeys.forEach(entry => {
      const localesEntryKeys = Object.keys(parsedGlobalResourceOverrides[entry]);
      allGlobalResourceOverrides.push(localesEntryKeys);
    });
    const mergeAllArray = allGlobalResourceOverrides.flat(1);
    const containsAll = allGlobalResourcesKeys.every(element => {
      return mergeAllArray.includes(element);
    });
    const undefinedKey = allGlobalResourcesKeys.filter(x => mergeAllArray.indexOf(x) === -1);
    if (containsAll !== true) {
      logger.warn(`${resourceOverrides}`);
      logger.warn(
        ___`\t - global resource overrides contain a property '${undefinedKey}' that is not defined in the global resources under ${globalResources}.`
      );
    }
  }
}
/**
 * Given a map of all the assets, find assets that share the same title.
 * @param {*} mapToIterate
 * @returns {Integer} total count of assets with duplicate titles
 */
function checkDuplicateTitlesWithinTheSameAsset(mapToIterate) {
  // a running counter for reporting the amount of duplicates found
  let duplicateErrorCount = 0;

  /**
   * A map to sort asset titles, each entry/key will be a 'title' that contains:
   * - count (number of assets found with that title)
   * - instanceName (assets which refer to that title)
   */
  const titlesMap = {};
  for (const instanceName of Object.keys(mapToIterate)) {
    const instance = mapToIterate[instanceName];
    const {title} = instance;
    if (titlesMap[title]) {
      titlesMap[title].count++;
      if (instance.constructor.name === 'Container' || instance.constructor.name === 'Page') {
        titlesMap[title].instances.push(mapToIterate[instanceName].path);
      }
    } else if (instance.constructor.name === 'Container' || instance.constructor.name === 'Page') {
      titlesMap[title] = {
        count: 1,
        instances: [mapToIterate[instanceName].path]
      };
    }
  }
  Object.keys(titlesMap).forEach(title => {
    if (titlesMap[title].count > 1) {
      duplicateErrorCount++;
      logger.error(___`Found a duplicate 'title' ${title} referenced by the following asset:`);
      const duplicates = titlesMap[title].instances;
      duplicates.forEach(dup => {
        logger.error(___`\t - ${dup}`);
      });
    }
  });

  return duplicateErrorCount;
}

/**
 * Check there is no other Base Component with the same name as the Container title
 * @param {*} mappedContainersByName
 */
function checkContainerTitlesWithBaseComponents(mappedContainersByName, appJsonComponents) {
  for (const containerName of Object.keys(mappedContainersByName)) {
    const containerTitle = mappedContainersByName[containerName].title;
    const container = mappedContainersByName[containerName];

    if (appJsonComponents[containerTitle]) {
      container.foundIssues.push(
        ___`\t - the value '${containerTitle}' in the property 'title' of this container has already been used by another base component in .occ/app.json.`
      );
    }
  }
}

/**
 * Iterates over 'mappedComponentInstancesByName' one Component Instance at a time, for each Component Instance
 * if it is type 'layout' (thus referencing other Component Instances/Base Components) check each of the references
 * if it is a valid reference to either Base Component or Component Instance.
 * @param {*} mappedComponentInstancesByName
 */
function validateComponentInstanceReferences(mappedComponentInstancesByName, appJsonComponents) {
  Object.keys(mappedComponentInstancesByName).forEach(componentName => {
    const componentInstance = mappedComponentInstancesByName[componentName];

    // Layout Component Instance contain references to other Component Instances/Base Components
    if (componentInstance.componentInstanceType === 'layout') {
      componentInstance.aggregateComponentReferences.forEach(reference => {
        // check if 'reference' points to a component instance OR if 'reference' point to a base component
        if (!mappedComponentInstancesByName[reference] && !appJsonComponents[reference]) {
          componentInstance.foundIssues.push(
            ___`\t - component instance ${componentInstance.name} is referencing a nonexistent asset '${reference}'.`
          );
        }
      });
    }
  });
}

/**
 * Check if Containers are referencing existing assets. Iterates over 'mappedContainersByName' one Container at a time
 * and checks whether each reference is a valid reference to either Base Component or Component Instance.
 * @param {*} mappedContainersByName
 * @param {*} mappedComponentInstancesByName
 * @param {*} appJsonComponents
 */
function validateContainerReferences(mappedContainersByName, mappedComponentInstancesByName, appJsonComponents) {
  Object.keys(mappedContainersByName).forEach(containerName => {
    const container = mappedContainersByName[containerName];
    container.aggregateContainerReferences.forEach(ref => {
      if (mappedComponentInstancesByName[ref]) {
        logger.debug(___`${containerName} is referencing '${ref}', which is a component instance.`);
      }
      if (appJsonComponents[ref]) {
        logger.debug(___`${containerName} is referencing '${ref}', which is a base component.`);
      }
      if (!mappedComponentInstancesByName[ref] && !appJsonComponents[ref]) {
        container.foundIssues.push(___`\t - container is referencing '${ref}', which is a nonexistent asset.`);
      }
    });
  });
}

/**
 * Check if Pages are referencing existing assets. Iterates over 'mappedPagesByName' one Page at a time
 * and checks whether each reference is a valid reference to either Base Component or Component Instance.
 * @param {*} mappedPagesByName
 * @param {*} mappedComponentInstancesByName
 * @param {*} appJsonComponents
 */
function validatePageReferences(mappedPagesByName, mappedComponentInstancesByName, appJsonComponents) {
  Object.keys(mappedPagesByName).forEach(pageName => {
    const page = mappedPagesByName[pageName];

    page.aggregatePageReferences.forEach(ref => {
      if (mappedComponentInstancesByName[ref]) {
        logger.debug(___`${pageName} is referencing '${ref}', which is a component instance.`);
      }
      if (appJsonComponents[ref]) {
        logger.debug(___`${pageName} is referencing '${ref}', which is a base component.`);
      }
      if (!mappedComponentInstancesByName[ref] && !appJsonComponents[ref]) {
        page.foundIssues.push(___`\t - page is referencing '${ref}', which is a nonexistent asset.`);
      }
    });
  });
}

function validateSlotReferences(mappedSlotsByName, mappedComponentInstancesByName) {
  Object.keys(mappedSlotsByName).forEach(slotName => {
    const slot = mappedSlotsByName[slotName];
    slot.aggregateSlotReferences.forEach(ref => {
      if (mappedComponentInstancesByName[ref]) {
        logger.debug(___`${slotName} is referencing '${ref}', which is a component instance.`);
      }
      if (!mappedComponentInstancesByName[ref]) {
        slot.foundIssues.push(___`\t - slot is referencing '${ref}', which is a nonexistent asset.`);
      }
    });
  });
}

function validatePageSlotWithSlotNames(mappedSlotsByName, mappedPagesByName) {
  Object.keys(mappedPagesByName).forEach(pageName => {
    const page = mappedPagesByName[pageName];

    page.aggregatePageSlotsReferences.forEach(ref => {
      if (mappedSlotsByName[ref]) {
        logger.debug(___`${pageName} slot is referencing '${ref}', which is a slot.`);
      }
      if (!mappedSlotsByName[ref]) {
        page.foundIssues.push(___`\t - page's slot is referencing '${ref}', which is a nonexistent slot.`);
      }
    });
  });
}

/**
 * Iterate over Component Instances/Containers and log the found errors
 * @param {*} mappedComponentInstancesByName
 */
async function reportErrors(mapToIterate) {
  Object.keys(mapToIterate).forEach(instanceName => {
    const instance = mapToIterate[instanceName];
    if (instance.foundIssues.length > 0) {
      logger.error(`'${instance.path}':`);
    }
    instance.foundIssues.forEach(issue => logger.error(issue));
  });
}

async function validateAssets(appName, options) {
  const {appDir} = options;
  logger.info(___`Validating assets for ${appName}.`);
  if (!isAppJsonPresent(appDir)) {
    throw new Error(
      ___`Unable to validate assets due to missing 'app.json' file, please run 'yarn occ output ${appName}' to generate app.json in order to proceed with asset validation.`
    );
  }

  const pathToComponentsToValidate = path.join(appDir, PATH_TO_COMPONENT_INSTANCES);
  const pathToContainersToValidate = path.join(appDir, PATH_TO_CONTAINERS);
  const pathToPagesToValidate = path.join(appDir, PATH_TO_PAGES);
  const pathToSlotsToValidate = path.join(appDir, PATH_TO_SLOTS);
  const pathToGlobalResourcesToValidate = path.join(appDir, PATH_TO_GLOBAL_RESOURCES);
  const pathToGlobalResourceOverridesToValidate = path.join(appDir, PATH_TO_GLOBAL_RESOURCE_OVERRIDES);

  const mappedComponentInstancesByName = {};
  const mappedContainersByName = {};
  const mappedPagesByName = {};
  const mappedSlotsByName = {};
  const mappedGlobalResourcesByName = {};
  const mappedGlobalResourceOverridesByName = {};

  if (fs.pathExistsSync(pathToComponentsToValidate)) {
    fs.readdirSync(pathToComponentsToValidate).forEach(componentName => {
      const pathToFile = path.join(pathToComponentsToValidate, componentName);
      if (!fs.lstatSync(pathToFile).isDirectory()) return; //Skipping entries that are not directories
      mappedComponentInstancesByName[componentName] = new ComponentInstance(componentName, appDir);
    });
  }
  if (fs.pathExistsSync(pathToContainersToValidate)) {
    fs.readdirSync(pathToContainersToValidate).forEach(containerFileName => {
      const containerName = path.parse(containerFileName).name;
      mappedContainersByName[containerName] = new Container(containerFileName, appDir);
    });
  }
  if (fs.pathExistsSync(pathToPagesToValidate)) {
    fs.readdirSync(pathToPagesToValidate).forEach(pageFileName => {
      const pageName = path.parse(pageFileName).name;
      mappedPagesByName[pageName] = new Page(pageFileName, appDir);
    });
  }
  if (fs.pathExistsSync(pathToSlotsToValidate)) {
    fs.readdirSync(pathToSlotsToValidate).forEach(slotName => {
      const pathToFile = path.join(pathToSlotsToValidate, slotName);
      if (!fs.lstatSync(pathToFile).isDirectory()) return; //Skipping entries that are not directories
      mappedSlotsByName[slotName] = new Slot(slotName, appDir);
    });
  }
  if (fs.pathExistsSync(pathToGlobalResourcesToValidate)) {
    fs.readdirSync(pathToGlobalResourcesToValidate).forEach(globalResourcesFileName => {
      const globalResourceName = path.parse(globalResourcesFileName).name;
      mappedGlobalResourcesByName[globalResourceName] = new GlobalResource(globalResourcesFileName, appDir);
    });
  }
  if (fs.pathExistsSync(pathToGlobalResourceOverridesToValidate)) {
    fs.readdirSync(pathToGlobalResourceOverridesToValidate).forEach(globalResourceOverridesFileName => {
      const globalResourceOverridesName = path.parse(globalResourceOverridesFileName).name;
      mappedGlobalResourceOverridesByName[globalResourceOverridesName] = new GlobalResourceOverride(
        globalResourceOverridesFileName,
        appDir
      );
    });
  }

  // A temporary hack to get all the information about Base Components for now.
  const appJsonComponents = getAppJsonComponents(appDir);
  /**
   * Begin Component Instance 'cross' validation
   */
  validateComponentInstanceReferences(mappedComponentInstancesByName, appJsonComponents);

  /**
   * Begin Container validation
   */
  validateContainerReferences(mappedContainersByName, mappedComponentInstancesByName, appJsonComponents);
  checkContainerTitlesWithBaseComponents(mappedContainersByName, appJsonComponents);

  /**
   * Validate if Container Base Component exists
   */
  Object.keys(mappedContainersByName).forEach(containerName => {
    const containerInstance = mappedContainersByName[containerName];
    if (
      !appJsonComponents[containerInstance.component] &&
      containerInstance.component &&
      typeof containerInstance.component === 'string'
    ) {
      containerInstance.foundIssues.push(___`\t - base component does not exist.`);
    }
  });

  const duplicateContainerTitleCount = checkDuplicateTitlesWithinTheSameAsset(mappedContainersByName);
  const duplicatePageTitleCount = checkDuplicateTitlesWithinTheSameAsset(mappedPagesByName);
  const readAllLocales = path.join('packages', 'core', 'ui', 'resources');
  if (fs.pathExistsSync(readAllLocales)) {
    const getAllLocalesOptions = fs.readdirSync(readAllLocales, 'utf-8');
    getAllLocalesOptions.forEach(locale => {
      checkResourceOverridesDefinedInResources(appDir, locale);
    });
  }
  /**
   * Begin Page validation
   */
  validatePageReferences(mappedPagesByName, mappedComponentInstancesByName, appJsonComponents);
  /**
   * Begin Slot validation
   */
  validateSlotReferences(mappedSlotsByName, mappedComponentInstancesByName);
  validatePageSlotWithSlotNames(mappedSlotsByName, mappedPagesByName);

  reportErrors(mappedComponentInstancesByName);
  reportErrors(mappedContainersByName);
  reportErrors(mappedPagesByName);
  reportErrors(mappedSlotsByName);
  reportErrors(mappedGlobalResourcesByName);
  reportErrors(mappedGlobalResourceOverridesByName);

  const componentInstanceIssuesCount = Object.keys(mappedComponentInstancesByName).reduce(
    (accumulatedCount, componentInstanceName) => {
      return accumulatedCount + mappedComponentInstancesByName[componentInstanceName].foundIssues.length;
    },
    0
  );

  const containerIssuesCount = Object.keys(mappedContainersByName).reduce((accumulatedCount, containerName) => {
    return accumulatedCount + mappedContainersByName[containerName].foundIssues.length;
  }, 0);

  const pageIssuesCount = Object.keys(mappedPagesByName).reduce((accumulatedCount, pageName) => {
    return accumulatedCount + mappedPagesByName[pageName].foundIssues.length;
  }, 0);

  const slotIssuesCount = Object.keys(mappedSlotsByName).reduce((accumulatedCount, slotName) => {
    return accumulatedCount + mappedSlotsByName[slotName].foundIssues.length;
  }, 0);

  const globalResourceIssuesCount = Object.keys(mappedGlobalResourcesByName).reduce(
    (accumulatedCount, globalResourceName) => {
      return accumulatedCount + mappedGlobalResourcesByName[globalResourceName].foundIssues.length;
    },
    0
  );

  const globalResourceOverridesIssuesCount = Object.keys(mappedGlobalResourceOverridesByName).reduce(
    (accumulatedCount, globalResourceOverridesName) => {
      return accumulatedCount + mappedGlobalResourceOverridesByName[globalResourceOverridesName].foundIssues.length;
    },
    0
  );

  const totalIssuesFound =
    componentInstanceIssuesCount +
    containerIssuesCount +
    duplicateContainerTitleCount +
    duplicatePageTitleCount +
    pageIssuesCount +
    slotIssuesCount +
    globalResourceIssuesCount +
    globalResourceOverridesIssuesCount;
  if (totalIssuesFound > 0) {
    throw new Error(
      ___`Asset validation failed, found ${totalIssuesFound} issue(s). Please see issue(s) listed above.`
    );
  } else {
    logger.info(___`All assets pass the validation.`);
  }
}

module.exports = {
  validateAssets
};
