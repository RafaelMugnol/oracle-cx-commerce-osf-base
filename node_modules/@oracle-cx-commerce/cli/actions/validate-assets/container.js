/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */
const path = require('path');
const fs = require('fs-extra');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});

const PATH_TO_CONTAINERS = path.join('assets', 'containers');
const MAX_CONTAINER_NAME_LENGTH = 50;
const MAX_WIDTH = 12;
const MIN_WIDTH = 0;
class Container {
  /**
   * Initialize a Container Object
   * @param {*} containerFileName File name of the Container
   * @param {*} appDir
   */
  constructor(containerFileName, appDir) {
    this.appDir = appDir;
    this.containerFileName = containerFileName;
    this.path = path.join(appDir, PATH_TO_CONTAINERS, containerFileName);

    this.foundIssues = [];

    this.containerFileContent = null;
    this.aggregateContainerReferences = [];

    if (this.containerFileName.length > MAX_CONTAINER_NAME_LENGTH) {
      this.foundIssues.push(___`\t - container file name exceeds the maximum length of ${MAX_CONTAINER_NAME_LENGTH}.`);
    }
    /**
     * Run a function to populate the above fields
     */
    this.processContainerFile();
  }

  /**
   * Validate required property
   * @param {*} obj Layout entry
   * @param {*} propertyName Name of the property
   * @param {*} fn Function that validates the type of a property
   * @param {*} appDir
   */
  validateRequiredProperty(obj, propertyName, fn, entryIndex) {
    if (!Object.prototype.hasOwnProperty.call(obj, propertyName)) {
      this.foundIssues.push(___`\t - layout entry #${entryIndex + 1} is missing the '${propertyName}' property.`);
    } else if (!fn(obj[propertyName])) {
      this.foundIssues.push(
        ___`\t - the type of ${propertyName} property in layout entry #${entryIndex + 1} is invalid.`
      );
    }
  }

  /**
   * - Checks if containerFile exists
   * - Checks if containerFile contains a valid JSON Object
   * - Checks if containerFile contains a 'tile' property
   * - Checks if containerFile contains a 'component' property
   * - Checks if containerFile contains a 'layout' property
   */
  processContainerFile() {
    const containerJsonData = fs.readFileSync(this.path, 'utf-8');
    let parsedContainerJsonData;
    try {
      parsedContainerJsonData = JSON.parse(containerJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t - contains an invalid JSON object.`);

      return;
    }

    if (!parsedContainerJsonData.title) {
      this.foundIssues.push(___`\t - container is missing 'title' property.`);
    } else if (typeof parsedContainerJsonData.title !== 'string') {
      this.foundIssues.push(___`\t - 'title' property contains an invalid data type that is not a string.`);
    }

    if (!parsedContainerJsonData.component) {
      this.foundIssues.push(___`\t - container is missing 'component' property.`);
    } else if (typeof parsedContainerJsonData.component !== 'string') {
      this.foundIssues.push(___`\t - 'component' property contains an invalid data type that is not a string.`);
    }

    if (!parsedContainerJsonData.layout) {
      this.foundIssues.push(___`\t - container is missing 'layout' property.`);

      return;
    }
    if (!Array.isArray(parsedContainerJsonData.layout)) {
      this.foundIssues.push(___`\t - 'layout' property contains an invalid type that is not an array.`);

      return;
    }
    if (parsedContainerJsonData.layout.length === 0) {
      logger.warn(`'${this.path}'`);
      logger.warn(___`\t - 'layout' property contains 0 region defined.`);
    }

    this.containerFileContent = parsedContainerJsonData;
    this.containerLayout = parsedContainerJsonData.layout;
    this.title = parsedContainerJsonData.title;
    this.component = parsedContainerJsonData.component;
    this.validateContainerLayoutEntries(this.containerLayout);

    this.aggregateContainerReferences = this.parseLayoutForContainers(this.containerLayout);
  }

  /**
   * Iterate over each entry in the 'layout' property of containerFileName
   * @param {} containerLayoutEntries
   * @returns {Boolean} true if no issues were found, false otherwise
   */
  validateContainerLayoutEntries(containerLayoutEntries) {
    containerLayoutEntries.forEach((layoutEntry, entryIndex) => {
      this.validateRequiredProperty(layoutEntry, 'width', Number.isInteger, entryIndex);
      if (Number.isInteger(layoutEntry.width) && (layoutEntry.width > MAX_WIDTH || layoutEntry.width < MIN_WIDTH)) {
        this.foundIssues.push(
          ___`\t - layout entry #${
            entryIndex + 1
          } has 'width' property with an invalid value that is greater than ${MAX_WIDTH} or less than ${MIN_WIDTH}.`
        );
      }
      this.validateRequiredProperty(layoutEntry, 'components', Array.isArray, entryIndex);

      if (layoutEntry.type) {
        if (layoutEntry.type !== 'main') {
          this.foundIssues.push(
            ___`\t - layout entry #${entryIndex + 1} has 'type' property that is not set to 'main'.`
          );
        }
      }
    });
  }

  /**
   * Iterates over the entries of the `layout` object coming from the containerFile
   */
  parseLayoutForContainers(containerLayout) {
    const aggregatedEntries = [];
    containerLayout.forEach(layoutEntry => {
      if (layoutEntry.components && Array.isArray(layoutEntry.components)) {
        aggregatedEntries.push(...layoutEntry.components);
      }
    });

    return aggregatedEntries;
  }
}

module.exports = {
  Container,
  PATH_TO_CONTAINERS
};
