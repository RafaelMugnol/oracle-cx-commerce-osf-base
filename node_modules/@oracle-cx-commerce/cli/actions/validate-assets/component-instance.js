/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */
const path = require('path');
const fs = require('fs-extra');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});

const PATH_TO_COMPONENT_INSTANCES = path.join('assets', 'components');
const MAX_COMPONENT_INSTANCE_NAME_LENGTH = 50;
const MAX_LAYOUT_ENTRY_WIDTH = 12;
const MIN_LAYOUT_ENTRY_WIDTH = 0;
const MAX_RESOURCES_LOCALES_LENGTH = 500;
const VALID_REGION_TYPES = ['main', 'header', 'footer'];
class ComponentInstance {
  /**
   * Initialize a Component Instance Object
   * @param {*} name Directory name of the Component Instance
   * @param {*} appDir
   */
  constructor(name, appDir) {
    this.appDir = appDir;
    this.name = name;
    this.path = path.join(appDir, PATH_TO_COMPONENT_INSTANCES, name);

    /**
     *  componentInstanceType could be:
     *  - basic (no layout file exists) [default]
     *  - layout (layout file exists, need to process layout file)
     */
    this.componentInstanceType = 'basic';

    /**
     * From index.json of the Component Instance. Need to validate that it correlates to one of the following:
     * - title of a container
     * - export name of a Base Component
     * - export name of a OOTB React Widget
     */
    this.type = null;
    /**
     * If index.json contains superType, this field will be populated
     */
    this.componentSuperType = null;

    this.foundIssues = [];

    this.configJsonContent = null;
    this.layoutJsonContent = null;
    this.aggregateComponentReferences = null;

    if (this.name.length > MAX_COMPONENT_INSTANCE_NAME_LENGTH) {
      this.foundIssues.push(
        ___`\t - component instance directory name exceeds the maximum length of ${MAX_COMPONENT_INSTANCE_NAME_LENGTH}.`
      );
    }
    /**
     * Run a series of functions to populate the above fields
     */
    this.initializeComponentInstance();
  }

  initializeComponentInstance() {
    this.processIndexJson();
    this.processConfigJson();
    this.processLayoutJson();
    this.processResourcesJson();
    this.processStructureJson();
  }

  /**
   * Validate required property
   * @param {*} obj Region entry
   * @param {*} propertyName Name of the property
   * @param {*} fn Function that validates the type of a property
   * @param {*} appDir
   */
  validateRequiredProperty(obj, propertyName, fn, entryIndex) {
    if (!Object.prototype.hasOwnProperty.call(obj, propertyName)) {
      this.foundIssues.push(___`\t - layout entry #${entryIndex + 1} is missing the '${propertyName}' property.`);
    } else if (!fn(obj[propertyName])) {
      this.foundIssues.push(
        ___`\t - the type of ${propertyName} property in layout entry #${entryIndex + 1} is invalid`
      );
    }
  }
  /**
   * - Checks if index.json exists
   * - Checks if index.json contains a valid JSON Object
   * - Checks if index.json contains a 'type' property
   * - Checks if index.json contains a 'superType' property
   */
  processIndexJson() {
    const pathToIndexFile = path.join(this.path, 'index.json');
    if (!fs.existsSync(pathToIndexFile)) {
      this.foundIssues.push(___`\t	- index.json file is missing.`);

      return;
    }

    const indexJsonData = fs.readFileSync(pathToIndexFile, 'utf-8');
    let parsedIndexJsonData;
    try {
      parsedIndexJsonData = JSON.parse(indexJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t - index.json file contains an invalid JSON object.`);

      return;
    }

    if (!parsedIndexJsonData.type) {
      this.foundIssues.push(___`\t - index.json file is missing 'type' property.`);

      return;
    }

    this.type = parsedIndexJsonData.type;
    this.componentSuperType = parsedIndexJsonData.superType || null;
  }

  /**
   * Checks if config.json exists
   * Checks if config.json contains a valid JSON Object
   *
   * If above conditions are met, store content of file at:
   * - this.configJsonContent
   *
   * If Errors are found sets the following:
   * - this.foundIssues adds string entries with detailed description
   */
  processConfigJson() {
    const pathToConfigJsonFile = path.join(this.path, 'config.json');

    // It is OK for a Component Instance to not have a config.json file, no errors recorded.
    if (!fs.existsSync(pathToConfigJsonFile)) return;

    const configJsonData = fs.readFileSync(pathToConfigJsonFile, 'utf-8');
    let parsedConfigJsonData;
    try {
      parsedConfigJsonData = JSON.parse(configJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t - config.json file contains an invalid JSON object.`);

      return;
    }

    this.configJsonContent = parsedConfigJsonData;
  }

  /**
   * Utilize the following Component Instance class properties:
   * - this.path
   * - this.name
   *
   * If Errors are found sets the following:
   * - this.foundIssues adds string entries with detailed description
   *
   * Iterates over "regions" property if exists and aggregates all the references to other Component
   * Instances or Base Components into a single array to store at:
   * - this.aggregateComponentReferences
   */
  processLayoutJson() {
    const pathToLayoutJsonFile = path.join(this.path, 'layout.json');

    // It is OK for a Component Instance to not have a layout.json file, no errors recorded.
    if (!fs.existsSync(pathToLayoutJsonFile)) return;

    const layoutJsonData = fs.readFileSync(pathToLayoutJsonFile, 'utf-8');
    let parsedLayoutJsonData;
    try {
      parsedLayoutJsonData = JSON.parse(layoutJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t - layout.json file contains an invalid JSON object.`);

      return;
    }

    if (!parsedLayoutJsonData.regions) {
      this.foundIssues.push(___`\t - layout.json exists but is missing the 'regions' property.`);

      return;
    }

    if (parsedLayoutJsonData.regions.length === 0) {
      logger.warn(`'${this.path}'`);
      logger.warn(___`\t - layout.json 'regions' property contains 0 region defined.`);
    }

    this.layoutJsonContent = parsedLayoutJsonData;
    this.layoutRegions = parsedLayoutJsonData.regions;
    this.validateLayoutRegionsEntries(this.layoutRegions);

    this.aggregateComponentReferences = this.parseLayoutRegionsForComponents(this.layoutRegions);
    this.componentInstanceType = 'layout';
  }

  /**
   * Iterate over each entry in the 'region' property of layout.json
   * @param {} layoutRegionsEntries
   * @returns {Boolean} true if no issues were found, false otherwise
   */
  validateLayoutRegionsEntries(layoutRegionsEntries) {
    layoutRegionsEntries.forEach((regionEntry, entryIndex) => {
      this.validateRequiredProperty(regionEntry, 'width', Number.isInteger, entryIndex);
      this.validateRequiredProperty(regionEntry, 'components', Array.isArray, entryIndex);
      if (
        (Number.isInteger(regionEntry.width) && regionEntry.width > MAX_LAYOUT_ENTRY_WIDTH) ||
        regionEntry.width < MIN_LAYOUT_ENTRY_WIDTH
      ) {
        this.foundIssues.push(
          ___`\t - layout.json: regions entry #${
            entryIndex + 1
          } has 'width' property with an invalid value that is greater than ${MAX_LAYOUT_ENTRY_WIDTH} or less than ${MIN_LAYOUT_ENTRY_WIDTH}.`
        );
      }

      if (regionEntry.type) {
        if (!VALID_REGION_TYPES.includes(regionEntry.type)) {
          this.foundIssues.push(
            ___`\t - layout.json: regions entry #${
              entryIndex + 1
            } 'type' property is invalid, 'type' must be one of ${VALID_REGION_TYPES.join(', ')}.`
          );
        }
      }
    });
  }

  /**
   * Iterates over the entries of the `regions` object coming from the 'layout.json' of
   * the Component Instance.
   */
  parseLayoutRegionsForComponents(layoutRegions) {
    const aggregatedEntries = [];
    layoutRegions.forEach(layoutEntry => {
      if (layoutEntry.components) aggregatedEntries.push(...layoutEntry.components);
    });

    return aggregatedEntries;
  }

  processResourcesJson() {
    const pathToResourcesJsonFile = path.join(this.path, 'resources.json');

    // It is OK for a Component Instance to not have a resource.json file, no errors recorded.
    if (!fs.existsSync(pathToResourcesJsonFile)) return;

    const resourceJsonData = fs.readFileSync(pathToResourcesJsonFile, 'utf-8');
    let parsedResourceJsonData;
    try {
      parsedResourceJsonData = JSON.parse(resourceJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t - resources.json file contains an invalid JSON object.`);

      return;
    }

    if (!this.validateResourcesLocales(parsedResourceJsonData)) {
      this.foundIssues.push(___`\t - resources.json contains invalid locale entries.`);
    }
  }
  isIsoDate(str) {
    if (!/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/.test(str)) {
      return false;
    }

    return true;
  }
  isAfter(firstDate, secondDate) {
    const endDate = Date.parse(firstDate);
    const startDate = Date.parse(secondDate);
    if (endDate < startDate) {
      return false;
    }

    return true;
  }
  /**
   * Iterate over the entries for each locale key specified in the resources.json file.
   * For each key:value pair, check if the value exceeds 'MAX_RESOURCES_LOCALES_LENGTH'
   * TODO: check that the locales is supported by verifying local against the OCC listLocales endpoint
   * @param {*} resourcesParsedContent
   * @returns {Boolean} true if no locales value exceed 'MAX_RESOURCES_LOCALES_LENGTH', false otherwise
   */
  validateResourcesLocales(resourcesParsedContent) {
    const localesIssues = [];
    const resourceslocalesList = Object.keys(resourcesParsedContent);

    resourceslocalesList.forEach(locale => {
      const localesEntryKeys = Object.keys(resourcesParsedContent[locale]);
      localesEntryKeys.forEach(localeKey => {
        const localeEntryValue = resourcesParsedContent[locale][localeKey];
        if (localeEntryValue.length > MAX_RESOURCES_LOCALES_LENGTH) {
          localesIssues.push(
            ___`locales '${locale}' has an invalid entry ${localeKey} which exceeds max length of ${MAX_RESOURCES_LOCALES_LENGTH} characters.`
          );
        }
      });
    });

    localesIssues.forEach(issue => {
      this.foundIssues.push(___`\t - resources.json: ${issue}`);
    });

    return localesIssues.length > 0 ? false : true;
  }

  processStructureJson() {
    const pathToStructureJsonFile = path.join(this.path, 'structure.json');

    // It is OK for a Component Instance to not have a structure.json file, no errors recorded.
    if (!fs.existsSync(pathToStructureJsonFile)) return;

    const structureJsonData = fs.readFileSync(pathToStructureJsonFile, 'utf-8');
    let structureResourceJsonData;
    try {
      structureResourceJsonData = JSON.parse(structureJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t -  ${this.name}'s structure.json file contains an invalid JSON object.`);
    }

    if (!structureResourceJsonData.regions) {
      this.foundIssues.push(___`\t - structure.json exists but is missing the 'regions' property.`);

      return;
    }

    structureResourceJsonData.regions.forEach((regionEntry, entryIndex) => {
      if (regionEntry.deviceType && regionEntry.deviceType !== 'xs' && regionEntry.deviceType !== 'md') {
        this.foundIssues.push(
          ___`\t - structure.json: regions entry #${
            entryIndex + 1
          } property 'deviceType' is invalid, 'deviceType' must be 'xs' or 'md'.`
        );
      }

      if (regionEntry.startDate) {
        if (!this.isIsoDate(regionEntry.startDate)) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${
              entryIndex + 1
            } has 'startDate' property that is not in ISO format.`
          );
        }
      }
      if (regionEntry.endDate) {
        if (!this.isIsoDate(regionEntry.endDate)) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${entryIndex + 1} has 'endDate' property that is not in ISO format.`
          );
        }
        if (!this.isAfter(regionEntry.endDate, regionEntry.startDate)) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${
              entryIndex + 1
            } has 'endDate' property that is before 'startDate'.`
          );
        }
      }
    });
  }
}

module.exports = {
  ComponentInstance,
  PATH_TO_COMPONENT_INSTANCES
};
