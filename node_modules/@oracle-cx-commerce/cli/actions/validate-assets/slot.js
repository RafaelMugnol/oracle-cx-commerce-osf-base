/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */
const path = require('path');
const fs = require('fs-extra');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});

const PATH_TO_SLOTS = path.join('assets', 'slots');
const MAX_WIDTH = 12;
const MIN_WIDTH = 0;
const MAX_SLOT_DISPLAY_NAME_LENGTH = 50;
const VALID_TYPES = ['DeviceTypeSlot', 'ContentVariationSlot', 'RoleBasedSlot'];

class Slot {
  /**
   * Initialize a Container Object
   * @param {*} name File name of the Container
   * @param {*} appDir
   */
  constructor(name, appDir) {
    this.appDir = appDir;
    this.name = name;
    this.path = path.join(appDir, PATH_TO_SLOTS, name);

    this.foundIssues = [];

    this.slotFileContent = null;
    this.aggregateSlotReferences = [];
    this.configJsonContent = null;
    this.validateISODate = null;

    /**
     * Run a series of functions to populate the above fields
     */
    this.initializeSlot();
  }

  initializeSlot() {
    this.processIndexJson();
    this.processStructureJson();
    this.processConfigJson();
  }

  processIndexJson() {
    const pathToIndexFile = path.join(this.path, 'index.json');
    if (!fs.existsSync(pathToIndexFile)) {
      this.foundIssues.push(___`\t	- index.json file is missing.`);

      return;
    }

    const indexJsonData = fs.readFileSync(pathToIndexFile, 'utf-8');
    let parsedIndexJsonData;
    try {
      parsedIndexJsonData = JSON.parse(indexJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t - index.json file contains an invalid JSON object.`);

      return;
    }

    if (!parsedIndexJsonData.type) {
      this.foundIssues.push(___`\t - index.json file is missing 'type' property.`);

      return;
    }
    if (!VALID_TYPES.includes(parsedIndexJsonData.type)) {
      this.foundIssues.push(
        ___`\t - index.json 'type' property contains an invalid value ${
          parsedIndexJsonData.type
        }, 'type' must be one of ${VALID_TYPES.join(', ')}.`
      );
    }
    this.type = parsedIndexJsonData.type;
  }

  processStructureJson() {
    const pathToStructureJsonFile = path.join(this.path, 'structure.json');

    if (!fs.existsSync(pathToStructureJsonFile)) return;

    const structureJsonData = fs.readFileSync(pathToStructureJsonFile, 'utf-8');
    let structureResourceJsonData;
    try {
      structureResourceJsonData = JSON.parse(structureJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t -  ${this.name}'s structure.json file contains an invalid JSON object.`);
    }

    if (!structureResourceJsonData.regions) {
      this.foundIssues.push(___`\t - structure.json exists but is missing the 'regions' property.`);

      return;
    }
    if (!Array.isArray(structureResourceJsonData.regions)) {
      this.foundIssues.push(
        ___`\t - structure.json has the 'regions' property with an invalid type that is not an array.`
      );

      return;
    }
    if (structureResourceJsonData.regions.length === 0) {
      logger.warn(`'${this.path}'`);
      logger.warn(___`\t - structure.json 'regions' property contains 0 region defined.`);
    }
    this.layoutRegions = structureResourceJsonData.regions;

    this.validateLayoutRegionsEntries(structureResourceJsonData.regions);

    this.aggregateSlotReferences = this.parseLayoutForSlots(this.layoutRegions);
  }
  /**
   * Checks if config.json exists
   * Checks if config.json contains a valid JSON Object
   *
   * If above conditions are met, store content of file at:
   * - this.configJsonContent
   *
   * If Errors are found sets the following:
   * - this.foundIssues adds string entries with detailed description
   */
  processConfigJson() {
    const pathToConfigJsonFile = path.join(this.path, 'config.json');

    if (!fs.existsSync(pathToConfigJsonFile)) return;

    const configJsonData = fs.readFileSync(pathToConfigJsonFile, 'utf-8');
    let parsedConfigJsonData;
    try {
      parsedConfigJsonData = JSON.parse(configJsonData);
    } catch (error) {
      this.foundIssues.push(___`\t - config.json file contains an invalid JSON object.`);

      return;
    }

    this.configJsonContent = parsedConfigJsonData;
  }

  /**
   * Iterate over each entry in the 'region' property of layout.json
   * @param {} layoutRegionsEntries
   * @returns {Boolean} true if no issues were found, false otherwise
   */
  validateLayoutRegionsEntries(layoutRegionsEntries) {
    layoutRegionsEntries.forEach((regionEntry, entryIndex) => {
      if (regionEntry.components) {
        if (!Array.isArray(regionEntry.components)) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${entryIndex + 1} has 'components' property that is not an array.`
          );
        }
      }
      if (regionEntry.width) {
        if (regionEntry.width > MAX_WIDTH || regionEntry.width < MIN_WIDTH) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${entryIndex + 1} has 'width' property with an invalid value.`
          );
        }
      }
      if (!regionEntry.displayName) {
        this.foundIssues.push(
          ___`\t - structure.json: regions entry #${entryIndex + 1} is missing 'displayName' property.`
        );
      }
      if (regionEntry.displayName && typeof regionEntry.displayName !== 'string') {
        this.foundIssues.push(
          ___`\t - structure.json: regions entry #${entryIndex + 1} has 'displayName' property that is not a string.`
        );
      }
      if (regionEntry.audiences) {
        if (!Array.isArray(regionEntry.audiences)) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${entryIndex + 1} has 'audiences' property that is not an array.`
          );
        }
      }
      if (regionEntry.roles) {
        if (!Array.isArray(regionEntry.roles)) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${entryIndex + 1} has 'roles' property that is not an array.`
          );
        }
      }
      if (regionEntry.deviceType && regionEntry.deviceType !== 'xs' && regionEntry.deviceType !== 'md') {
        this.foundIssues.push(
          ___`\t - structure.json: regions entry #${entryIndex + 1} property 'deviceType' is invalid as '${
            regionEntry.deviceType
          }', 'deviceType' must be 'xs' or 'md'.`
        );
      }
      if (regionEntry.startDate) {
        if (this.isIsoDate(regionEntry.startDate) === false) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${
              entryIndex + 1
            } has 'startDate' property that is not in ISO format.`
          );
        }
      }
      if (regionEntry.endDate) {
        if (this.isIsoDate(regionEntry.endDate) === false) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${entryIndex + 1} has 'endDate' property that is not in ISO format.`
          );
        }
        if (this.isAfter(regionEntry.endDate, regionEntry.startDate) === false) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${
              entryIndex + 1
            } has 'endDate' property that is before 'startDate'.`
          );
        }
      }
      if (regionEntry.resources) {
        if (
          typeof regionEntry.resources != 'object' ||
          (typeof regionEntry.resources == 'object' && Array.isArray(regionEntry.resources))
        ) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${
              entryIndex + 1
            } has 'resources' property with an invalid type that is not a JSON object.`
          );
        }
        const regionsResources = regionEntry.resources || {};
        const languages = Object.keys(regionsResources);
        if (regionEntry.resources[languages].displayName.length > MAX_SLOT_DISPLAY_NAME_LENGTH) {
          this.foundIssues.push(
            ___`\t - structure.json: regions entry #${
              entryIndex + 1
            } has 'displayName' property with an invalid value that is greater than ${MAX_SLOT_DISPLAY_NAME_LENGTH} .`
          );
        }
      }
    });
  }
  isIsoDate(str) {
    if (!/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/.test(str)) {
      return false;
    }
  }
  isAfter(firstDate, secondDate) {
    const endDate = Date.parse(firstDate);
    const startDate = Date.parse(secondDate);
    if (endDate < startDate) {
      return false;
    }
  }
  /**
   * Iterates over the entries of the `layout` object coming from the slot
   */
  parseLayoutForSlots(layoutRegions) {
    const aggregatedEntries = [];
    layoutRegions.forEach(layoutEntry => {
      if (layoutEntry.components && Array.isArray(layoutEntry.components)) {
        aggregatedEntries.push(...layoutEntry.components);
      }
    });

    return aggregatedEntries;
  }
}

module.exports = {
  Slot,
  PATH_TO_SLOTS
};
