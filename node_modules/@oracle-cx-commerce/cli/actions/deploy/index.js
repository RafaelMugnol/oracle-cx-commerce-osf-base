/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
const {cliHelperMethods} = require('@oracle-cx-commerce/cli-shared');
const {downloadAssets} = require('@oracle-cx-commerce/cli-shared');
const {getAssetDownloadZipFileName} = require('@oracle-cx-commerce/tools-util/deployment');

const {
  deployApplication,
  deleteApplication,
  getDeploymentEnvironment,
  getDeploymentDeployStatus,
  getClusterForApp
} = require('@oracle-cx-commerce/tools-util/endpoints');
const {
  getFileFromDeployment,
  getDeploymentFileLocation,
  getDeploymentResponseFileName
} = require('@oracle-cx-commerce/tools-util/deployment');
const {assertFolderExistSync} = require('@oracle-cx-commerce/tools-util');
const fs = require('fs');
const path = require('path');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});
const {getDeploymentsList} = require('@oracle-cx-commerce/tools-util/endpoints');
const {doPublish} = require('./publish');
const {build} = require('./../build');
const {
  postDeploymentVerifyControllerStatus,
  postDeployCheckState,
  isConfiguredControllers,
  logDeploymentInfo
} = require('./status');
const createDeploymentOutput = require('./output');
const {validateOCCVersion} = require('../../utils/index');
const setLoggingOptions = require('./set-logging-options');

async function getDeployJson(deploymentZipFile) {
  const fileContents = await getFileFromDeployment('deployment.json', deploymentZipFile);

  return JSON.parse(fileContents);
}

/**
 * @param {string} appDir the app directory in which to check for production files
 * @returns {Boolean} true if both cjs/min/server.js and esm/min/manifest.json exist, else false
 */
function productionFilesExist(appDir) {
  return (
    fs.existsSync(path.resolve(appDir, 'dist', 'cjs', 'min', 'server.js')) &&
    fs.existsSync(path.resolve(appDir, 'dist', 'esm', 'min', 'manifest.json'))
  );
}

// This action deploys the application to the configured occ instance
// The response is saved to a file
const deploy = async (appName, options) => {
  let zipFile;
  options.reset = await cliHelperMethods.promptConfirmReset(options);
  // add the workspace user name as a deployment tag so it'll appear in OCC.
  options.tag.push(`username:${options.userName}`);
  // Compare the minimum required version with the OCC version.
  validateOCCVersion(options).catch(error => logger.error(error));
  // Query all deployments for an application.
  if (options.list) {
    logger.info(___`Listing deployments for application ${appName}`);
    const response = await getDeploymentsList(options);
    if (!response || response.status === 404 || !response.items || response.items.length === 0) {
      logger.info(___`No deployments found.`);
    } else {
      response.items.forEach(item => {
        logDeploymentInfo(item, false);
      });
    }

    return;
  }
  if (options.zipFile) {
    zipFile = options.zipFile;
    const deployJson = await getDeployJson(zipFile);
    logger.verbose(`deployment.json from zip  ${zipFile} :`);
    logger.verbose(deployJson);
    appName = deployJson.appName;
  } else {
    // Check app directory is accessible.
    assertFolderExistSync(options.appDir, ___`Cannot access application folder: ${path.resolve(options.appDir)}`);
    //when using a "--localDevAppName", we don't require a build because we don't deploy
    //the dist files in this case.
    if (!options.localDevApp) {
      if (options.build) {
        options.production = true;
        await build(appName, options);
      } else if (!productionFilesExist(options.appDir)) {
        logger.error(
          ___`The hosted environment only runs apps in production mode, and will fail to launch an app if it is deployed without the minified production files (e.g. ${options.appDir}/cjs/min/server.js).`
        );
        logger.info(
          ___`Please run 'yarn occ build ${appName} --production' before deploying, or retry 'yarn occ deploy' *without* the '--no-build' flag`
        );
        throw new Error(___`Missing production files for ${appName}.`);
      }
    } else {
      //this leaves out the dist files from the generated zip.
      const ignoreDist = '**/dist/**';
      options.ignore ? options.ignore.push(ignoreDist) : (options.ignore = [ignoreDist]);
    }
    //store deployment zip by host destination
    options.dest = getDeploymentFileLocation(
      options.appServerAdmin,
      options.localDevApp ? options.originAppName : appName
    );

    zipFile = await createDeploymentOutput(appName, options);
  }

  logger.verbose(___`Using  deployment zip located ${path.resolve(zipFile)}`);
  // put the response file in the same folder as the deployment zip
  const deployResponsePath = path.resolve(path.dirname(zipFile), getDeploymentResponseFileName(appName));

  //reset the response file
  fs.writeFileSync(deployResponsePath, '{}');

  const packagedApp = fs.readFileSync(zipFile);

  const restClient = new Client(options.appServerAdmin, options.appKey);

  logger.info(___`Connecting to ${options.appServerAdmin}`);

  let deployResponse;
  let deploymentId;

  const savedResponse = {
    appServerAdmin: options.appServerAdmin,
    date: new Date().toLocaleString()
  };

  await restClient.login(true);

  try {
    if (options.reset) {
      // Q: Should we allow backups even when not resetting?
      // Q: Should be parallel with build/zip creation? Or we expect this to be so fast that's unnecessary?
      if (options.backup) {
        //the pre-deploy backup of assets saved with the deployment zip and response file.
        // Write to the default location
        const preDeployPreviewAssetDownload = path.resolve(
          path.dirname(zipFile),
          getAssetDownloadZipFileName(appName, 'preview')
        );
        try {
          const response = await downloadAssets({
            restClient,
            appName,
            preview: true,
            downloadLocation: preDeployPreviewAssetDownload
          });
          if (response.status !== 200) {
            throw new Error(
              ___`Error backing up preview assets for ${appName} from ${options.appServerAdmin}. Status: ${response.status}`
            );
          }

          logger.info(___`Preview Assets back up saved here:  ${preDeployPreviewAssetDownload}`);
        } catch (error) {
          // Ignore the error if assets didn't exist for the app (might be our first time deploying, so resetting wasn't necessary)
          if (error.response && error.response.status !== 404) {
            throw error;
          }
        }
      }

      logger.info(___`Deleting application ${appName} from ${options.appServerAdmin}`);
      try {
        await deleteApplication({restClient, appName});
      } catch (error) {
        // swallow 404s in this case
        if (!error.response || error.response.status !== 404) {
          throw error;
        }
      }
    } else if (options.backup) {
      logger.verbose(___`Ignoring backup option as this is not a reset deployment.`);
    }

    let deployMessage;
    if (!options.localDevApp) {
      if (options.debugMode === true || options.debugMode === false) {
        // Enable/disable debugMode on the cluster if requested.
        const cluster = await getClusterForApp({...options, restClient, appName});
        if (cluster) {
          await setLoggingOptions(cluster, options);
        } else {
          logger.warn(
            ___`Cannot determine hosted environment for preview to change debug mode because application must be deployed once first.`
          );
        }
      }
      deployMessage = ___`Deploying application ${appName} on ${options.appServerAdmin}`;
    } else {
      deployMessage = ___`Deploying application ${appName} to ${options.appServerAdmin}`;
    }

    logger.info(deployMessage);

    deployResponse = await deployApplication({
      restClient,
      appName,
      appServerAdmin: options.appServerAdmin,
      appKey: options.appKey,
      packagedApp,
      verbose: options.verbose,
      replaceApplication: options.replaceApp,
      deployParams: options.deployParams
    });

    if (deployResponse) {
      savedResponse.response = {
        ...deployResponse
      };
      // save the response for future reference
      fs.writeFileSync(deployResponsePath, JSON.stringify(savedResponse, null, 2));

      if (deployResponse.body) {
        deployResponse = deployResponse.body;

        if (deployResponse.info && Array.isArray(deployResponse.info)) {
          deployResponse.info.forEach(info => {
            logger.verbose(info);
          });
        }
        if (deployResponse.warnings && Array.isArray(deployResponse.warnings)) {
          deployResponse.warnings.forEach(warning => {
            logger.warn(warning);
          });
        }
        if (typeof deployResponse.message === 'string') {
          logger.info(deployResponse.message);
        }
        if (deployResponse.deploymentId) {
          deploymentId = deployResponse.deploymentId;
          logger.info(___`Upload successful.`);
          logger.info(___`Deployment id is ${deployResponse.deploymentId}.`);
        }
      } else {
        throw new Error(___`Unexpected response received from deploy: ${deployResponse}`);
      }
    }
  } catch (error) {
    const errResponse = {};
    errResponse.errors = [];

    errResponse.errors.push(error.message);
    let errorMsg;
    if (
      error.response &&
      error.response.status === 400 &&
      error.response.body &&
      Array.isArray(error.response.body.errors)
    ) {
      error.response.body.errors.forEach(resperror => {
        errorMsg = `${resperror.code} - ${resperror.message}`;
        errResponse.errors.push(errorMsg);
      });
    }
    errResponse.errors.forEach(error => {
      logger.error(error);
    });
    savedResponse.response = {
      ...errResponse
    };

    fs.writeFileSync(deployResponsePath, JSON.stringify(savedResponse, null, 2));
    throw error;
  } finally {
    await restClient.logout();
  }

  //all this code is for self checking of deploy status on the controllers after
  //the deployment.
  //note that errors from this process are not captured to the response file
  //so we don't overwrite the messages from the actual deployment done above.
  await restClient.login(true);
  try {
    let activeStatus = await postDeployCheckState(restClient, deploymentId);
    // get the the deployment environment so we can tell if there are controllers
    // the should be checked.
    const deploymentResponse = await getDeploymentDeployStatus({restClient, id: deploymentId});
    const {clusterId} = deploymentResponse.body.deployment;
    let deploymentEnv;
    if (clusterId && !options.localDevApp && clusterId !== 'NO_CLUSTER_DEPLOY') {
      deploymentEnv = await getDeploymentEnvironment({restClient, clusterId});
      // only check controllers if there are some in preview
      if (activeStatus && isConfiguredControllers(deploymentEnv, false)) {
        logger.info(___`Checking status of deployment installation in hosted preview environment.`);
        activeStatus = await postDeploymentVerifyControllerStatus(restClient, deploymentEnv, deploymentId, false);
      }
    }

    // if we didn't successfully push the deployment to the preview controllers
    // don't run publish
    if (activeStatus && (options.publish || options.publishAll)) {
      if (deploymentEnv) {
        if (options.debugMode === true || options.debugMode === false) {
          // Enable/disable debugMode on the live cluster if requested.
          await setLoggingOptions(clusterId, {...options, live: true});
        }
      }
      logger.info(___`Publish initiated.`);
      await doPublish({restClient, ...options, appName});

      // only check controllers if there are some in live
      if (deploymentEnv && isConfiguredControllers(deploymentEnv, true)) {
        logger.info(___`Checking status of deployment installation in hosted live environment.`);
        activeStatus = await postDeploymentVerifyControllerStatus(restClient, deploymentEnv, deploymentId, true);
      }
    }
    //if either preview or live failed the status check, fail the cli.
    if (!activeStatus) {
      throw new Error(___`Deployment to ${options.appServerAdmin} failed to complete`);
    }
  } finally {
    await restClient.logout();
  }
};

module.exports = {deploy};
