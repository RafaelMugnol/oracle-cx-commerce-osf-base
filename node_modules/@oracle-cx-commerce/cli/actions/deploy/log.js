/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
const {getDeploymentLog} = require('@oracle-cx-commerce/tools-util/endpoints');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const fs = require('fs-extra');
const fileType = require('file-type');
const chalk = require('chalk');

const doGetLogs = async (restClient, reqParams, reqAction, id, itemType) => {
  logger.info(___`Getting logs for ${itemType} ${id}`);

  try {
    const response = await getDeploymentLog({restClient, reqParams, reqAction, id});

    return response;
  } catch (error) {
    if (error.response && error.response.status === 404) {
      throw new Error(___`${itemType} log for ${id} not found.`);
    } else {
      throw error;
    }
  }
};

const getDeploymentLogs = async (restClient, reqParams, deployment) => {
  return doGetLogs(restClient, reqParams, 'applicationDeployment', deployment, 'deployment');
};

const getClusterLogs = async (restClient, reqParams, clusterId) => {
  return doGetLogs(restClient, reqParams, 'deploymentEnvironment', clusterId, 'cluster');
};

const getApplicationLogs = async (restClient, reqParams, application) => {
  return doGetLogs(restClient, reqParams, 'clientApplications', application, 'application');
};

const getLogs = async (appName, options) => {
  const restClient = new Client(options.appServerAdmin, options.appKey);

  logger.info(___`Connecting to ${options.appServerAdmin}`);

  await restClient.login();
  const params = {};
  if (options.zipFile) {
    params.format = 'zip';
  }
  params.preview = !options.live;

  if (options.system) {
    params.syslog = 'true';
  }
  if (options.loggingLevel) {
    params.loggingLevel = options.loggingLevel;
  }
  if (options.since) {
    params.since = options.since;
  }
  if (options.until) {
    params.until = options.until;
  }
  if (options.queryText) {
    params.queryText = options.queryText;
  }
  if (options.limit) {
    params.limit = options.limit;
  }
  if (options.loggingLevel) {
    params.loggingLevel = options.loggingLevel;
  }
  if (options.order) {
    params.order = options.order;
  }
  if (options.label) {
    params.label = options.label;
  }
  if (options.includeArchives) {
    params.includeArchives = 'true';
    if (options.includeArchives !== true) {
      params.numArchiveFiles = options.includeArchives;
    }
  }

  let response;
  if (options.deployment) {
    response = await getDeploymentLogs(restClient, params, options.deployment);
  } else if (options.cluster) {
    const cluster = options.cluster === true ? options.defaultCluster : options.cluster;
    response = await getClusterLogs(restClient, params, cluster);
  } else {
    response = await getApplicationLogs(restClient, params, appName);
  }

  if (response && response.ok) {
    // process the response as a ZIP file
    if (options.zipFile) {
      const {buffer} = response;
      const type = await fileType.fromBuffer(buffer);
      if (type && type.ext === 'zip') {
        let zipFile = `${options.zipFile}`;
        if (!zipFile.endsWith('.zip')) {
          zipFile = `${zipFile}.zip`;
        }
        await fs.writeFile(zipFile, buffer);
        logger.info(`Saved ${zipFile}`);
      } else {
        logger.error('Endpoint returned a corrupted buffer.');
      }

      return;
    }

    // process the response as JSON
    if (options.json) {
      // dump the JSON response body to the console
      logger.info(response.body);

      return;
    }

    // process the response by formatting and printing out the log entries as human readable text
    if (!response.body) {
      // make sure there is a body
      logger.error('No body was returned in the response.');

      return;
    }

    // output the log results as readable text by iterating over the JSON and pulling out each entry
    // each item represents one controller of which there could be many and each item contains 1..n log entries
    if (response.body.results) {
      response.body.results.forEach(result => {
        if (result.items) {
          if (result.host) {
            logger.info(___`logs for ${result.host}`);
          }
          result.items.forEach(entry => {
            // format the timestamp, label, level and message into a single string and output it to stdout
            const logKeys = ['timestamp', 'label', 'level', 'message'];
            const loggingLevel = entry[logKeys[2]];
            let loggingLevelFormatted = chalk.cyan(loggingLevel);
            switch (loggingLevel) {
              case 'error':
                loggingLevelFormatted = chalk.red(loggingLevel);
                break;
              case 'warn':
                loggingLevelFormatted = chalk.yellow(loggingLevel);
                break;
              case 'info':
                loggingLevelFormatted = chalk.green(loggingLevel);
                break;
              default:
                break;
            }
            const message = `${entry[logKeys[0]]} - [${entry[logKeys[1]]}] ${loggingLevelFormatted}: ${
              entry[logKeys[3]]
            }`;
            process.stdout.write(message);
            if (message && !message.endsWith('\n')) {
              process.stdout.write('\n');
            }
            // output any remaining properties on their own line, slightly indented without any formatting since we
            // do not know what the other properties might be.
            Object.keys(entry)
              .filter(k => !logKeys.includes(k))
              .forEach(e => {
                let val = entry[e];
                if (val && val.constructor !== String) {
                  val = JSON.stringify(val, null, 2);
                }
                process.stdout.write(`${e}: ${val}`);
                if (val && !val.endsWith('\n')) {
                  process.stdout.write('\n');
                }
              });
          });
        }
        // no items but message
        else if (result.message) {
          logger.info(___`Host: ${result.host}, Message: ${result.message}`);
        } else {
          // unrecognized response
          throw new Error(___`Unrecognized object in response\n${JSON.stringify(result, null, 2)}`);
        }
      });
    } else {
      logger.info('No results were returned in the body of the response.');
    }

    // output any errors
    if (response.body.errors) {
      throw new Error(___`Errors received in log response\n${JSON.stringify(response.body.errors, null, 2)}`);
    }
  }
};
module.exports = {
  getLogs,
  getDeploymentLogs
};
