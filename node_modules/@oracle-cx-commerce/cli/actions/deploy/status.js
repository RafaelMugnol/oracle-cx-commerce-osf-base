/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const {
  getDeploymentEnvironment,
  getApplicationDeployStatus,
  getClusterDeployStatus,
  getDeploymentDeployStatus
} = require('@oracle-cx-commerce/tools-util/endpoints');

const {getLastDeploymentResponseFromWorkspace} = require('@oracle-cx-commerce/tools-util/deployment');

const contextToString = islive => (islive ? 'live' : 'preview');

const getDeploymentStatus = async (restClient, deployment) => {
  return getDeploymentDeployStatus({restClient, id: deployment});
};

const getClusterStatus = async (restClient, clusterId) => {
  return getClusterDeployStatus({restClient, id: clusterId});
};

const getApplicationStatus = async (restClient, application) => {
  return getApplicationDeployStatus({restClient, id: application});
};

/**
 * @param {string} deployId the deployId to look for
 * @param {string} state the deployment state to look for (e.g. 'ACTIVE', 'FAILED')
 * @return {function} a function that can be used to filter controller statuses
 *    to deployments matching the params
 */
const getDeploymentFilter = (deployId, state) => {
  return args =>
    args.status.deployId && args.status.deployId === deployId && args.status.state && args.status.state === state;
};

/*
 * Reads the given occ deploy status and returns true if the given deployment
 * id was returned as the current deployment (on Admin)
 * for the given context.
 */
const isDeployed = (occDeployStatus, deploymentId, isLive) => {
  const context = contextToString(isLive);
  if (occDeployStatus && occDeployStatus[context] && occDeployStatus[context].deployed) {
    return occDeployStatus[context].deployed === deploymentId;
  }

  return false;
};
/*
 * Determines if the given deployment environment has controllers for the given context
 * If none is found a warning is logged.
 */
const isConfiguredControllers = (occDeploymentEnv, isLive) => {
  const context = contextToString(isLive);
  if (occDeploymentEnv) {
    if (isLive && occDeploymentEnv.liveControllers && occDeploymentEnv.liveControllers.length > 0) {
      return true;
    }
    if (!isLive && occDeploymentEnv.previewControllers && occDeploymentEnv.previewControllers.length > 0) {
      return true;
    }
    logger.warn(___`There is no configured access to the application in the ${context} environment.`);
  }

  return false;
};

/**
 * This util function will read the given deploy status response and return an array
 * of all controllers for the given context report at least one status that
 * passes the given filterCallBack.
 *
 * A false return means at least one controller did not meet the given criteria.
 *
 * @param      {object}  occDeployStatus  The deployment status response received from occ.
 * @param      {String}  deploymentId  The deployment id.
 * @param      {String}  forceDeployId  In the case of a redeployment, the id assigned to the force.
 * @param      {Boolean} isLive whether we should match live (True) or preview (False) controllers.
 * @param      {Boolean} matchError whether controllers that couldn't be contacted (connection error) should be returned
 * @param      {function} filterCallBack This callback is called for each status that was
 * found to match the given deploymentId. Return true from the callback for a match.
 * @returns    {Array<object>} an array of deployment status objects
 */
const findControllersMatchingDeployment = (
  occDeployStatus,
  deploymentId,
  forceDeployId,
  isLive,
  matchError = false,
  filterCallBack
) => {
  const context = contextToString(isLive);
  if (!occDeployStatus || !occDeployStatus[context] || !occDeployStatus[context].controllers) {
    return [];
  }
  const controllerData = occDeployStatus[context].controllers;

  // find controllers that are reporting the deployment as matching the filterCallback
  return controllerData.filter(controller => {
    if (controller.status) {
      const found = controller.status.filter(status => {
        logger.verbose(___`Controller: ${controller.containerId}, status: ${JSON.stringify(status)}`);
        const match = filterCallBack({status, deploymentId, forceDeployId, isLive});
        if (match) {
          logger.debug(___`findControllersMatchingDeployment; Filter matched status`);
        } else {
          logger.debug(___`findControllersMatchingDeployment: Filter did not match status`);
        }

        return match;
      });

      return found.length > 0;
    }
    if (matchError && controller.error) {
      return true;
    }

    return false;
  });
};
/**
 *
 * This util function will read the given deploy status response and return true
 * if each controller for the given context report at least one status that
 * passes the given filterCallBack.
 *
 * A false return means at least one controller did not meet the given criteria.
 *
 * @param      {object}  occDeployStatus  The deployment status response received from occ.
 * @param      {String}  deploymentId  The deployment id.
 * @param      {String}  forceDeployId  In the case of a redeployment, the id assigned to the force.
 * @param      {Boolean} isLive whether we should match live (True) or preview (False) controllers.
 * @param      {Boolean} matchError whether controllers that couldn't be contacted (connection error) should be returned
 * @param      {function} filterCallBack This callback is called for each status that was
 * found to match the given deploymentId. Return true from the callback for a match.
 * @returns    {Boolean} whether all controllers have a deployment matching the params
 */
const testAllControllerDeployStatus = (
  occDeployStatus,
  deploymentId,
  forceDeployId,
  isLive,
  matchError,
  filterCallBack
) => {
  const context = contextToString(isLive);
  if (!occDeployStatus || !occDeployStatus[context] || !occDeployStatus[context].controllers) {
    return false;
  }
  const controllerData = occDeployStatus[context].controllers;
  // find controllers that are reporting the deployment as matching the filterCallback
  const controllersThatMatch = findControllersMatchingDeployment(
    occDeployStatus,
    deploymentId,
    forceDeployId,
    isLive,
    matchError,
    filterCallBack
  );
  if (controllersThatMatch.length !== controllerData.length) {
    return false;
  }

  return true;
};
/**
 *
 * This util function will read the given deploy status response and return true
 * if *ANY* controllers for the given context report at least one status that
 * passes the given filterCallBack.
 *
 * A true return means at least one controller meets the given criteria.
 *
 * @param      {object}  occDeployStatus  The deployment status response received from occ.
 * @param      {String}  deploymentId  The deployment id.
 * @param      {String}  forceDeployId  In the case of a redeployment, the id assigned to the force.
 * @param      {Boolean} isLive whether we should match live (True) or preview (False) controllers.
 * @param      {Boolean} matchError whether controllers that couldn't be contacted (connection error) should be returned
 * @param      {function} filterCallBack This callback is called for each status that was
 * found to match the given deploymentId. Return true from the callback for a match.
 * @return     {Boolean} whether some controller had a deployment matched the filter callback.
 *
 */
const testAnyControllerDeployStatus = (
  occDeployStatus,
  deploymentId,
  forceDeployId,
  isLive,
  matchError,
  filterCallBack
) => {
  const controllersThatMatch = findControllersMatchingDeployment(
    occDeployStatus,
    deploymentId,
    forceDeployId,
    isLive,
    matchError,
    filterCallBack
  );

  return controllersThatMatch.length !== 0;
};
/*
 * Returns true if all controllers report
 * the deployment as active.
 */
const isDeploymentActiveOnAllControllers = (occDeployStatus, deploymentId, isLive) => {
  return testAllControllerDeployStatus(
    occDeployStatus,
    deploymentId,
    null,
    isLive,
    false,
    getDeploymentFilter(deploymentId, 'ACTIVE')
  );
};

/**
 * @returns {boolean} true if any controller reports the deployment as FAILED, or any controller
 * couldn't be contacted
 */
const isDeploymentFailedOnAnyController = (occDeployStatus, deploymentId, isLive) => {
  return testAnyControllerDeployStatus(
    occDeployStatus,
    deploymentId,
    null,
    isLive,
    true,
    getDeploymentFilter(deploymentId, 'FAILED')
  );
};

/*
 * Returns true if all controllers report
 * the force deployment as started.
 */
const isForcedRedeployOnAllControllers = (occDeployStatus, deploymentId, forceDeployId, isLive) => {
  return testAllControllerDeployStatus(occDeployStatus, deploymentId, forceDeployId, isLive, false, args => {
    return (
      args.status.deployId &&
      args.status.deployId === args.deploymentId &&
      args.status.forceDeployId &&
      args.status.forceDeployId === args.forceDeployId
    );
  });
};
/**
 *
 *  Util func that reads the deployment status response from occ and
 *  logs deployment is referenced in the page
 *  repository for preview or live.
 */
const logDeployed = (occDeployStatus, isLive) => {
  const context = contextToString(isLive);
  if (occDeployStatus && occDeployStatus[context] && occDeployStatus[context].deployed) {
    // checks only preview controllers for now. if the --publish
    // options was used we could also check the live controllers
    const {deployed} = occDeployStatus[context];
    logger.info(___`Deployment ${deployed} found in ${context}.`);

    return deployed;
  }

  logger.info(___`No deployment found in ${context}.`);

  return null;
};

/*
 * Reads the deploy status from occ and logs the error message for each
 * controller, if available.
 *
 * Also, logs the app capacity and instance failures for each controller that
 * references the given deployment as active.
 */

const logDeploymentHealth = (occDeployStatus, deploymentId, isLive) => {
  const context = contextToString(isLive);
  if (!occDeployStatus || !occDeployStatus[context] || !occDeployStatus[context].controllers) {
    return;
  }
  const controllerData = occDeployStatus[context].controllers;
  controllerData.forEach(controller => {
    if (controller.error) {
      // got an error instead of a status
      logger.error(___`${controller.error.message}`);
    } else if (controller.status) {
      controller.status.forEach(controllerStatus => {
        if (controllerStatus.state === 'ACTIVE' && controllerStatus.deployId === deploymentId) {
          // Warn if the status is "active" but the appCapacity is less than 1
          if (controllerStatus.appCapacity && controllerStatus.appCapacity < 1) {
            logger.warn(
              ___`Deployment ${deploymentId} on controller ${controller.containerId} is running with fewer node instances than expected. App capacity: ${controllerStatus.appCapacity}.`
            );
          }
          // Log if instance failures/restarts are greater than 0
          if (controllerStatus.instanceFailures && controllerStatus.instanceFailures > 0) {
            logger.info(
              ___`Deployment ${deploymentId} on controller ${controller.containerId} has seen its Node instances fail ${controllerStatus.instanceFailures} times.`
            );
          }
        }
      });
    } else {
      logger.error(___`Unrecognized object in response\n${JSON.stringify(controller, null, 2)}`);
    }
  });
};

/**
 * Attempts to return the reason a deployment failed.
 * @param {object} occDeployStatus The deployment status response received from occ.
 * @param {string} deployId the deployment ID whose failure reason should be found
 * @param {Boolean} isLive whether to look in preview or live
 * @returns {string|undefined} the reason a controller said the deployment failed,
 *    or undefined if it couldn't find one
 */
const getFailureReason = (occDeployStatus, deployId, isLive) => {
  const failedControllers = findControllersMatchingDeployment(
    occDeployStatus,
    deployId,
    null,
    isLive,
    false,
    getDeploymentFilter(deployId, 'FAILED')
  );

  // Return the failure reason in the last controller, if possible
  return (((failedControllers.pop() || {}).status || []).pop() || {}).message;
};

/**
 * Util func that reads the given deploy status response
 * and logs if the given deployment is active on all the
 * preview or live controllers (i.e. a group of controllers).
 *
 * It also logs the health metadata for each
 * active deployment status found.
 *
 */
const logActiveDeployment = (occDeployStatus, deploymentEnv, deploymentId, isLive) => {
  const context = contextToString(isLive);
  if (!occDeployStatus || !occDeployStatus[context]) {
    return;
  }
  if (!deploymentEnv || !isConfiguredControllers(deploymentEnv, isLive)) {
    return;
  }
  if (isDeploymentActiveOnAllControllers(occDeployStatus, deploymentId, isLive)) {
    logger.info(___`Deployment ${deploymentId} is fully installed in hosted ${context} environment.`);
  } else {
    logger.warn(___`Deployment ${deploymentId} is not fully installed in the hosted ${context} environment.`);
    let failureReason;
    if ((failureReason = getFailureReason(occDeployStatus, deploymentId, isLive))) {
      logger.warn(failureReason);
    }
  }

  logDeploymentHealth(occDeployStatus, deploymentId, isLive);
};
/*
 * logs the info, warning and error messages
 */
const logDeploymentMessages = occDeploymentInfo => {
  if (occDeploymentInfo.infoMessages) {
    occDeploymentInfo.infoMessages.forEach(info => {
      logger.info(info);
    });
  }
  if (occDeploymentInfo.warningMessages) {
    occDeploymentInfo.warningMessages.forEach(warning => {
      logger.warn(warning);
    });
  }
  if (occDeploymentInfo.errorMessages) {
    occDeploymentInfo.errorMessages.forEach(error => {
      logger.error(error);
    });
  }
};
/*
 * Logs info about a specific deployment
 */
const logDeploymentInfo = (occDeploymentInfo, showMessages = false) => {
  const meta = JSON.parse(occDeploymentInfo.metadata);
  logger.info(___`- Deployment: ${occDeploymentInfo.repositoryId} -`);
  logger.info(___`  application id: ${occDeploymentInfo.applicationId}`);
  logger.info(___`  cluster id: ${occDeploymentInfo.clusterId}`);
  logger.info(___`  creation date:  ${occDeploymentInfo.creationDate}`);
  logger.info(___`  tags:           ${meta.tags ? meta.tags.join(', ') : 'n/a'}`);
  if (occDeploymentInfo.state) {
    logger.info(___`  state:          ${occDeploymentInfo.state}`);
  }
  if (showMessages) {
    logDeploymentMessages(occDeploymentInfo);
  }
};

/*
 * Returns the given deployment object from
 * the occ deploy status.
 */
function findDeployment(occDeployStatus, deploymentId) {
  //a single deployment can also be returned when only one
  //deployment is queried.
  if (occDeployStatus.deployment) {
    return occDeployStatus.deployment;
  }
  //deploy status can have multiple deployments returned as an array.
  //if so, find the deployment in the array
  if (occDeployStatus.deployments) {
    return occDeployStatus.deployments.find(deployment => {
      return deployment.id === deploymentId;
    });
  }
}
/*
 * Reads the deployment status from occ and logs a series a messages to help
 * interpret the raw response. The raw response can also be logged using verbose
 * logging.
 *
 * For an application, we log info about both its preview and live deployments.
 *
 * 1. The deployments that are currently referenced by the application in preview and live.
 * These are the deployments we expect to find active on the controllers.
 * Note the preview and live deployments may or may not exist and can be different deployments
 * or the same deployment.
 * 2. For deployments found in step 1, log a successful deployment if all the (preview || live)
 * controllers currently reference the deployment as active, or report a possible problem
 * because it's not active on all controllers.
 * 3. Log info about general errors received from the controllers and any reported app instance failures or
 * any discrepancy in the expected app capacity.
 */
async function logApplicationStatus(restClient, occDeployStatus) {
  const previewDeploymentId = logDeployed(occDeployStatus, false);
  let deploymentEnv;
  if (previewDeploymentId) {
    const previewDeployment = findDeployment(occDeployStatus, previewDeploymentId);
    if (previewDeployment) {
      logDeploymentInfo(previewDeployment);
      deploymentEnv = await getDeploymentEnvironment({restClient, clusterId: previewDeployment.clusterId});
      logActiveDeployment(occDeployStatus, deploymentEnv, previewDeploymentId, false);
    }
  }

  const liveDeploymentId = logDeployed(occDeployStatus, true);
  if (liveDeploymentId) {
    const liveDeployment = findDeployment(occDeployStatus, liveDeploymentId);
    if (liveDeployment) {
      logDeploymentInfo(liveDeployment);
      if (!deploymentEnv || deploymentEnv.clusterId !== liveDeployment.clusterId) {
        deploymentEnv = await getDeploymentEnvironment({restClient, clusterId: liveDeployment.clusterId});
      }
      logActiveDeployment(occDeployStatus, deploymentEnv, liveDeploymentId, true);
    }
  }
}

/*
 * Logs info about an occ deployment status.
 *
 * 1. Meta-data about the deployment itself
 * 2. Log if the deployment is currently referenced as the current preview or live deployment
 * for the application (referenced by the deployment)
 * 3. If a current preview or live deployment, check if deployment is active on
 * all preview or live controllers. If not, log a warning.
 */
function logDeploymentStatus(occDeployStatus, deploymentEnv, deploymentId, isLive, showDeploymentMessages = true) {
  // log info about the deployment object
  const deployment = findDeployment(occDeployStatus, deploymentId);
  if (deployment) {
    logDeploymentInfo(deployment, showDeploymentMessages);
  }

  // if the deployment is in preview, check/log if the deployment is
  // active in the preview cluster.
  if (isLive === undefined || !isLive) {
    if (isDeployed(occDeployStatus, deploymentId, false)) {
      logDeployed(occDeployStatus, false);
      logActiveDeployment(occDeployStatus, deploymentEnv, deploymentId, false);
    } else {
      logger.info(___`Deployment ${deploymentId} not found in preview.`);
    }
  }

  // if the deployment is in live, check/log if the deployment is
  // active in the live cluster.
  if (isLive === undefined || isLive) {
    if (isDeployed(occDeployStatus, deploymentId, true)) {
      logDeployed(occDeployStatus, true);
      logActiveDeployment(occDeployStatus, deploymentEnv, deploymentId, true);
    } else {
      logger.info(___`Deployment ${deploymentId} not found in live.`);
    }
  }
}

/**
 * If the occDeployStatus shows any controllers/apps running in debugMode, this function
 * will issue a warning log message and instructions about how to disable debugMode.
 * @param {Object} occDeployStatus a status response from Admin
 *    (with Arrays of controller status responses under keys 'preview' and 'live')
 *    e.g. {preview: [{..., debugMode: false, status: [{deployId: ..., debugMode: false}, ...]}, ...], live: ...}
 */
function warnIfDebugMode(occDeployStatus) {
  if (!occDeployStatus) return;

  const debugModeEnabled = obj => obj && obj.debugMode && obj.debugMode !== 'false';

  // Determine if any preview/live controllers/apps are running in debug mode, and warn about them.
  for (const context of ['preview', 'live']) {
    if (occDeployStatus[context] && occDeployStatus[context].controllers) {
      const {controllers} = occDeployStatus[context];
      const controllerInDebugMode = controllers.some(controller => debugModeEnabled(controller));
      // Only warn about apps that are active running in debug mode
      const appInDebugMode = controllers.some(controller => {
        return (
          Array.isArray(controller.status) &&
          controller.status.some(app => app && app.state === 'ACTIVE' && debugModeEnabled(app))
        );
      });
      if (controllerInDebugMode && !appInDebugMode) {
        logger.warn(
          ___`All apps started in ${context} will be started in debugMode. This will reduce performance. To disable debugMode run 'occ redeploy --no-debugMode ${
            context === 'live' ? '--live' : ''
          }'`
        );
      }
      if (appInDebugMode) {
        logger.warn(
          ___`Some ACTIVE OSF apps running in ${context} are running in debugMode. This will reduce performance. To disable debugMode run 'occ redeploy --no-debugMode ${
            context === 'live' ? '--live' : ''
          }'`
        );
      }
      // Technically could have an app that's not one of the ones queried still running in debugMode, I suppose, and have debugMode off on the controller
      // This would be pretty unlikely, though
      if (!controllerInDebugMode && !appInDebugMode)
        logger.verbose(___`OSF running in production mode in remote environment.`);
    }
  }
}

const sleep = millis => new Promise(resolve => setTimeout(resolve, millis));

/*
 * This util function displays the status of a recent deployment
 * by continually pinging its status for a short period of time.
 *
 * It will continually request the status from occ until all
 * controllers report the deployment as "ACTIVE".
 *
 * If after n tries, it will automatically stop and report an error.
 *
 * If the deployment successfully becomes active on all controllers, a
 * full status of the deployment is logged.
 *
 * Returns true if the deployment becomes active on all controllers.
 *
 */
const postDeploymentVerifyControllerStatus = async (
  restClient,
  deploymentEnv,
  deployment,
  isLive,
  failOnFirstError = true
) => {
  let isAllActive = false,
    failedEarly = false;
  let failureReason;
  const context = contextToString(isLive);

  let response;
  let occDeployStatus;
  const interval = process.env.OCC_STATUS_INTERVAL_MS ? Number(process.env.OCC_STATUS_INTERVAL_MS) : 5000;
  const numChecks = process.env.OCC_STATUS_CHECKS ? Number(process.env.OCC_STATUS_CHECKS) : 20;
  for (let i = 0; i < numChecks; i++) {
    //fetch the status from occ
    response = await getDeploymentStatus(restClient, deployment);
    occDeployStatus = response.body;
    //check for either accepted/rejected

    // check that response contains status info for the given context (preview || live)
    // if not, nothing more can be checked
    logger.info(___`Attempting to install the application workspace in the hosted ${context} environment...`);
    // check if all the controllers report the deployment as active. if so, we're done.
    if ((isAllActive = isDeploymentActiveOnAllControllers(occDeployStatus, deployment, isLive))) {
      break;
    } else if (
      failOnFirstError &&
      (failedEarly = isDeploymentFailedOnAnyController(occDeployStatus, deployment, isLive))
    ) {
      failureReason = getFailureReason(occDeployStatus, deployment, isLive);
      break;
    }
    //otherwise, wait and try again.
    await sleep(interval);
  } //end for

  if (isAllActive) {
    logger.info(___`Successfully deployed to hosted ${context} environment.`);
  } else {
    if (failedEarly) {
      logger.error(___`Deployment did not complete processing in hosted ${context} environment due to an error.`);
    } else {
      logger.error(
        ___`Deployment did not complete processing in hosted ${context} environment in the expected timeframe`
      );
    }
    if (failureReason) {
      logger.warn(failureReason);
    }
    logger.info(___`You can use the 'yarn deploy-status --deployment ${deployment}' command to manually check status.`);
    logger.info(___`If problem persists, please contact support.`);
  }

  logger.info('');
  logger.info(
    ___`The following is the current status of deployment ${deployment} in the hosted ${context} environment.`
  );

  logDeploymentStatus(occDeployStatus, deploymentEnv, deployment, isLive, false);

  logger.verbose(occDeployStatus);
  warnIfDebugMode(occDeployStatus);

  return isAllActive;
};
/*
 * checks the state of the given deployment continuously until either "REJECTED" or "ACCEPTED"
 * When the deployment reaches either state, the info, error and warning messages are also
 * logged.
 */
const postDeployCheckState = async (restClient, deployment) => {
  let response;
  let occDeployStatus;
  const interval = process.env.OCC_STATUS_INTERVAL_MS ? Number(process.env.OCC_STATUS_INTERVAL_MS) : 5000;
  const numChecks = process.env.OCC_STATUS_CHECKS ? Number(process.env.OCC_STATUS_CHECKS) : 180;
  for (let i = 0; i < numChecks; i++) {
    // check that response contains status info for the given context (preview || live)
    // if not, nothing more can be checked
    //fetch the status from occ
    response = await getDeploymentStatus(restClient, deployment);
    occDeployStatus = response.body;
    //check for either accepted/rejected
    if (occDeployStatus) {
      const deploymentDetail = findDeployment(occDeployStatus, deployment);
      if (deploymentDetail) {
        //if no state then occ hasn't been updated with new deployment model.
        if (!deploymentDetail.state) {
          return true;
        }
        logger.info(___`Waiting for deployment to pass validation...`);
        if (deploymentDetail.state && deploymentDetail.state === 'INITIALIZED') {
          await sleep(interval);
          continue;
        }

        logDeploymentMessages(deploymentDetail);
        if (deploymentDetail.state === 'REJECTED') {
          logger.error(___`Deployment was rejected.`);

          return false;
        }
        logger.info(___`Deployment passed validation and was accepted.`);

        return true;
      }
    }
  }
  logger.error(___`Deployment did not pass validation in the expected timeframe.`);
  logger.info(
    ___`You can use the 'yarn deploy-status --deployment ${deployment}' command to manually check its state.`
  );
  logger.info(___`If problem persists, please contact support.`);

  return false;
};
/*
* Logs the status of a specific redeployment based on the json status response
* received from the occ.
*
* It will continually request the status from occ until all
* controllers report the deployment with the given forceRedeployId.

* If after n tries, it will automatically stop and report an error.
*
* Returns true if it's able to find the redeployment started on all controllers.
*/
const postRedeployVerifyStart = async (restClient, deployment, forceRedeployId, isLive) => {
  let isAllForced = false;
  const context = contextToString(isLive);
  let response;
  let occDeployStatus;
  const interval = process.env.OCC_STATUS_INTERVAL_MS ? Number(process.env.OCC_STATUS_INTERVAL_MS) : 5000;
  const numChecks = process.env.OCC_STATUS_CHECKS ? Number(process.env.OCC_STATUS_CHECKS) : 10;
  for (let i = 0; i < numChecks; i++) {
    response = await getDeploymentStatus(restClient, deployment);
    occDeployStatus = response.body;
    logger.info(___`Starting redeployment in ${context}. Please wait...`);
    if ((isAllForced = isForcedRedeployOnAllControllers(occDeployStatus, deployment, forceRedeployId, isLive))) {
      break;
    }
    await sleep(interval);
  }

  if (isAllForced) {
    logger.info(___`Successfully started forced redeployment to ${context}.`);
  } else {
    logger.error(___`Force redeployment failed to ${context}.`);
    logger.info(___`You can use the 'yarn deploy-status --deployment ${deployment}' command to manually check status.`);
    logger.info(___`If problem persists, please contact support.`);
  }
  logger.verbose(occDeployStatus);
  warnIfDebugMode(occDeployStatus);

  return isAllForced;
};

/**
 * Cli invoked function for displaying deployment status.
 * @param {String} appName
 * @param {Object} options
 */
const getStatus = async (appName, options) => {
  const restClient = new Client(options.appServerAdmin, options.appKey);

  await restClient.login();

  let response;
  try {
    if (options.deployment) {
      logger.info(___`Getting status for deployment ${options.deployment} on server ${options.appServerAdmin}`);

      response = await getDeploymentStatus(restClient, options.deployment);
      if (response) {
        if (options.json) {
          logger.info(response.body);
        } else {
          const deployment = findDeployment(response.body, options.deployment);
          let deploymentEnv;
          if (deployment.clusterId) {
            deploymentEnv = await getDeploymentEnvironment({restClient, clusterId: deployment.clusterId});
          }
          logger.verbose(response.body);
          logDeploymentStatus(response.body, deploymentEnv, options.deployment);
        }
      }

      return;
    }
    if (options.last) {
      logger.info(
        ___`Getting the status of the last deployment of application ${appName} from this workspace to ${options.appServerAdmin}.`
      );
      const lastDeploymentResponse = getLastDeploymentResponseFromWorkspace(
        options.appServerAdmin,
        options.originAppName || appName,
        options.originAppName ? appName : undefined
      );

      //we got a response file
      if (lastDeploymentResponse.responseData) {
        //if there's deployment id then check its status
        if (lastDeploymentResponse.deploymentId) {
          // show the deployment status if the deployment ID is found in the json file.
          logger.info(___`Deployed to ${lastDeploymentResponse.appServerAdmin} on ${lastDeploymentResponse.date}`);
          response = await getDeploymentStatus(restClient, lastDeploymentResponse.deploymentId);
          if (response) {
            if (options.json) {
              logger.info(response.body);
            } else {
              const deployment = response.body;
              const deploymentEnv = await getDeploymentEnvironment({restClient, clusterId: deployment.clusterId});
              logger.verbose(response.body);
              logDeploymentStatus(response.body, deploymentEnv, lastDeploymentResponse.deploymentId);
            }
          }
        } else {
          // response file without a deployment id is probably a failure... just dump it out
          logger.info(
            ___`Last deployment of application ${appName} on ${lastDeploymentResponse.date} to ${lastDeploymentResponse.appServerAdmin} resulted in a failure.`
          );
          logger.info(lastDeploymentResponse.responseData);
        }
      } else {
        logger.info(
          ___`No last deployment result for application ${appName} to ${options.appServerAdmin} available on this workspace.`
        );
      }

      return;
    }
    //if the --cluster option was specifically used, do a cluster status using
    //the cluster id provided or the default if none is provided.
    if (options.cluster) {
      const cluster = options.cluster === true ? options.defaultCluster : options.cluster;
      logger.info(___`Getting status for cluster ${cluster} on server ${options.appServerAdmin}`);

      response = await getClusterStatus(restClient, cluster);
    } else {
      logger.info(___`Getting status for application ${appName} on server ${options.appServerAdmin}`);

      response = await getApplicationStatus(restClient, appName);
      if (response) {
        if (options.json) {
          logger.info(response.body);
        } else {
          logger.verbose(response.body);
          await logApplicationStatus(restClient, response.body);
        }
      }

      return;
    }
    if (response) {
      logger.info(response.body);
    } else {
      logger.info(___`No response was returned from status call`);
    }

    return response;
  } catch (error) {
    if (error.response && error.response.status === 404) {
      throw new Error(___`Status not found. 404 response received.`);
    } else {
      logger.error(___`Error checking deployment status`);
      logger.error(error.message);
      throw error;
    }
  } finally {
    if (response && response.body) {
      warnIfDebugMode(response.body);
    }
  }
};

module.exports = {
  postDeploymentVerifyControllerStatus,
  postDeployCheckState,
  postRedeployVerifyStart,
  getStatus,
  getDeploymentEnvironment,
  isConfiguredControllers,
  getDeploymentStatus,
  getClusterStatus,
  getApplicationStatus,
  logDeploymentInfo
};
