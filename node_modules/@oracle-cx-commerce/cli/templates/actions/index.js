/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

const {
  actionIndexExportString,
  actionMetaExportString
} = require('@oracle-cx-commerce/cli/templates/actions/string-utils');

const {
  ACTION_DEFAULT_PATH,
  writeTemplateFiles,
  getPathToActionIndex,
  getPathToActionMeta,
  createOrUpdateImportsAndExports,
  generateTemplateFiles,
  readAppName,
  verifyApp,
  validatePluginFolderExists,
  pluginExists,
  standardizePluginName
} = require('@oracle-cx-commerce/cli/templates/utils');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const logger = require('@oracle-cx-commerce/logger/cli');

/**
 * Adds an export and import reference at the end of an index.js or meta.js file
 *
 * @param      {Object}  options   The command line options including appDir and other widget specific options
 */
async function checkAndUpdateActionExport(options) {
  const pathToActionIndex = getPathToActionIndex(options.appDir);
  const pathToActionMeta = getPathToActionMeta(options.appDir);

  logger.info(___`Updating exports for files:`);
  logger.info(___`\t${pathToActionIndex}`);
  logger.info(___`\t${pathToActionMeta}`);

  createOrUpdateImportsAndExports(pathToActionIndex, actionIndexExportString(options.actionName));
  createOrUpdateImportsAndExports(pathToActionMeta, actionMetaExportString(options.actionName));
}

/**
 * List all files and directories that need to be created for the new action.
 *
 * @param      {string}   name              action name
 * @param      {Object}   options           The command line options including appDir and other widget specific options
 */
async function validateActionOptions(options) {
  if (options.reducer && options.endpoint) {
    throw new Error(___`Can't specify both 'reducer' and 'endpoint'.`);
  }

  if (options.name === undefined && (options.endpoint === undefined || options.endpoint === true)) {
    throw new Error(___`Must specify a name for the action when an endpoint is unspecified.`);
  }
}

async function createAction(appName, options) {
  // Validate/standardize plugin name
  options.actionName = options.name ? standardizePluginName(options.name) : options.endpoint;

  await validateActionOptions(options);

  const actionPath = ACTION_DEFAULT_PATH;
  // Verify app and plugin folder exists.
  await verifyApp(appName, options.appDir);
  validatePluginFolderExists(options.appDir, ACTION_DEFAULT_PATH);

  // Validate no action with the same name already exists
  if (pluginExists(options.appDir, actionPath, dashCase(options.actionName))) {
    throw new Error(
      ___`Action "${dashCase(options.actionName)}", already exists in path ${path.resolve(
        options.appDir,
        ACTION_DEFAULT_PATH
      )}.`
    );
  }

  // Read package name from package.json at app level
  options.packageName = readAppName(options.appDir);

  // Log information about the action to be created
  logger.info(___`Creating action: ${options.actionName}.`);
  logger.info(___`\t Path to action files: ${actionPath}.`);
  if (options.endpoint) {
    logger.info(
      ___`\t Action will invoke endpoint: ${options.endpoint === true ? options.actionName : options.endpoint}`
    );
  }

  // Generate files content to be written
  const templatesDirectory = path.resolve(path.relative('.', __dirname), 'template-files');

  const filesToWrite = generateTemplateFiles(templatesDirectory, options);

  // Define destination for new action
  const installPath = path.join(options.appDir, actionPath);
  const newActionFolder = path.join(installPath, dashCase(options.actionName));
  logger.info(___`Creating new action folder ${newActionFolder}.`);

  // Write the files to the specified destination
  await writeTemplateFiles(newActionFolder, filesToWrite);

  // Update the action's exports
  await checkAndUpdateActionExport(options);
}

module.exports = {createAction};
