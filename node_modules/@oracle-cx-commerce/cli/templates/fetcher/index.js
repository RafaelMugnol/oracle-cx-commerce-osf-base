/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

const {
  fetchersIndexExportString,
  fetchersMetaExportString,
  fetchersHooksExportString
} = require('@oracle-cx-commerce/cli/templates/fetcher/string-utils');

const {
  FETCHER_DEFAULT_PATH,
  WIDGET_DEFAULT_PATH,
  writeTemplateFiles,
  getPathToFetcherIndex,
  getPathToFetcherHooks,
  getPathToFetcherMeta,
  createOrUpdateImportsAndExports,
  generateTemplateFiles,
  verifyApp,
  validatePluginFolderExists,
  pluginExists,
  standardizePluginName,
  capitalizeFirstLetter
} = require('@oracle-cx-commerce/cli/templates/utils');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const logger = require('@oracle-cx-commerce/logger/cli');
const fse = require('fs-extra');

/**
 * Adds an export and import reference at the end of an index.js or meta.js file
 *
 * @param      {Object}  options   The command line options including appDir and other widget specific options
 */
async function checkAndUpdateFetcherExports(options) {
  // If creating a fetcher for a component, resolve the path to the component's fetcher folder.
  const pathToForComponent = options.forComponent
    ? path.join(options.appDir, WIDGET_DEFAULT_PATH, dashCase(options.forComponent))
    : '';

  const pathToFetchersIndex = options.forComponent
    ? path.join(pathToForComponent, 'fetchers', 'index.js')
    : getPathToFetcherIndex(options.appDir);

  const pathToFetchersHooks = options.forComponent
    ? path.join(pathToForComponent, 'fetchers', 'hooks.js')
    : getPathToFetcherHooks(options.appDir);

  const pathToFetchersMeta = options.forComponent
    ? path.join(pathToForComponent, 'fetchers', 'meta.js')
    : getPathToFetcherMeta(options.appDir);

  logger.info(___`Updating exports for files:`);
  await createOrUpdateImportsAndExports(pathToFetchersIndex, fetchersIndexExportString(options.fetcherName));
  await createOrUpdateImportsAndExports(pathToFetchersMeta, fetchersMetaExportString(options.fetcherName));
  await createOrUpdateImportsAndExports(
    pathToFetchersHooks,
    fetchersHooksExportString(options.hookName, options.fetcherName)
  );
  logger.info(___`\t${pathToFetchersIndex}`);
  logger.info(___`\t${pathToFetchersHooks}`);
  logger.info(___`\t${pathToFetchersMeta}`);
}

/**
 * List all files and directories that need to be created for the new component.
 *
 * @param      {string}   name              widget name
 * @param      {Object}   options           The command line options including appDir and other widget specific options
 */
async function createFetcher(appName, options) {
  // Validate/standardize plugin name
  options.fetcherName = standardizePluginName(options.name);
  options.hookName = `use${capitalizeFirstLetter(options.fetcherName)}`;

  // Verify app exists
  await verifyApp(appName, options.appDir);

  // Determine path to create the fetcher at.
  const fetcherPath = options.forComponent
    ? path.join(WIDGET_DEFAULT_PATH, dashCase(options.forComponent), 'fetchers')
    : FETCHER_DEFAULT_PATH;

  // forComponent checks
  if (options.forComponent) {
    validatePluginFolderExists(options.appDir, WIDGET_DEFAULT_PATH);
    // Check if the component exits in the default component/widget path
    if (!pluginExists(options.appDir, WIDGET_DEFAULT_PATH, dashCase(options.forComponent))) {
      // Question: should we prompt Marcus to specify a different path to the widget/component?
      throw new Error(
        ___`Component "${dashCase(options.forComponent)}" does not exist in path ${path.resolve(
          options.appDir,
          WIDGET_DEFAULT_PATH
        )}.`
      );
    }
  }

  // Check if 'fetchers' folders exists, create if it does not.
  try {
    validatePluginFolderExists(options.appDir, fetcherPath);
  } catch (err) {
    await fse.ensureDir(path.resolve(options.appDir, fetcherPath));
  }

  // Check if fetcher with the same name already exists
  if (pluginExists(options.appDir, fetcherPath, `${dashCase(options.fetcherName)}`)) {
    throw new Error(
      ___`Fetcher "${dashCase(options.fetcherName)}", already exists in path ${path.resolve(
        options.appDir,
        FETCHER_DEFAULT_PATH
      )}.`
    );
  }

  // Log information about the fetcher to create
  const fetcherSelectorValue = options.selector
    ? options.selector
    : ___`not provided, please replace 'SELECTOR_PLACEHOLDER_VALUE'`;
  const fetcherEndpointValue = options.endpoint
    ? options.endpoint
    : ___`not provided, please replace 'ENDPOINT_PLACEHOLDER_VALUE'`;

  logger.info(___`Fetcher name: ${options.fetcherName}.`);
  if (options.forComponent) {
    logger.info(___`\tCreating a fetcher for component: ${dashCase(options.forComponent)} in app ${options.appDir}.`);
  } else {
    logger.info(___`\tCreating a global fetcher for app ${options.appDir}.`);
  }
  logger.info(___`\tPath to Fetcher files: ${path.join(options.appDir, fetcherPath)}.`);
  logger.info(___`\tFetcher references: ${options.fetcherName} (fetcher), ${options.hookName} (hook).`);
  logger.info(___`\tFetcher's selector: ${fetcherSelectorValue}.`);
  logger.info(___`\tFetcher's endpoint: ${fetcherEndpointValue}.`);

  // Generate files content to be written
  const templatesDirectory = options.forComponent
    ? path.resolve(path.relative('.', __dirname), 'template-files', 'component-dependent')
    : path.resolve(path.relative('.', __dirname), 'template-files', 'global');

  const filesToWrite = generateTemplateFiles(templatesDirectory, options);

  // Define destination for new fetcher
  const installPath = path.join(options.appDir, fetcherPath);
  const newFetcherFolder = path.join(installPath, dashCase(options.fetcherName));
  logger.info(___`Creating new fetcher folder ${newFetcherFolder}.`);

  // Write the files to the specified destination
  await writeTemplateFiles(newFetcherFolder, filesToWrite);

  // Update Exports
  await checkAndUpdateFetcherExports(options);
}

module.exports = {createFetcher};
