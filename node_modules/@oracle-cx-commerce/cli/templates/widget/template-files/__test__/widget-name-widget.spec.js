/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

function baseTestImports(widgetName) {
  return `import React from 'react';
import {act, cleanup, render, screen, waitForElement} from '@oracle-cx-commerce/test/component/custom-render';
import {createMockStore} from '@oracle-cx-commerce/test/component/create-mock-store';
import {preloadComponents} from '@oracle-cx-commerce/commerce-utils/react';
import Widget from '@oracle-cx-commerce/react-components/widget';

export const ${widgetName} = () => import('../index');
`;
}

function currencySelectorTestContent(widgetName) {
  return `${baseTestImports(widgetName)}
describe('${widgetName} renders correctly and shows after changing visible state', () => {
  /**
   * Reference to dynamic imported comps to resolve and preload.
   */
  const comps = {${widgetName}};
  beforeAll(async () => {
    /**
     * Resolves all components(dynamic) and updates reference to actual implementation
     * Not required if a widget is not a dynamic import reference.
     */
    await preloadComponents(comps);
  });
  beforeEach(() => {
    // Runs before every test.
  });
  afterEach(() => {
    // Runs after every test.
    cleanup(); // Cleans up the window.document with empty body after every test.
  });

  it('${widgetName} works as expected', async done => {
    /**
     * The state structure that will be used by widget to render.
     * Add more relevant repositories to the state.
     */
    const state = {
      pageRepository: {
        widgets: {
          dsWidgetInstance: {
            labelSampleTranslation: 'A Translated Label',
            helloText: 'hello text',
            labelExtraInfo: 'extra info',
            currencies: [],
            selectedCurrency: {},
            id: 'dsWidgetInstance',
            componentId: '${widgetName}',
            regions: []
          }
        }
      }
    };
    /**
     * Create a mock store with the state.
     */
    const mockStore = createMockStore(state);

    /**
     * Renders the widget with store and component providers OOTB.
     */
    render(<Widget widgetId="dsWidgetInstance" />, mockStore, comps);

    /**
     * Wait for render to finish and make sure the rendered DOM has the required labels
     */
    await waitForElement(() => screen.getByText(state.pageRepository.widgets.dsWidgetInstance.labelSampleTranslation));
    done();
  });

  it('${widgetName} triggers listCurrencies endpoint when list of currencies is not present in state', async done => {
    const state = {
      pageRepository: {
        widgets: {
          dsWidgetInstance: {
            labelSampleTranslation: 'A Translated Label',
            helloText: 'hello text',
            labelExtraInfo: 'extra info',
            currencies: [],
            selectedCurrency: {},
            id: 'dsWidgetInstance',
            componentId: '${widgetName}',
            regions: []
          }
        }
      }
    };

    try {
      const endpointPromise = Promise.resolve({
        ok: true,
        status: 200,
        /**
         * Delta is the added state structure being return by the endpoint
         */
        delta: {
          currencyRepository: {
            currencyInfo: {
              currencies: [
                {
                  currencyType: null,
                  symbol: '$',
                  deleted: false,
                  displayName: 'US Dollar',
                  repositoryId: 'en_US',
                  fractionalDigits: 2,
                  currencyCode: 'USD',
                  numericCode: '840'
                }
              ]
            }
          }
        }
      });
      const mockStore = createMockStore(state, {
        'endpoint-listCurrencies': endpointPromise
      });

      const storeEndpointSpy = jest.spyOn(mockStore, 'endpoint');

      render(<Widget widgetId="dsWidgetInstance" />, mockStore, comps);

      // resolving endpoint promise
      await act(() => endpointPromise);

      // verify getCardTypes endpoint triggered
      expect(storeEndpointSpy).toHaveBeenNthCalledWith(1, 'listCurrencies');
      // clear and restore the mocks
      storeEndpointSpy.mockRestore();
      done();
    } catch (e) {
      done.fail();
      console.error('error', e);
    }
  });

  it('Please implement your own tests for ${widgetName}', async done => {
    /**
     * The state structure that will be used by widget to render.
     * Add more relevant repositories to the state.
     */
    const state = {
      pageRepository: {
        widgets: {
          dsWidgetInstance: {
            labelSampleTranslation: 'A Translated Label',
            helloText: 'hello text',
            labelExtraInfo: 'extra info',
            currencies: [],
            selectedCurrency: {},
            id: 'dsWidgetInstance',
            componentId: '${widgetName}',
            regions: []
          }
        }
      }
    };
    /**
     * Create a mock store with the state.
     */
    const mockStore = createMockStore(state);

    /**
     * Renders the widget with store and component providers OOTB.
     */
    render(<Widget widgetId="dsWidgetInstance" />, mockStore, comps);

    /**
     * Wait for render to finish and make sure the rendered DOM has the required labels
     */
    await waitForElement(() => screen.getByText(state.pageRepository.widgets.dsWidgetInstance.labelSampleTranslation));

    /**
     * Remove this statement after full test implemented!
     */
    done.fail('implement the test and state structure used by the widgets!!!');
  });
});
`;
}

function baseTestContent(widgetName) {
  return `${baseTestImports(widgetName)}
describe('${widgetName} renders correctly and shows after changing visible state', () => {
  /**
   * Reference to dynamic imported comps to resolve and preload.
   */
  const comps = {${widgetName}};
  beforeAll(async () => {
    /**
     * Resolves all components(dynamic) and updates reference to actual implementation
     * Not required if a widget is not a dynamic import reference.
     */
    await preloadComponents(comps);
  });
  beforeEach(() => {
    // Runs before every test.
  });
  afterEach(() => {
    // Runs after every test.
    cleanup(); // Cleans up the window.document with empty body after every test.
  });

  it('${widgetName} works as expected', async done => {
    /**
     * The state structure that will be used by widget to render.
     * Add more relevant repositories to the state.
     */
    const state = {
      pageRepository: {
        widgets: {
          dsWidgetInstance: {
            id: 'dsWidgetInstance',
            componentId: '${widgetName}',
            regions: []
          }
        }
      }
    };
    /**
     * Create a mock store with the state.
     */
    const mockStore = createMockStore(state);

    /**
     * Renders the widget with store and component providers OOTB.
     */
    render(<Widget widgetId="dsWidgetInstance" />, mockStore, comps);

    /**
     * Wait for render to finish and make sure the rendered DOM has the required labels
     */
    await waitForElement(() => screen.getByText(/Base/));

    done();
  });
});
`;
}

module.exports = options => {
  let content = '';
  if (options.template && options.template.toLowerCase() === 'currencyselector') {
    content = currencySelectorTestContent(options.widgetName);
  } else {
    content = baseTestContent(options.widgetName);
  }

  return [
    {
      fileName: `${dashCase(options.widgetName)}-widget.spec.js`,
      relativePath: '__test__',
      content
    }
  ];
};
