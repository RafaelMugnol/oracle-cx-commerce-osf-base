/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');
const {
  WIDGET_DEFAULT_PATH,
  writeTemplateFiles,
  getPathToWidgetIndex,
  getPathToWidgetMeta,
  createOrUpdateImportsAndExports,
  generateTemplateFiles,
  readAppLocales,
  readAppName,
  verifyApp,
  validatePluginFolderExists,
  pluginExists,
  standardizePluginName
} = require('@oracle-cx-commerce/cli/templates/utils');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const logger = require('@oracle-cx-commerce/logger/cli');

const {updateAppLocales} = require('./app-wide-locale-utils');
const {componentsIndexExportString, componentsMetaExportString} = require('./string-utils');

const supportedTemplates = ['blank', 'currencyselector'];
// the following dependencies and devDependencies are required when creating a widget using create-widget based on current templates
const requiredDevDependencies = ['@oracle-cx-commerce/react-components', '@oracle-cx-commerce/test'];
const requiredDependencies = ['@oracle-cx-commerce/resources'];

/**
 * Adds an export and import reference at the end of an index.js or meta.js file
 *
 * @param      {Object}  options   The command line options including appDir and other widget specific options
 */
async function updateWidgetExports(options) {
  const pathToComponentsIndex = getPathToWidgetIndex(options.appDir);
  const pathToComponentsMeta = getPathToWidgetMeta(options.appDir);

  logger.info(___`Updating exports for files:`);
  logger.info(___`\t${pathToComponentsIndex}`);
  logger.info(___`\t${pathToComponentsMeta}`);

  createOrUpdateImportsAndExports(pathToComponentsIndex, componentsIndexExportString(options.widgetName));
  createOrUpdateImportsAndExports(pathToComponentsMeta, componentsMetaExportString(options.widgetName));
}

function checkTemplateExists(templateName) {
  if (templateName && !supportedTemplates.includes(templateName.toLowerCase())) {
    throw new Error(
      ___`Template name '${templateName}' not found. Available template choices are: ${supportedTemplates}.`
    );
  }
}

/**
 * Given app name and cli options:
 * - template a set of widget files and write them to a specific app.
 * - Update the index.js and meta.js in the {appDir}/src/plugins/components
 * - Update the app-locales in {appDir}/src/core/ui/locales
 *
 * @param      {string}   appName           The app of which to write the new widget to.
 * @param      {Object}   options           The command line options including appDir and other widget specific options.
 */
async function createWidget(appName, options) {
  if (options.listTemplates) {
    logger.info(___`Available widget templates: ${supportedTemplates.join(', ')}.`);

    return;
  }

  if (!options.name) {
    throw new Error(___`Please provide widget name using the '-n' or '--name' option.`);
  }

  // Validate/standardize plugin name
  options.widgetName = standardizePluginName(options.name);
  const widgetPath = WIDGET_DEFAULT_PATH;

  // Verify app and plugin folder exists.
  await verifyApp(appName, options.appDir);
  validatePluginFolderExists(options.appDir, WIDGET_DEFAULT_PATH);

  if (pluginExists(options.appDir, widgetPath, dashCase(options.widgetName))) {
    throw new Error(
      ___`Component "${dashCase(options.widgetName)}", already exists in path ${path.resolve(
        options.appDir,
        WIDGET_DEFAULT_PATH
      )}.`
    );
  }

  checkTemplateExists(options.template);

  // Log information about the widget to be created
  logger.info(___`Creating Widget: ${options.widgetName}.`);

  // Read locales from package.json at app level
  const localesList = readAppLocales(options.appDir);
  const appPackageName = readAppName(options.appDir);

  updateAppLocales(options.appDir, localesList, appPackageName);

  // Generate files content to be written
  const templatesDirectory = path.resolve(path.relative('.', __dirname), 'template-files');
  // To resolve user provided templates use : path.resolve(process.cwd(), options.templatePath)

  const filesToWrite = generateTemplateFiles(templatesDirectory, options);

  // Define destination for new component
  const installPath = path.join(options.appDir, widgetPath);
  const newWidgetFolder = path.join(installPath, dashCase(options.widgetName));
  logger.info(___`Creating new widget folder ${newWidgetFolder}.`);

  // Write the files to the specified destination
  await writeTemplateFiles(newWidgetFolder, filesToWrite);

  // Update the exports
  await updateWidgetExports(options);
  // Prompt the user to add the required dependencies to devDependencies
  logger.warn(___`Please consider adding the follow packages to your application's dependencies:`);
  requiredDependencies.forEach(dependecy => logger.warn(` - ${dependecy}`));
  logger.warn(___`Please consider adding the follow packages to your application's devDependencies:`);
  requiredDevDependencies.forEach(dependecy => logger.warn(` - ${dependecy}`));
}

module.exports = {createWidget};
