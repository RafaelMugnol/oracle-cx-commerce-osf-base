/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

const {
  componentsIndexExportString,
  componentsMetaExportString
} = require('@oracle-cx-commerce/cli/templates/widget/string-utils');

const {
  WIDGET_DEFAULT_PATH,
  writeTemplateFiles,
  getPathToWidgetIndex,
  getPathToWidgetMeta,
  createOrUpdateImportsAndExports,
  generateTemplateFiles,
  readAppLocales,
  verifyApp,
  validatePluginFolderExists,
  pluginExists,
  standardizePluginName
} = require('@oracle-cx-commerce/cli/templates/utils');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const logger = require('@oracle-cx-commerce/logger/cli');

const supportedTemplates = ['blank', 'currencyselector'];

/**
 * Adds an export and import reference at the end of an index.js or meta.js file
 *
 * @param      {Object}  options   The command line options including appDir and other widget specific options
 */
async function updateWidgetExports(options) {
  const pathToComponentsIndex = getPathToWidgetIndex(options.appDir);
  const pathToComponentsMeta = getPathToWidgetMeta(options.appDir);

  logger.info(___`Updating exports for files:`);
  logger.info(___`\t${pathToComponentsIndex}`);
  logger.info(___`\t${pathToComponentsMeta}`);

  createOrUpdateImportsAndExports(pathToComponentsIndex, componentsIndexExportString(options.widgetName));
  createOrUpdateImportsAndExports(pathToComponentsMeta, componentsMetaExportString(options.widgetName));
}

function checkTemplateExists(templateName) {
  if (templateName && !supportedTemplates.includes(templateName.toLowerCase())) {
    throw new Error(
      ___`Template name '${templateName}' not found. Available template choices are: ${supportedTemplates}.`
    );
  }
}
/**
 * List all files and directories that need to be created for the new component.
 *
 * @param      {string}   name              widget name
 * @param      {Object}   options           The command line options including appDir and other widget specific options
 */
async function createWidget(appName, options) {
  if (options.listTemplates) {
    logger.info(___`Available widget templates: ${supportedTemplates.join(', ')}.`);

    return;
  }

  if (!options.name) {
    throw new Error(___`Please provide widget name using the '-n' or '--name' option.`);
  }

  // Validate/standardize plugin name
  options.widgetName = standardizePluginName(options.name);
  const widgetPath = WIDGET_DEFAULT_PATH;

  // Verify app and plugin folder exists.
  await verifyApp(appName, options.appDir);
  validatePluginFolderExists(options.appDir, WIDGET_DEFAULT_PATH);

  if (pluginExists(options.appDir, widgetPath, dashCase(options.widgetName))) {
    throw new Error(
      ___`Component "${dashCase(options.widgetName)}", already exists in path ${path.resolve(
        options.appDir,
        WIDGET_DEFAULT_PATH
      )}.`
    );
  }

  checkTemplateExists(options.template);

  // Log information about the widget to be created
  logger.info(___`Creating Widget: ${options.widgetName}.`);
  logger.info(___`Path to Widget files: ${path.join(options.appDir, widgetPath)}`);

  // Read locales from package.json at app level
  options.localesList = readAppLocales(options.appDir);

  // Generate files content to be written
  const templatesDirectory = path.resolve(path.relative('.', __dirname), 'template-files');
  // To resolve user provided templates use : path.resolve(process.cwd(), options.templatePath)

  const filesToWrite = generateTemplateFiles(templatesDirectory, options);

  // Define destination for new component
  const installPath = path.join(options.appDir, widgetPath);
  const newWidgetFolder = path.join(installPath, dashCase(options.widgetName));
  logger.info(___`Creating new widget folder ${newWidgetFolder}.`);

  // Write the files to the specified destination
  await writeTemplateFiles(newWidgetFolder, filesToWrite);

  // Update the exports
  await updateWidgetExports(options);
}

module.exports = {createWidget};
