/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const {
  promises: fsp,
  constants: {F_OK}
} = require('fs');
const path = require('path');
const fs = require('fs');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});
const {assertFolderExistSync} = require('@oracle-cx-commerce/tools-util');
const logger = require('@oracle-cx-commerce/logger/cli');
const fse = require('fs-extra');

const WIDGET_DEFAULT_PATH = 'src/plugins/components';
const ACTION_DEFAULT_PATH = 'src/plugins/actions';
const ENDPOINT_DEFAULT_PATH = 'src/plugins/endpoints';
const FETCHER_DEFAULT_PATH = 'src/plugins/fetchers';
const ENDPOINT_FACTORY_PATH = 'src/core/wapi';
const SELECTOR_DEFAULT_PATH = 'src/plugins/selectors';
const SUBSCRIBER_DEFAULT_PATH = 'src/plugins/subscribers';

/**
 * @param {String} appDir
 * @returns {String} a joined path of an app dir and a specific plugin directory
 */
const getPathToWidgetIndex = appDir => path.join(appDir, WIDGET_DEFAULT_PATH, 'index.js');
const getPathToWidgetMeta = appDir => path.join(appDir, WIDGET_DEFAULT_PATH, 'meta.js');
const getPathToFetcherIndex = appDir => path.join(appDir, FETCHER_DEFAULT_PATH, 'index.js');
const getPathToFetcherMeta = appDir => path.join(appDir, FETCHER_DEFAULT_PATH, 'meta.js');
const getPathToFetcherHooks = appDir => path.join(appDir, FETCHER_DEFAULT_PATH, 'hooks.js');
const getPathToActionIndex = appDir => path.join(appDir, ACTION_DEFAULT_PATH, 'index.js');
const getPathToActionMeta = appDir => path.join(appDir, ACTION_DEFAULT_PATH, 'meta.js');
const getPathToEndpointsIndex = appDir => path.join(appDir, ENDPOINT_DEFAULT_PATH, 'index.js');
const getPathToEndpointsMeta = appDir => path.join(appDir, ENDPOINT_DEFAULT_PATH, 'meta.js');
const getPathToSelectorIndex = appDir => path.join(appDir, SELECTOR_DEFAULT_PATH, 'index.js');
const getPathToSubscriberIndex = appDir => path.join(appDir, SUBSCRIBER_DEFAULT_PATH, 'index.js');
const getPathToSubscriberMeta = appDir => path.join(appDir, SUBSCRIBER_DEFAULT_PATH, 'meta.js');

/**
 * Reads a file and returns its content.
 *
 * @param      {string}  path    The file path.
 * @return     {string}  File content.
 */
const readFile = async path => fsp.readFile(path, 'utf8');

/**
 * Writes a file.
 *
 * @param      {string}  destination  Path to write the file to
 * @param      {string}  output       content of the file
 */
async function writeFile(destination, output) {
  // Read dir from the path.
  const {dir} = path.parse(destination);
  // Ensure destination directory exists and we can create the new files.
  await fse.ensureDir(dir);
  // Write the personalized file.
  await fsp.writeFile(destination, output);
}

/**
 * Iterate over a file list, calls writeFile function on each template object
 *
 * @param      {string}   newPluginFolder         The root of the new plugin folder
 * @param      {Array}    fileList                An array of list containing objects which include file name, relative path and file content
 * @param      {Boolean}  quiet                   print files being written to the console
 */
async function writeTemplateFiles(newPluginFolder, fileList, verbose = true) {
  if (verbose) {
    logger.info(___`Writing template files to ${newPluginFolder}:`);
  }
  for (const files of fileList) {
    for (const file of files) {
      if (verbose) {
        logger.info(`\t ${path.join(file.relativePath, file.fileName)}`);
      }
      await writeFile(path.join(newPluginFolder, file.relativePath, file.fileName), file.content);
    }
  }
}
/**
 * Adds an export and import reference at the end of an index.js or meta.js file
 *
 * @param      {string}  pathToFile           Path to write the file to update
 * @param      {string}  contentToAppend      export statement to add
 */
async function createOrUpdateImportsAndExports(pathToFile, content) {
  try {
    assertFolderExistSync(pathToFile, `${pathToFile} does not exist.`);
    fs.appendFileSync(pathToFile, content);
  } catch (error) {
    logger.info(___`${pathToFile} not found, writing a new file.`);
    await writeFile(pathToFile, content);
  }
}

/**
 * Reads the locales from the app level package.json
 *
 * @param      {string}  appDir      Path to app directory
 * @return     {Array}   array of locales
 */
function readAppLocales(appDir) {
  // read locales from package.json at app level
  const pathToPackageJson = path.resolve(appDir, 'package.json');
  const appPackageContent = fs.readFileSync(pathToPackageJson, 'utf8');
  // extract locales defined in package.json
  const jsonData = JSON.parse(appPackageContent);
  const appLocales = jsonData.occ.locales;
  logger.verbose(___`App's locales: ${appLocales}.`);

  return appLocales;
}

/**
 * Reads the application name from the app level package.json
 *
 * @param      {string}  appDir      Path to app directory
 * @return     {Array}   array of locales
 */
function readAppName(appDir) {
  // read locales from package.json at app level
  const pathToPackageJson = path.resolve(appDir, 'package.json');
  const appPackageContent = fs.readFileSync(pathToPackageJson, 'utf8');
  // extract locales defined in package.json
  const jsonData = JSON.parse(appPackageContent);
  const packageName = jsonData.name;

  return packageName;
}
/**
 * Verify an app exists
 *
 * @param      {string}  appName        Name of the app
 * @param      {string}  pathToApp      Path to app directory
 */
async function verifyApp(appName, pathToApp) {
  assertFolderExistSync(pathToApp, `Cannot access application ${appName} at path: ${pathToApp}.`);

  // Check if app package.json files exists.
  const packageJsonPath = path.resolve(pathToApp, 'package.json');
  try {
    await fsp.access(packageJsonPath, F_OK);
  } catch (reason) {
    throw new Error(___`Cannot access application's package.json file at path: ${packageJsonPath}.\n${reason}`);
  }
}

/**
 * Verify the plugin folder exists in the app path
 *
 * @param      {string}  pathToApp        Path to app directory
 * @param      {string}  pathToPlugin     Path to plugin directory
 */
function validatePluginFolderExists(pathToApp, pathToPlugin) {
  const pathToPlugins = path.resolve(pathToApp, pathToPlugin);
  assertFolderExistSync(pathToPlugins, `Cannot access application's plugins folder: ${pathToPlugins}.`);
}

/**
 * Check if a plugin with the same name (case-insensitive) already exists in the plugin directory of a specific app
 *
 * @param      {string}  pathToApp      Path to app directory
 * @param      {string}  pathToPlugin     Path to plugin directory
 * @param      {string}  pluginName     name of the plugin to check
 * @return     {boolean}
 */
function pluginExists(pathToApp, pathToPlugin, pluginName) {
  const pluginList = fs.readdirSync(path.resolve(pathToApp, pathToPlugin)).map(entry => entry.toLowerCase());

  return pluginList.includes(pluginName.toLowerCase());
}

/**
 * List all files and directories that need to be created for the new plugin.
 *
 * @param      {string}   templateDir       The source file path the template files.
 * @param      {Array}    fileList          Accumulating list of files of templates.
 * @param      {string}   relativeDir       Relative path to a file/folder.
 * @return     {Array}    fileList          list of files to template.
 */
function discoverTemplateFiles(templateDir, fileList, relativeDir = '') {
  fileList = fileList || [];
  fs.readdirSync(templateDir).forEach(file => {
    if (fs.statSync(path.resolve(templateDir, file)).isDirectory()) {
      fileList = discoverTemplateFiles(path.join(templateDir, file), fileList, path.join(relativeDir, file));
    } else {
      fileList.push(path.join(relativeDir, file));
    }
  });

  return fileList;
}

/**
 * Transforms static files to template object that can be written by writeFiles
 *
 * @param      {string}   pathToFile       The source file path the template files.
 * @param      {string}    fileName          Accumulating list of files to install
 * @return     {Object}
 */
function transformFile(pathToFile, fileName) {
  const content = fs.readFileSync(path.resolve(pathToFile, fileName), 'utf-8');

  return [
    {
      fileName,
      relativePath: '',
      content
    }
  ];
}
/**
 * Iterates over each template file, process template files based on 'options' to create formatted plugin files.
 *
 * @param      {string}     pathToTemplateFiles   path to the directory holding all the template files
 * @param      {string}     options               cli options for the template files
 * @return     {Array}      Array of template file objects
 */
function generateTemplateFiles(pathToTemplateFiles, options) {
  const pluginFileList = discoverTemplateFiles(pathToTemplateFiles);
  const templatedFiles = [];

  for (const file of pluginFileList) {
    if (path.parse(file).ext === '.js') {
      // A template file with a .js extension exports a function with one parameter
      templatedFiles.push(require(path.resolve(pathToTemplateFiles, file))(options));
    } else {
      // A static template file is read and is constructed into the same object returned by a .js template file
      templatedFiles.push(transformFile(pathToTemplateFiles, file));
    }
  }

  return templatedFiles;
}

/**
 * Transform the first letter to upper case.
 *
 * @param      {string}     optionName
 * @return     {string}
 */
function capitalizeFirstLetter(name) {
  return name.charAt(0).toUpperCase() + name.slice(1);
}

/**
 * Returns a validated plugin name to be used when creating the plugin related folders.
 * @param      {string}     name
 * @return     {string}
 */
function standardizePluginName(name) {
  if (!name || typeof name !== 'string' || !name.trim()) {
    return;
  }

  const matches = name.trim().match(/^[a-z]+|[a-z]+|[A-Z][a-z]+|\d+|[A-Z]+(?![a-z])/g);

  return matches.join('');
}

/**
 * Checks and throws an error if special characters are found in the name.
 * @param      {string}     name
 * @return     {string}
 */
function validatePluginName(name) {
  if (!name || typeof name !== 'string' || !name.trim()) {
    return;
  }

  if (name.match(/[^\w-]|_/g)) {
    throw new Error(___`Invalid name provided. Please provide an alphanumeric name.`);
  } else {
    return name;
  }
}

module.exports = {
  WIDGET_DEFAULT_PATH,
  ACTION_DEFAULT_PATH,
  ENDPOINT_DEFAULT_PATH,
  FETCHER_DEFAULT_PATH,
  ENDPOINT_FACTORY_PATH,
  SELECTOR_DEFAULT_PATH,
  SUBSCRIBER_DEFAULT_PATH,
  getPathToWidgetIndex,
  getPathToWidgetMeta,
  getPathToFetcherIndex,
  getPathToFetcherMeta,
  getPathToFetcherHooks,
  getPathToActionIndex,
  getPathToActionMeta,
  getPathToEndpointsIndex,
  getPathToEndpointsMeta,
  getPathToSelectorIndex,
  getPathToSubscriberIndex,
  getPathToSubscriberMeta,
  readFile,
  writeFile,
  writeTemplateFiles,
  generateTemplateFiles,
  createOrUpdateImportsAndExports,
  readAppLocales,
  readAppName,
  verifyApp,
  validatePluginFolderExists,
  pluginExists,
  discoverTemplateFiles,
  capitalizeFirstLetter,
  standardizePluginName,
  validatePluginName
};
