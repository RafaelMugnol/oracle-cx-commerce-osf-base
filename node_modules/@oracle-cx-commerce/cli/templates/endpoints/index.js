/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

const {
  swaggerEndpointsIndexExportString,
  swaggerEndpointsMetaExportString,
  endpointsIndexExportString,
  endpointsMetaExportString,
  endpointPluginIndexExport,
  endpointPluginMetaExport
} = require('@oracle-cx-commerce/cli/templates/endpoints/string-utils');

const {
  splitURL,
  filterEndpoints,
  processSwaggerInput,
  addOriginToAppConfig
} = require('@oracle-cx-commerce/cli/templates/endpoints/endpoint-utils');

const {
  ENDPOINT_FACTORY_PATH,
  ENDPOINT_DEFAULT_PATH,
  writeTemplateFiles,
  getPathToEndpointsIndex,
  getPathToEndpointsMeta,
  createOrUpdateImportsAndExports,
  generateTemplateFiles,
  verifyApp,
  validatePluginFolderExists,
  writeFile,
  readAppName,
  pluginExists,
  validatePluginName,
  capitalizeFirstLetter,
  standardizePluginName
} = require('@oracle-cx-commerce/cli/templates/utils');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const logger = require('@oracle-cx-commerce/logger/cli');
const fse = require('fs-extra');

/**
 * Adds an export and import reference at the end of an index.js or meta.js file
 *
 * @param      {Object}  options   The command line options including appDir and other widget specific options
 */
async function updateEndpointExports(options) {
  const pathToEndpointsIndex = getPathToEndpointsIndex(options.appDir);
  const pathToEndpointsMeta = getPathToEndpointsMeta(options.appDir);

  logger.info(___`Updating exports for files:`);
  logger.info(___`\t${pathToEndpointsIndex}`);
  logger.info(___`\t${pathToEndpointsMeta}`);
  if (options.url) {
    await createOrUpdateImportsAndExports(pathToEndpointsIndex, endpointsIndexExportString(options.directoryName));
    await createOrUpdateImportsAndExports(pathToEndpointsMeta, endpointsMetaExportString(options.directoryName));
  } else if (options.swagger) {
    await createOrUpdateImportsAndExports(
      pathToEndpointsIndex,
      swaggerEndpointsIndexExportString(options.directoryNamePath)
    );
    await createOrUpdateImportsAndExports(
      pathToEndpointsMeta,
      swaggerEndpointsMetaExportString(options.directoryNamePath)
    );
  }
}

/**
 * Iterate over the list of operation Ids and create the plugin files for each
 *
 * @param {Object}  options                     The command line options including appDir and other widget specific options
 * @param {Array}   swaggerEndpointsList        List of endpoints fetched from the Swagger Document
 * @param {String}  endpointTemplateDirectory   Path to endpoint plugin templates
 */
async function writeEndpointPlugins(options, swaggerEndpointsList, endpointTemplateDirectory) {
  let newEndpointPluginPath, endpointPluginfilesToWrite;
  const newEndpointPluginBasePath = path.join(options.appDir, ENDPOINT_DEFAULT_PATH, options.directoryNamePath);

  // Accumulate all the imports for each endpoints index/meta
  let allIndexImport = '';
  let allMetaImports = '';

  await Promise.all(
    Object.keys(swaggerEndpointsList).map(async endpointId => {
      const copyOfCliOptions = {...options};
      Object.assign(copyOfCliOptions, swaggerEndpointsList[endpointId]);

      // Generate files content to be written for endpoint factory
      endpointPluginfilesToWrite = generateTemplateFiles(endpointTemplateDirectory, copyOfCliOptions);

      // Define destination for new endpoint factory
      newEndpointPluginPath = path.join(newEndpointPluginBasePath, dashCase(copyOfCliOptions.operationId));
      allIndexImport += endpointPluginIndexExport(copyOfCliOptions.operationId);
      allMetaImports += endpointPluginMetaExport(copyOfCliOptions.operationId);

      // Write the files to the specified destination
      return writeTemplateFiles(newEndpointPluginPath, endpointPluginfilesToWrite, false);
    })
  );
  // Write the accumulated import/exports for all newly created endpoints
  await writeFile(path.join(newEndpointPluginBasePath, 'index.js'), allIndexImport);
  await writeFile(path.join(newEndpointPluginBasePath, 'meta.js'), allMetaImports);
}

/**
 * Create an endpoint factory and endpoint plugins for a specific API Catalog
 *
 * @param      {string}   name              endpoint folder name
 * @param      {Object}   options           The command line options including appDir and other widget specific options
 */
async function validateEndpointOptions(options) {
  if (!options.swagger && !options.url) {
    throw new Error(
      ___`The endpoint URL is missing. Please specify either '--swagger' or '--url' when creating endpoints.`
    );
  }
  if (options.swagger && options.verb) {
    throw new Error(___`Can't specify 'verb' when creating endpoints from a swagger document.`);
  }
  if (options.swagger && options.url) {
    throw new Error(___`Can't specify both '--swagger' and '--url' when creating an endpoint.`);
  }
  if (options.url && options.endpoints) {
    throw new Error(___`Can't specify 'endpoints' when creating endpoints for a URL.`);
  }

  const verbs = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE'];
  if (options.url && options.verb === undefined) {
    throw new Error(___`Please provide a valid value for 'verb'.`);
  }
  // Invalid value provided
  if (options.url && !verbs.includes(options.verb.toUpperCase())) {
    throw new Error(___`'${options.verb}' is an invalid value for option 'verb'.`);
  }
}

function determineEndpointDirectoryName(options) {
  if (options.swagger) {
    if (options.swaggerDocumentConfigs.basePath && options.swaggerDocumentConfigs.basePath.replace(/\//g, '')) {
      return dashCase(options.swaggerDocumentConfigs.basePath);
    }

    return dashCase(options.swaggerDocumentConfigs.host);
  }

  if (options.url) {
    const url = new URL(`${options.url}`);
    // Check if specified url include a pathname
    if (url.pathname.replace(/\//g, '')) {
      // use pathname as directoryName if so
      return dashCase(url.pathname);
    }

    // use URL's host as directoryName if there is no pathname in provided URL
    return dashCase(url.host);
  }
}

async function createEndpoint(appName, options) {
  await validateEndpointOptions(options);
  await verifyApp(appName, options.appDir);
  validatePluginFolderExists(options.appDir, ENDPOINT_DEFAULT_PATH);

  if (options.swagger) {
    await createEndpointsFromSwagger(appName, options);
  } else if (options.url) {
    await createEndpointFromUrl(appName, options);
  }
}

async function createEndpointsFromSwagger(appName, options) {
  options.swaggerDocumentConfigs = await processSwaggerInput(options.swagger);

  // If user specified endpoints, validate they exist in Swagger API doc and filter out the non-selected endpoints
  const swaggerEndpointsList = options.endpoints
    ? filterEndpoints(options.swaggerDocumentConfigs.swaggerApiMapping, options.endpoints)
    : options.swaggerDocumentConfigs.swaggerApiMapping;

  if (options.directoryName === undefined) {
    options.formattedDirectoryName = determineEndpointDirectoryName(options);
  } else {
    validatePluginName(options.directoryName);
    options.formattedDirectoryName = options.directoryName;
  }

  options.directoryNamePath = options.formattedDirectoryName;
  options.endpointFactoryName = `create${capitalizeFirstLetter(
    standardizePluginName(options.formattedDirectoryName)
  )}EndpointFactory`;
  options.endpointFactoryNamePath = `${dashCase(options.formattedDirectoryName)}-endpoint`;

  // Verify that endpoint factory folder exists
  await fse.ensureDir(path.resolve(options.appDir, ENDPOINT_FACTORY_PATH));

  // Check if endpoint factory with same name already exists
  if (pluginExists(options.appDir, ENDPOINT_FACTORY_PATH, `${options.endpointFactoryNamePath}.js`)) {
    throw new Error(
      ___`Endpoint Factory "${options.endpointFactoryNamePath}", already exists in path ${path.resolve(
        options.appDir,
        ENDPOINT_FACTORY_PATH
      )}. Please provide a different name using --directoryName.`
    );
  }

  // Check if endpoint plugin with same name already exists
  if (pluginExists(options.appDir, ENDPOINT_DEFAULT_PATH, options.directoryNamePath)) {
    throw new Error(
      ___`Endpoint Plugin "${options.formattedDirectoryName}", already exists in path ${path.resolve(
        options.appDir,
        ENDPOINT_DEFAULT_PATH
      )}. Please provide a different name using --directoryName.`
    );
  }

  addOriginToAppConfig(
    options.formattedDirectoryName,
    options.swaggerDocumentConfigs.host,
    options.swaggerDocumentConfigs.apiCatalogHost,
    options.appDir
  );

  // Log information about the endpoint being created
  logger.info(___`Endpoint name: ${options.formattedDirectoryName}.`);
  logger.info(___`\t Path to Endpoint Factory files: ${ENDPOINT_FACTORY_PATH}.`);
  logger.info(___`\t Path to Endpoint Plugin files: ${ENDPOINT_DEFAULT_PATH}.`);

  // Endpoint Factory

  // Define template path for Endpoint factory template
  const endpointFactoryTemplatesDirectory = path.resolve(path.relative('.', __dirname), 'template-files', 'factory');
  // Generate files content to be written for endpoint factory
  const filesToWrite = generateTemplateFiles(endpointFactoryTemplatesDirectory, options);

  // Define destination for new endpoint factory
  const newEndpointFactoryPath = path.join(options.appDir, ENDPOINT_FACTORY_PATH);
  logger.info(___`Creating a new Endpoint Factory at ${newEndpointFactoryPath}.`);

  // Write the files to the specified destination
  await writeTemplateFiles(newEndpointFactoryPath, filesToWrite);

  // Endpoint Plugins

  // Read package name from package.json at app level
  options.packageName = readAppName(options.appDir);

  // Define template path for Endpoint plugins template
  const endpointPluginsTemplatesDirectory = path.resolve(
    path.relative('.', __dirname),
    'template-files',
    'endpoint-plugin'
  );

  await writeEndpointPlugins(options, swaggerEndpointsList, endpointPluginsTemplatesDirectory);
  logger.info(
    ___`Created ${Object.keys(swaggerEndpointsList).length} endpoint plugins at ${path.join(
      options.appDir,
      ENDPOINT_DEFAULT_PATH,
      options.directoryNamePath
    )}.`
  );

  // Update the exports
  await updateEndpointExports(options);
}

async function createEndpointFromUrl(appName, options) {
  if (options.directoryName === undefined) {
    options.directoryName = determineEndpointDirectoryName(options);
  } else {
    validatePluginName(options.directoryName);
  }
  options.url = splitURL(options.url);

  // Read package name from package.json at app level
  options.packageName = readAppName(options.appDir);

  // Check whether the endpoint folder exist, if not create one.
  if (pluginExists(options.appDir, ENDPOINT_DEFAULT_PATH, options.directoryName)) {
    throw new Error(
      ___`Endpoint "${standardizePluginName(options.directoryName)}", already exists in path ${path.resolve(
        options.appDir,
        ENDPOINT_DEFAULT_PATH
      )}. Please provide a different name using --directoryName.`
    );
  }
  logger.info(___`Endpoint name: ${standardizePluginName(options.directoryName)}`);
  logger.info(___`\t Path to Endpoint Plugins files: ${ENDPOINT_DEFAULT_PATH}.`);

  // Generate files content to be written

  const singleEndpoinTemplatesDirectory = path.resolve(
    path.relative('.', __dirname),
    'template-files',
    'endpoint-plugin'
  );

  const filesToWrite = generateTemplateFiles(singleEndpoinTemplatesDirectory, options);

  // Define destination for new endpoint
  const installPath = path.join(options.appDir, ENDPOINT_DEFAULT_PATH);
  const newEndpointFolder = path.join(installPath, options.directoryName);
  logger.info(___`Creating new Endpoint Plugin folder ${newEndpointFolder}.`);

  // Write the files to the specified destination
  await writeTemplateFiles(newEndpointFolder, filesToWrite);
  await updateEndpointExports(options);
}
module.exports = {createEndpoint};
