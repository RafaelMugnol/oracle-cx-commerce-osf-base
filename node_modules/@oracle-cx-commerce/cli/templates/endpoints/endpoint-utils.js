/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const fetch = require('@oracle-cx-commerce/http-client');
const fse = require('fs-extra');
const path = require('path');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const {camelCase} = require('@oracle-cx-commerce/tools-util/strings');

const transformApiCatalog = require('./transform-catalog-es5');

/**
 * Determine if swagger document provided is remote url or local file
 *
 * @param      {Object}  swagger  CLI input provided for parameter --swagger
 * @return     {Object}
 */
function determineSwaggerInputType(swagger) {
  try {
    splitURL(swagger);
    logger.verbose(___`Successfully proccesed input URL: ${swagger}`);

    return 'url';
  } catch (err) {
    logger.verbose(___`${swagger} is not a URL, attempting to process as local file.`);

    return 'localFile';
  }
}

/**
 * Fetch the apiCatalog json object from a remote url
 *
 * @param      {Object}   swagger     Contains the path to the swagger document
 * @return     {Object}   content of the swagger file
 */
async function fetchSwaggerDocumentFromURL(swaggerUrl) {
  try {
    const response = await fetch(`${swaggerUrl}`);
    if (!response.ok) {
      throw new Error(___`Failed to get all paths from: ${swaggerUrl} \n ${response.status} \n ${response.statusText}`);
    }

    const swaggerDocData = await response.json();

    return swaggerDocData;
  } catch (error) {
    throw new Error(
      ___`'create-endpoints' failed to fetch swagger document from remote URL ${swaggerUrl}. \n ${error}`
    );
  }
}

/**
 * Read and parse a local Swagger Document
 *
 * @param      {Object}   pathToSwaggerFile     Path to swagger document to parse
 * @return     {Object}                         Content of the swagger file
 */
function readSwaggerDocumentFromLocalFile(swaggerFile) {
  try {
    const swaggerFilePath = path.resolve(swaggerFile);
    const swaggerFileContent = fse.readFileSync(swaggerFilePath, 'utf-8');
    const swaggerFileExtension = path.extname(swaggerFilePath);

    if (swaggerFileExtension !== '.json') {
      throw new Error(
        ___`Unsupported swagger file format ${swaggerFileExtension} for file ${swaggerFilePath}. Supported formats: json.`
      );
    }

    const swaggerDocParsedData = JSON.parse(swaggerFileContent);

    return swaggerDocParsedData;
  } catch (error) {
    throw new Error(___`'create-endpoints' failed to read local swagger document ${swaggerFile}. \n ${error}`);
  }
}

/**
 * Parent function to read the swagger document from remote url or local file
 * @param {String} swagger              Original user input from the cli
 * @param {String} swaggerDocType       URL | LocalFile
 */
async function fetchSwaggerDocument(swagger, swaggerDocType) {
  let swaggerDocumentData;
  if (swaggerDocType === 'url') {
    swaggerDocumentData = await fetchSwaggerDocumentFromURL(swagger);
  }

  if (swaggerDocType === 'localFile') {
    swaggerDocumentData = readSwaggerDocumentFromLocalFile(swagger);
  }

  return swaggerDocumentData;
}

/**
 * Parse host, basePath and schemes from the swagger document.
 * Modifies swaggerDocumentData.
 * @param {Object} swaggerDocumentData
 * @param {String} swaggerDocType
 * @param {String} originalSwaggerInput
 */
function parseOAS2SwaggerDocument(swaggerDocumentData, swaggerDocType, originalSwaggerInput) {
  if (!swaggerDocumentData.host) {
    if (swaggerDocType === 'localFile') {
      throw new Error(___`Missing key 'host' in Swagger Document.`);
    } else {
      //  According to https://swagger.io/specification/v2/ :
      // If the host is not included, the host serving the documentation is to be used.
      swaggerDocumentData.host = new URL(originalSwaggerInput).origin;
    }
  }

  if (!swaggerDocumentData.basePath) {
    // According to https://swagger.io/specification/v2/ :
    // If it (basePath) is not included, the API is served directly under the host. The value MUST start with a leading slash (/).
    swaggerDocumentData.basePath = '';
  }

  if (!swaggerDocumentData.host.startsWith('https://') && !swaggerDocumentData.host.startsWith('http://')) {
    // host does not contains http or https, check if schemes key exists in swagger document
    if (swaggerDocumentData.schemes) {
      // if schema is not found in host, take the first element from 'schemes' array of the swagger document
      swaggerDocumentData.host = `${swaggerDocumentData.schemes[0]}://${swaggerDocumentData.host}`;
    } else {
      if (swaggerDocType === 'localFile') {
        throw new Error(___`Missing key 'schemes' in Swagger Document.`);
      }
      swaggerDocumentData.host = `${new URL(originalSwaggerInput).protocol}://${swaggerDocumentData.host}`;
    }
  }
}

/**
 * Parse the first entry in the servers list from the swagger document to a host and a basePath
 * Modifies swaggerDocumentData.
 * @param {Object} swaggerDocumentData
 * @param {String} swaggerDocType
 * @param {String} originalSwaggerInput
 */
function parseOAS3SwaggerDocument(swaggerDocumentData, swaggerDocType, originalSwaggerInput) {
  if (!swaggerDocumentData.servers) {
    if (swaggerDocType === 'localFile') {
      throw new Error(___`Missing key 'servers' in Swagger Document.`);
    } else {
      //  According to https://swagger.io/specification/ :
      // If the host is not included, the host serving the documentation is to be used.
      swaggerDocumentData.host = new URL(originalSwaggerInput).href;
    }
  } else {
    // Take first URL entry from the swagger document
    swaggerDocumentData.host = swaggerDocumentData.servers[0].url;
  }
}

/**
 * Verifies that all relevant fields are present in the swagger file, transforms the API catalog to
 * endpoint mapping.
 * @param {Object} swaggerDocumentData   Content of the parsed swagger document
 * @param {String} swaggerDocType         URL | Local file
 * @param {String} originalSwaggerInput        Original user input from the cli
 */
function parseSwaggerDocument(swaggerDocumentData, swaggerDocType, originalSwaggerInput) {
  if (!swaggerDocumentData.paths) {
    throw new Error(___`Missing key 'paths' in Swagger Document.`);
  }

  if (swaggerDocumentData.swagger) {
    // OAS 2
    parseOAS2SwaggerDocument(swaggerDocumentData, swaggerDocType, originalSwaggerInput);
  } else if (swaggerDocumentData.openapi) {
    // OAS 3
    parseOAS3SwaggerDocument(swaggerDocumentData, swaggerDocType, originalSwaggerInput);
  } else {
    throw new Error(___`Unable to determine Swagger Document OAS Version.`);
  }

  const swaggerApiMapping = transformApiCatalog({}, swaggerDocumentData);
  const apiCatalogPath = swaggerDocType === 'url' ? new URL(originalSwaggerInput).pathname : '';
  // In case the URL which hosts the swagger file is not the same as the host of the endpoints
  swaggerDocumentData.apiCatalogHost =
    swaggerDocType === 'url' && swaggerDocumentData.host !== new URL(originalSwaggerInput).origin
      ? new URL(originalSwaggerInput).origin
      : '';

  return {
    apiCatalogHost: swaggerDocumentData.apiCatalogHost,
    host: swaggerDocumentData.host,
    basePath: swaggerDocumentData.basePath,
    swaggerApiMapping,
    apiCatalogPath
  };
}

/**
 * Based on the user input for --swagger:
 * Determine if the swagger document is a local file or remote url.
 * Fetch or Read the swagger file based on the document type.
 * Parse the swagger file and transform the API catalog into endpoint mapping.
 * @param {String} originalSwaggerInput Original user input from the cli
 * @return {Object}                     An object containing the following fields describing the swagger document:
 *                                      swagger type, content of swagger file, host, basePath, api mapping and api catalog path
 */
async function processSwaggerInput(originalSwaggerInput) {
  const swaggerDocumentConfigs = {
    type: null,
    content: null
  };
  // Determine if swagger parameter is local file or web address
  swaggerDocumentConfigs.type = determineSwaggerInputType(originalSwaggerInput);
  swaggerDocumentConfigs.content = await fetchSwaggerDocument(originalSwaggerInput, swaggerDocumentConfigs.type);

  const swaggerParsedContent = parseSwaggerDocument(
    swaggerDocumentConfigs.content,
    swaggerDocumentConfigs.type,
    originalSwaggerInput
  );

  return {...swaggerDocumentConfigs, ...swaggerParsedContent};
}

/**
 * Splits a URL into origin and path.
 * @param {String} fullUrl
 */
function splitURL(fullUrl) {
  const url = new URL(fullUrl);

  if (!url.host) throw new Error(___`${fullUrl} is not a valid URL.`);

  return {
    fullUrl,
    url: url.origin,
    path: url.pathname
  };
}

/**
 * Prints all endpoints to the console
 * @param {Array} allEndpoints
 */
function listOperationIds(allEndpoints) {
  const operationIds = Object.keys(allEndpoints).map(endpoint => allEndpoints[endpoint].operationId);

  logger.info(`There are ${operationIds.length} total endpoints found:`);
  operationIds.forEach(endpointId => {
    logger.info(
      ___`
  EndpointName: ${camelCase(allEndpoints[endpointId].operationId)}
    operationId: ${allEndpoints[endpointId].operationId}
    Description: ${allEndpoints[endpointId].description}
    HTTP Method: ${allEndpoints[endpointId].method}
    EndpointPath: ${allEndpoints[endpointId].url}\n`
    );
  });
}

/**
 * Check if specified endpoints exits in Swagger API document
 * @param {Array} allEndpoints
 * @param {Array} endpointsToCreate
 */
function validateEndpointExists(allEndpoints, endpointsToCreate, swagger) {
  const operationIds = Object.keys(allEndpoints).map(endpoint => allEndpoints[endpoint].operationId);
  endpointsToCreate.forEach(endpoint => {
    if (!operationIds.includes(endpoint)) {
      throw new Error(___`Endpoint ${endpoint} was not found in Swagger document ${swagger}`);
    }
  });
}

/**
 * Filter out operationIds not specified by the user
 * @param {Array} allEndpoints
 * @param {Array} endpointsToCreate
 */
function filterEndpoints(allEndpoints, endpointsToCreate) {
  endpointsToCreate = endpointsToCreate.split(',').map(endpoint => endpoint.trim());
  validateEndpointExists(allEndpoints, endpointsToCreate);

  const selectedEndpoints = {};
  Object.keys(allEndpoints).forEach(endpoint => {
    if (endpointsToCreate.includes(allEndpoints[endpoint].operationId)) {
      selectedEndpoints[endpoint] = allEndpoints[endpoint];
    }
  });

  return selectedEndpoints;
}

/**
 * Assumption: the app folder is already validated to exist
 * Goal: create or update {appName}/config/app-config/index.js with the new endpoint origin/catalog origin
 * @param {*} apiName     Name of the collection of endpoints
 * @param {*} apiOrigin
 * @param {*} apiCatalogOrigin
 * @param {*} appDir
 */
function addOriginToAppConfig(apiName, apiOrigin, apiCatalogOrigin, appDir) {
  let appConfig = {};

  const pathToAppConfig = path.resolve(appDir, path.join('config', 'app-config', 'index.js'));
  // if app-config exists, read the contents. If not, use an empty object.
  if (fse.existsSync(pathToAppConfig)) {
    appConfig = require(pathToAppConfig);
  }

  if (appConfig.endpointOrigins) {
    if (typeof appConfig.endpointOrigins !== 'object') {
      throw new Error(___`Error saving endpoint origins in app-config/index.js, endpointOrigin must be an object.`);
    }
    if (appConfig.endpointOrigins[apiName]) {
      throw new Error(
        ___`Error saving endpoint origins in app-config/index.js, "${apiName}" object already exists in endpointOrigins of app-config.`
      );
    }
  } else {
    // create an empty endpointOrigins object to populate later on
    appConfig.endpointOrigins = {};
  }

  // Add new entry in the endpoint origins object
  appConfig.endpointOrigins[apiName] = {
    origin: apiOrigin,
    ...(apiCatalogOrigin && {catalogOrigin: apiCatalogOrigin})
  };

  // template app-config and populate with updated config
  const template = `module.exports = ${JSON.stringify(appConfig, null, 2)};`;

  fse.outputFileSync(pathToAppConfig, template);

  logger.info(___`Added endpoint origins to application configuration at ${pathToAppConfig}`);
}
module.exports = {
  splitURL,
  validateEndpointExists,
  listOperationIds,
  filterEndpoints,
  processSwaggerInput,
  addOriginToAppConfig
};
