/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
const {standardizePluginName} = require('@oracle-cx-commerce/cli/templates/utils');

function swaggerEndpointImport(endpointFactoryName, endpointFactoryNamePath) {
  return `import {getBodyAsJson} from '@oracle-cx-commerce/endpoints/factory';
import {populateError} from '@oracle-cx-commerce/endpoints/utils';
import {${endpointFactoryName}} from '../../../../core/wapi/${endpointFactoryNamePath}';
`;
}

function endpointImport() {
  return `import {getBodyAsJson} from '@oracle-cx-commerce/endpoints/factory';
import {populateError} from '@oracle-cx-commerce/endpoints/utils';
`;
}
function swaggerProcessInputRequireParameters(operationId, requiredParameters) {
  let parametersDestructure = '';
  let parametersAssertStatements = '';

  for (const parameter of requiredParameters) {
    parametersDestructure += `  const {${parameter.name}} = payload;\n`;
    parametersAssertStatements += `  console.assert(payload.${parameter.name} !== undefined, '${operationId} requires an ${parameter.name}.');\n`;
  }

  return `${parametersDestructure}${parametersAssertStatements}`;
}

function swaggerProcessInputExport(operationId, requiredParameters) {
  return `
export const processInput = payload => {
${swaggerProcessInputRequireParameters(operationId, requiredParameters)}
  return payload;
};
`;
}

function swaggerProecessOutputExport() {
  return `
export const processOutput = async response => {
  const json = await getBodyAsJson(response);

  return response.ok
    ? {
        json
      }
    : populateError(response, json);
};
`;
}

function swaggerEndpointExport(operationId, customEndpointFactoryName) {
  return `
export default ${customEndpointFactoryName}('${operationId}', {
  processInput,
  processOutput
});
`;
}

function endpointBody(fullUrl, directoryName, verb) {
  return `
/** This endpoint uses a public API for requesting contents from the url */
const url = '${fullUrl}';

/**
 * Convert response data into an object to be merged into the application state.
 */
const processOutput = json => ({
  myRepository: {
    myTable: {
      myProperty: json
    }
  }
});

/**
 * Return an object that implements the endpoint adapter interface.
 */
const ${standardizePluginName(directoryName)} = {
  /**
   * Return a Fetch API Request object to be used for invoking the endpoint.
   *
   * @param payload Optional payload to be included in the request
   * @param state The current application state
   * @return Request object for invoking the endpoint via Fetch API
   */
  async getRequest() {
    return new Request(url, {method: '${verb}'});
  },

  /**
   * Return a Fetch API Response object containing data from the endpoint.
   *
   * @param response The Response object returned by the fetch call
   * @param state The current application state
   * @param payload Optional payload that was included in the request
   * @return Response object, augmented with an async getJson function to return
   * an object to be merged into the application state
   */
  getResponse(response) {
    let json;
    response.getJson = async () => {
      if (json === undefined) {
        json = await getBodyAsJson(response);

        return response.ok ? processOutput(json) : populateError(response, json);
      }

      return json;
    };

    return response;
  }
};

export default ${standardizePluginName(directoryName)};
`;
}

module.exports = options => {
  let content = '';

  if (options.swagger) {
    content += swaggerEndpointImport(options.endpointFactoryName, options.endpointFactoryNamePath);
    content += swaggerProcessInputExport(options.operationId, options.requiredParameters);
    content += swaggerProecessOutputExport();
    content += swaggerEndpointExport(options.operationId, options.endpointFactoryName);
  } else {
    content += endpointImport();
    content += endpointBody(options.url.fullUrl, options.directoryName, options.verb);
  }

  return [
    {
      fileName: 'index.js',
      relativePath: ``,
      content
    }
  ];
};
