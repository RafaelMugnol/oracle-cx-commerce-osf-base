/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
const path = require('path');
const fse = require('fs-extra');
const createTempDir = require('tmp-promise').dir;

const {mockConsole} = require('@oracle-cx-commerce/test/utils/console');

const {
  WIDGET_DEFAULT_PATH,
  getPathToWidgetIndex,
  getPathToWidgetMeta,
  discoverTemplateFiles
} = require('@oracle-cx-commerce/cli/templates/utils');
const {
  validateOutputFiles,
  createTestApp,
  validateImports
} = require('@oracle-cx-commerce/cli/templates/__test__/asset-creation-tests-utils');

const {
  readLocaleFile,
  templateLocaleKeys,
  wrapLocaleWithLocaleTag,
  localesIndexContent,
  isLocaleImportPresent,
  isLocaleExportsPresent,
  updateAppLocales
} = require('@oracle-cx-commerce/cli/templates/widget/app-wide-locale-utils');
const {createWidget} = require('@oracle-cx-commerce/cli/templates');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

const blankStoreOptions = {
  appName: 'blank-store',
  userName: 'dev',
  name: 'ExampleWidget',
  appDir: 'packages/apps/blank-store'
};

const expectedBaseTemplateWidgetFiles = path.resolve(
  path.relative('.', __dirname),
  'expected-files',
  'create-widget-example-files',
  'example-widget-base-template'
);

const expectedCurrencyTemplateWidgetFiles = path.resolve(
  path.relative('.', __dirname),
  'expected-files',
  'create-widget-example-files',
  'example-widget-currency-selector-template'
);

describe('create-widget:all  -  all the tests that will invoke create-widget with different options', () => {
  let testAppPath, tempAppDir;
  beforeAll(async () => {
    tempAppDir = await createTestApp(blankStoreOptions.appName);
    expect(tempAppDir).toBeDefined();
    testAppPath = path.resolve(tempAppDir.path, blankStoreOptions.appName);
  });

  afterAll(async () => {
    await tempAppDir.cleanup();
  });

  test('create-widget:list-template-files - check that all widget template files are present', () => {
    const widgetTemplatesDirectory = path.resolve(path.relative('.', __dirname), '..', 'widget', 'template-files');
    const expectedFileList = [
      path.join('__test__', 'widget-name-widget.spec.js'),
      'config.js',
      'index.js',
      'meta.js',
      'readme.js',
      'styles.js'
    ];
    // only pass the path
    expect(discoverTemplateFiles(widgetTemplatesDirectory).sort()).toMatchObject(expectedFileList.sort());
  });

  test('create-widget:create-an-already-existing-widget-blank-store - create a widget that already existing in an specific app', async () => {
    const options = {...blankStoreOptions, name: 'HelloWorld'};
    await expect(createWidget(options.appName, options)).rejects.toThrow(
      `Component "${dashCase(options.name)}", already exists in path ${path.resolve(
        options.appDir,
        WIDGET_DEFAULT_PATH
      )}.`
    );
  });

  test('create-widget:create-an-already-existing-widget-test-app - create a widget in already existing in the test app', async () => {
    const options = {...blankStoreOptions, appDir: testAppPath, name: 'HelloWorld'};

    await expect(createWidget(options.appName, options)).rejects.toThrow(
      `Component "${dashCase(options.name)}", already exists in path ${path.resolve(
        options.appDir,
        WIDGET_DEFAULT_PATH
      )}.`
    );
  });

  test('create-widget:create-a-widget-in-test-app-folder - create a widget in the test app check widget folder exist', async () => {
    const options = {...blankStoreOptions, appDir: testAppPath, name: 'firstExampleWidget'};
    await expect(createWidget(options.appName, options)).resolves.not.toThrow();
    const newWidgetPath = path.resolve(options.appDir, WIDGET_DEFAULT_PATH, dashCase(options.name));
    console.log(newWidgetPath);
    expect(fse.existsSync(newWidgetPath)).toBeTruthy();
  });

  test('create-widget:check-for-imports-in-test-app-imports - create a widget in the test app and check if imports exist', async () => {
    const options = {...blankStoreOptions, appDir: testAppPath, name: 'secondExampleWidget'};
    await expect(createWidget(options.appName, options)).resolves.not.toThrow();
    const testAppWidgetIndexPath = getPathToWidgetIndex(options.appDir);
    const testAppWidgetMetaPath = getPathToWidgetMeta(options.appDir);
    validateImports(testAppWidgetIndexPath, `${options.name}`);
    validateImports(testAppWidgetMetaPath, `${options.name}`);
  });

  test('create-widget:check-widget-base-template-content - create a widget in the test app and check the content', async () => {
    const options = {...blankStoreOptions, appDir: testAppPath};
    await expect(createWidget(options.appName, options)).resolves.not.toThrow();
    const newWidgetPath = path.resolve(options.appDir, WIDGET_DEFAULT_PATH, dashCase(options.name));
    validateOutputFiles(expectedBaseTemplateWidgetFiles, newWidgetPath);
  });

  test('create-widget:check-widget-currency-selector-template-content - create a widget in the test app and check the content', async () => {
    const options = {
      ...blankStoreOptions,
      appDir: testAppPath,
      name: 'CurrencySelectorExample',
      template: 'CurrencySelector'
    };
    await expect(createWidget(options.appName, options)).resolves.not.toThrow();
    const newWidgetPath = path.resolve(options.appDir, WIDGET_DEFAULT_PATH, dashCase(options.name));
    validateOutputFiles(expectedCurrencyTemplateWidgetFiles, newWidgetPath);
  });

  test('create-widget:check-create-widget-aborts-for-locales-errors - attemps to create a widget but fails due to locale error', async () => {
    const options = {
      ...blankStoreOptions,
      appDir: testAppPath,
      name: 'failToCreateWidget'
    };

    const pathToWidgetDirectory = path.resolve(path.join(options.appDir, 'src', 'plugins', 'components', options.name));
    // making sure the widget files are not already there
    expect(fse.existsSync(pathToWidgetDirectory)).toBeFalsy();

    const pathToLocaleFile = path.resolve(path.join(options.appDir, 'src', 'core', 'ui', 'locales', 'en.json')); // I elected en.json since blank-store should always have en locale
    fse.writeFileSync(pathToLocaleFile, 'a non-json format to break create-widget readLocaleFile utility function');
    expect(fse.existsSync(pathToLocaleFile)).toBeTruthy();

    await expect(createWidget(options.appName, options)).rejects.toThrow(
      `Failed to parse locale file ${pathToLocaleFile} due to the file containing an invalid JSON. Please fix ${pathToLocaleFile} to be a valid JSON file and rerun the command.`
    );
    // making sure the widget files were not created due to locale file issue
    expect(fse.existsSync(pathToWidgetDirectory)).toBeFalsy();
  });
});

describe('create-widget-locale-utils:all  -  all the tests that will invoke create-widget utils for updating locales', () => {
  let workDir, tempDir;
  beforeAll(async () => {
    tempDir = await createTempDir({
      unsafeCleanup: true,
      // dir: path.resolve('.'),
      prefix: 'creation-tools-temp-dir'
    });

    workDir = tempDir.path;
  });

  afterAll(async () => {
    await tempDir.cleanup();
  });

  test('create-widget-locale-utils:wrapLocaleWithLocaleTag - wrap sample resources with locale tag', () => {
    const sampleLocale = `a sample locale`;
    expect(wrapLocaleWithLocaleTag(sampleLocale, 'en')).toEqual(`a sample locale`);
    expect(wrapLocaleWithLocaleTag(sampleLocale, 'pt-BR')).toEqual(`[pt-BR]a sample locale[pt-BR]`);
  });

  test('create-widget-locale-utils:localesIndexContent - compare content of newly written src/core/ui/index.js file', () => {
    const appPackageName = '@acme/my-app';

    let localeOptions = ['en'];
    let templatedFile = localesIndexContent(localeOptions, appPackageName);

    let expectedTemplate = `/* eslint-env node */
/* eslint-disable camelcase */

// NOTICE: For locales that include a hyphen, such as pt-BR, variable names must use an underscore instead of the hyphen. e.g.:
// const pt_BR = require('${appPackageName}/src/core/ui/locales/pt-BR.json');

/**
 * NOTICE: The import statements for app locales must include full (not relative) path to each locale file.
 */
const en = require('${appPackageName}/src/core/ui/locales/en.json');

export {en};
`;

    expect(templatedFile).toEqual(expectedTemplate);

    localeOptions = ['en', 'de', 'pt-BR'];
    templatedFile = localesIndexContent(localeOptions, appPackageName);

    expectedTemplate = `/* eslint-env node */
/* eslint-disable camelcase */

// NOTICE: For locales that include a hyphen, such as pt-BR, variable names must use an underscore instead of the hyphen. e.g.:
// const pt_BR = require('${appPackageName}/src/core/ui/locales/pt-BR.json');

/**
 * NOTICE: The import statements for app locales must include full (not relative) path to each locale file.
 */
const en = require('${appPackageName}/src/core/ui/locales/en.json');
const de = require('${appPackageName}/src/core/ui/locales/de.json');
const pt_BR = require('${appPackageName}/src/core/ui/locales/pt-BR.json');

export {en, de, pt_BR};
`;

    expect(templatedFile).toEqual(expectedTemplate);
  });

  test('create-widget-locale-utils:isLocaleImportPresent - check log messages are printed correctly when locale imports are present or missing', async () => {
    const appPackageName = '@acme/my-app';
    const pathToLocaleIndex = path.resolve(path.join(workDir, 'sample-locale-index.js'));
    fse.writeFileSync(pathToLocaleIndex, 'filler text witout any locale imports');

    await mockConsole(['log', 'warn'], async () => {
      isLocaleImportPresent(pathToLocaleIndex, ['en'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(1);
      expect(console.log.mock.calls[0][0]).toMatch(
        `Detected a missing import for locale 'en', please add the following import statement:\nconst en = require('${appPackageName}/src/core/ui/locales/en.json');\n to ${pathToLocaleIndex}.`
      );
    });

    await mockConsole(['log', 'warn'], async () => {
      isLocaleImportPresent(pathToLocaleIndex, ['pt-BR'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(1);
      expect(console.log.mock.calls[0][0]).toMatch(
        `Detected a missing import for locale 'pt-BR', please add the following import statement:\nconst pt_BR = require('${appPackageName}/src/core/ui/locales/pt-BR.json');\n to ${pathToLocaleIndex}.`
      );
    });

    await mockConsole(['log', 'warn'], async () => {
      isLocaleImportPresent(pathToLocaleIndex, ['en', 'pt-BR'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(2);
      expect(console.log.mock.calls[0][0]).toMatch(
        `Detected a missing import for locale 'en', please add the following import statement:\nconst en = require('${appPackageName}/src/core/ui/locales/en.json');\n to ${pathToLocaleIndex}.`
      );
      expect(console.log.mock.calls[1][0]).toMatch(
        `Detected a missing import for locale 'pt-BR', please add the following import statement:\nconst pt_BR = require('${appPackageName}/src/core/ui/locales/pt-BR.json');\n to ${pathToLocaleIndex}.`
      );
    });

    // expecting no cli warn message due to present en locale import
    fse.writeFileSync(pathToLocaleIndex, `const en = require('${appPackageName}/src/core/ui/locales/en.json');`);
    await mockConsole(['log', 'warn'], async () => {
      isLocaleImportPresent(pathToLocaleIndex, ['en'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(0);
    });

    // expecting no cli warn message due to present en and pt-BR locale import
    fse.writeFileSync(
      pathToLocaleIndex,
      `const en = require('${appPackageName}/src/core/ui/locales/en.json');\nconst pt_BR = require('${appPackageName}/src/core/ui/locales/pt-BR.json');`
    );
    await mockConsole(['log', 'warn'], async () => {
      isLocaleImportPresent(pathToLocaleIndex, ['en', 'pt-BR'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(0);
    });
  });

  test('create-widget-locale-utils:isLocaleExportsPresent - check log messages are printed correctly when locale exports are present or missing', async () => {
    const appPackageName = '@acme/my-app';
    const pathToLocaleIndex = path.resolve(path.join(workDir, 'sample-locale-index.js'));
    fse.writeFileSync(pathToLocaleIndex, 'filler text witout any locale exports');

    await mockConsole(['log', 'warn'], async () => {
      isLocaleExportsPresent(pathToLocaleIndex, ['en']);
      expect(console.log).toHaveBeenCalledTimes(1);
      expect(console.log.mock.calls[0][0]).toMatch(
        `Missing locale "en" export in ${pathToLocaleIndex}. Please add an export for "en"`
      );
    });

    await mockConsole(['log', 'warn'], async () => {
      isLocaleExportsPresent(pathToLocaleIndex, ['pt-BR'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(1);
      expect(console.log.mock.calls[0][0]).toMatch(
        `Missing locale "pt-BR" export in ${pathToLocaleIndex}. Please add an export for "pt_BR"`
      );
    });

    await mockConsole(['log', 'warn'], async () => {
      isLocaleExportsPresent(pathToLocaleIndex, ['en', 'pt-BR'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(2);
      expect(console.log.mock.calls[0][0]).toMatch(
        `Missing locale "en" export in ${pathToLocaleIndex}. Please add an export for "en"`
      );
      expect(console.log.mock.calls[1][0]).toMatch(
        `Missing locale "pt-BR" export in ${pathToLocaleIndex}. Please add an export for "pt_BR"`
      );
    });

    // expecting no cli warn message due to present en locale import
    fse.writeFileSync(pathToLocaleIndex, `export {en}`);
    await mockConsole(['log', 'warn'], async () => {
      isLocaleExportsPresent(pathToLocaleIndex, ['en'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(0);
    });

    // expecting no cli warn message due to present pt-BR locale import
    fse.writeFileSync(pathToLocaleIndex, `export {pt_BR}`);
    await mockConsole(['log', 'warn'], async () => {
      isLocaleExportsPresent(pathToLocaleIndex, ['pt-BR'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(0);
    });

    // expecting no cli warn message due to present en and pt-BR locale import
    fse.writeFileSync(pathToLocaleIndex, `export {en, pt_BR}`);
    await mockConsole(['log', 'warn'], async () => {
      isLocaleExportsPresent(pathToLocaleIndex, ['en', 'pt-BR'], appPackageName);
      expect(console.log).toHaveBeenCalledTimes(0);
    });
  });

  describe('create-widget-locale:all  -  all the tests that will invoke create-widget utils for updating locales', () => {
    let subWorkDir;
    beforeEach(() => {
      // creating a sub-directory under the tmp directory to simulate running the `yarn occ create-widget` command
      subWorkDir = path.join(workDir, 'update-locale-utils-sub-folder');
      fse.mkdirSync(subWorkDir);
    });

    afterEach(() => {
      // removing the sub-directory to create a 'clean' workspace for the next test
      fse.rmSync(subWorkDir, {recursive: true, force: true});
    });

    test('create-widget-locale-utils:updateAppLocales - missing src/core/ui/locales/index.js', async () => {
      const appPackageName = '@acme/my-app';
      const pathToLocaleIndex = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'index.js'));
      // making sure the above files don't exist to verify the use case
      expect(fse.existsSync(pathToLocaleIndex)).toBeFalsy();

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, [], appPackageName); // subWorkDir is appDir
        expect(console.log).toHaveBeenCalledTimes(1); // one log message to create index.js
        expect(console.log.mock.calls[0][0]).toMatch(`Writing an app-wide locale file ${pathToLocaleIndex}`);
      });
      expect(fse.existsSync(pathToLocaleIndex)).toBeTruthy();
    });

    test('create-widget-locale-utils:updateAppLocales - present src/core/ui/locales/index.js', async () => {
      const appPackageName = '@acme/my-app';
      const pathToLocaleIndex = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'index.js'));

      // making sure the above files exist to verify the use case
      expect(fse.existsSync(subWorkDir)).toBeTruthy();
      expect(fse.existsSync(pathToLocaleIndex)).toBeFalsy();

      fse.outputFileSync(pathToLocaleIndex, 'filler text');
      expect(fse.existsSync(pathToLocaleIndex)).toBeTruthy();

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, [], appPackageName); // subWorkDir is appDir
        expect(console.log).toHaveBeenCalledTimes(0); // no logs since no new files (index.js or locales) are created or updated
      });

      expect(fse.existsSync(pathToLocaleIndex)).toBeTruthy();
    });

    test('create-widget-locale-utils:updateAppLocales - missing locale file en', async () => {
      const appPackageName = '@acme/my-app';

      const pathToLocaleEnJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'en.json'));

      // making sure the above files don't exist to verify the use case
      expect(fse.existsSync(pathToLocaleEnJson)).toBeFalsy();

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, ['en'], appPackageName); // subWorkDir is appDir
        expect(console.log).toHaveBeenCalledTimes(2); // one log message to create index.js and one for en.json
        expect(console.log.mock.calls[1][0]).toMatch(
          `Writing a new locale file ${pathToLocaleEnJson} with default locale entries.`
        );
      });
      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy();
      expect(readLocaleFile(pathToLocaleEnJson)).toEqual(templateLocaleKeys('en'));
    });

    test('create-widget-locale-utils:updateAppLocales - missing locales file pt-BR', async () => {
      const appPackageName = '@acme/my-app';

      const pathToLocalePtBrJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'pt-BR.json'));

      // making sure the above files don't exist to verify the use case
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeFalsy();

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, ['pt-BR'], appPackageName); // subWorkDir is appDir
        expect(console.log).toHaveBeenCalledTimes(2); // one log message to create index.js and one for pt-BR.json
        expect(console.log.mock.calls[1][0]).toMatch(
          `Writing a new locale file ${pathToLocalePtBrJson} with default locale entries.`
        );
      });

      expect(fse.existsSync(pathToLocalePtBrJson)).toBeTruthy();
      expect(readLocaleFile(pathToLocalePtBrJson)).toEqual(templateLocaleKeys('pt-BR'));
    });

    test('create-widget-locale-utils:updateAppLocales - missing multiple locales files en and pt-BR', async () => {
      const appPackageName = '@acme/my-app';

      const pathToLocaleEnJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'en.json'));
      const pathToLocalePtBrJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'pt-BR.json'));

      // making sure the above files don't exist to verify the use case
      expect(fse.existsSync(pathToLocaleEnJson)).toBeFalsy();
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeFalsy();

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, ['en', 'pt-BR'], appPackageName); // subWorkDir is appDir
        expect(console.log).toHaveBeenCalledTimes(3); // one log message to create index.js and one for each locales (en, pt-BR)
        expect(console.log.mock.calls[1][0]).toMatch(
          `Writing a new locale file ${pathToLocaleEnJson} with default locale entries.`
        );
        expect(console.log.mock.calls[2][0]).toMatch(
          `Writing a new locale file ${pathToLocalePtBrJson} with default locale entries.`
        );
      });

      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy();
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeTruthy();
      expect(readLocaleFile(pathToLocaleEnJson)).toEqual(templateLocaleKeys('en'));
      expect(readLocaleFile(pathToLocalePtBrJson)).toEqual(templateLocaleKeys('pt-BR'));
    });

    test('create-widget-locale-utils:updateAppLocales - present but empty locale file en and pt-BR (one at a time)', async () => {
      const appPackageName = '@acme/my-app';

      /***** test for en *****/
      const pathToLocaleEnJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'en.json'));

      // making sure the above files exist to verify the use case
      expect(fse.existsSync(subWorkDir)).toBeTruthy();
      expect(fse.existsSync(pathToLocaleEnJson)).toBeFalsy();

      fse.outputFileSync(pathToLocaleEnJson, JSON.stringify({})); // writing an empty locale file
      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy(); // make sure the file was written

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, ['en'], appPackageName); // subWorkDir is appDir
        expect(console.log).toHaveBeenCalledTimes(2); // one log message to create index.js and for updating for en.json
        expect(console.log.mock.calls[1][0]).toMatch(
          `Updating locale file ${pathToLocaleEnJson} with additional locale entries.`
        );
      });

      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy();
      expect(readLocaleFile(pathToLocaleEnJson)).toEqual(templateLocaleKeys('en')); // check the content of the written file

      /***** test for pt-BR *****/
      const pathToLocalePtBrJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'pt-BR.json'));
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeFalsy();

      fse.outputFileSync(pathToLocalePtBrJson, JSON.stringify({}));
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeTruthy();

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, ['pt-BR'], appPackageName); // subWorkDir is appDir
        expect(console.log).toHaveBeenCalledTimes(2); // one log message to create index.js and for updating for pt-BR.json
        expect(console.log.mock.calls[1][0]).toMatch(
          `Updating locale file ${pathToLocalePtBrJson} with additional locale entries.`
        );
      });

      expect(fse.existsSync(pathToLocalePtBrJson)).toBeTruthy();
      expect(readLocaleFile(pathToLocalePtBrJson)).toEqual(templateLocaleKeys('pt-BR'));
    });

    test('create-widget-locale-utils:updateAppLocales - present locale file en and pt-BR with some locale entries in each (both together)', async () => {
      const appPackageName = '@acme/my-app';

      const pathToLocaleEnJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'en.json'));
      const pathToLocalePtBrJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'pt-BR.json'));

      // making sure the above files exist to verify the use case
      expect(fse.existsSync(subWorkDir)).toBeTruthy();
      expect(fse.existsSync(pathToLocaleEnJson)).toBeFalsy();
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeFalsy();

      // writing a non empty resource file for each locale
      fse.outputFileSync(pathToLocaleEnJson, JSON.stringify({sampleEnLocale: 'sample test for en locale'}));
      fse.outputFileSync(
        pathToLocalePtBrJson,
        JSON.stringify({samplePtBrLocale: '[pt-BR]sample test for en locale[pt-BR]'})
      );

      // make sure the files were written
      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy();
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeTruthy();

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, ['en', 'pt-BR'], appPackageName);
        expect(console.log).toHaveBeenCalledTimes(3); // one log message to create index.js and one for each resource file update (en, pt-BR)
        expect(console.log.mock.calls[1][0]).toMatch(
          `Updating locale file ${pathToLocaleEnJson} with additional locale entries.`
        );
        expect(console.log.mock.calls[2][0]).toMatch(
          `Updating locale file ${pathToLocalePtBrJson} with additional locale entries.`
        );
      });

      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy();
      expect(fse.existsSync(pathToLocalePtBrJson)).toBeTruthy();

      expect(readLocaleFile(pathToLocaleEnJson)).toMatchObject(templateLocaleKeys('en')); // check the content of the written file en.json
      expect(readLocaleFile(pathToLocalePtBrJson)).toMatchObject(templateLocaleKeys('pt-BR')); // check the content of the written file pt-BR.json
    });

    test('create-widget-locale-utils:updateAppLocales - present locale file en contains all required locales', async () => {
      const appPackageName = '@acme/my-app';
      const pathToLocaleIndex = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'index.js'));
      const pathToLocaleEnJson = path.resolve(path.join(subWorkDir, 'src', 'core', 'ui', 'locales', 'en.json'));

      // making sure the above files exist to verify the use case
      expect(fse.existsSync(subWorkDir)).toBeTruthy();
      expect(fse.existsSync(pathToLocaleEnJson)).toBeFalsy();

      fse.outputFileSync(pathToLocaleEnJson, JSON.stringify(templateLocaleKeys('en'))); // writing an empty locale file
      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy(); // make sure the file was written

      await mockConsole(['log', 'warn'], async () => {
        await updateAppLocales(subWorkDir, ['en'], appPackageName);
        expect(console.log).toHaveBeenCalledTimes(1); // one log message to create index.js and none for updating locale json files
        expect(console.log.mock.calls[0][0]).toMatch(`Writing an app-wide locale file ${pathToLocaleIndex}`);
      });

      expect(fse.existsSync(pathToLocaleEnJson)).toBeTruthy();
      expect(readLocaleFile(pathToLocaleEnJson)).toMatchObject(templateLocaleKeys('en')); // check the content of the written file en.json
    });
  });
});
