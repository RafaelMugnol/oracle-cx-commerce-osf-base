/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import {unmockFetchResponse, mockFetchResponse} from '@oracle-cx-commerce/test/unit';
import {Response} from 'node-fetch';

const path = require('path');
const fs = require('fs');

const {
  ENDPOINT_DEFAULT_PATH,
  ENDPOINT_FACTORY_PATH,
  getPathToEndpointsIndex,
  getPathToEndpointsMeta,
  discoverTemplateFiles
} = require('@oracle-cx-commerce/cli/templates/utils');

const {
  validateOutputFiles,
  createTestApp,
  validateImports
} = require('@oracle-cx-commerce/cli/templates/__test__/asset-creation-tests-utils');
const {createEndpoint} = require('@oracle-cx-commerce/cli/templates');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

const blankStoreOptions = {
  appName: 'blank-store',
  userName: 'dev',
  directoryName: 'aDirectoryName',
  appDir: 'packages/apps/blank-store'
};

const swaggerUrlTestCatalog = 'https://aosfpc1dev-store.occa.us-ashburn-1.ocs.oc-test.com/ccstore/v1/metadata-catalog';

const expectedSwaggerEndpointFiles = path.resolve(
  path.relative('.', __dirname),
  'expected-files',
  'create-endpoint-example-files',
  'example-swagger-endpoint-files'
);

const expectedSwaggerEndpointPluginFilesOAS2 = path.resolve(expectedSwaggerEndpointFiles, 'oas2', 'endpoint-plugin');
const expectedSwaggerEndpointFactoryFilesOAS2 = path.resolve(expectedSwaggerEndpointFiles, 'oas2', 'factory');

const expectedSwaggerEndpointPluginFilesOAS2LocalFile = path.resolve(
  expectedSwaggerEndpointFiles,
  'oas2-local-file',
  'endpoint-plugin'
);
const expectedSwaggerEndpointFactoryFilesOAS2LocalFile = path.resolve(
  expectedSwaggerEndpointFiles,
  'oas2-local-file',
  'factory'
);

const expectedSwaggerEndpointPluginFilesOAS3 = path.resolve(expectedSwaggerEndpointFiles, 'oas3', 'endpoint-plugin');
const expectedSwaggerEndpointFactoryFilesOAS3 = path.resolve(expectedSwaggerEndpointFiles, 'oas3', 'factory');

const expectedSwaggerEndpointPluginFilesOAS3LocalFile = path.resolve(
  expectedSwaggerEndpointFiles,
  'oas3-local-file',
  'endpoint-plugin'
);
const expectedSwaggerEndpointFactoryFilesOAS3LocalFile = path.resolve(
  expectedSwaggerEndpointFiles,
  'oas3-local-file',
  'factory'
);

const expectedUrlEndpointFiles = path.resolve(
  path.relative('.', __dirname),
  'expected-files',
  'create-endpoint-example-files',
  'example-url-endpoint-files'
);

const mockSwaggerAPIResponseDataPathOAS2 = path.resolve(
  expectedSwaggerEndpointFiles,
  'oas2-swagger-api-mock-response.json'
);
const mockSwaggerAPIResponseDataOAS2 = fs.readFileSync(mockSwaggerAPIResponseDataPathOAS2, 'utf-8');

const mockSwaggerAPIResponseDataPathOAS3 = path.resolve(
  expectedSwaggerEndpointFiles,
  'oas3-swagger-api-mock-response.json'
);
const mockSwaggerAPIResponseDataOAS3 = fs.readFileSync(mockSwaggerAPIResponseDataPathOAS3, 'utf-8');

describe('create-endpoint:all  -  all the tests that will invoke create-endpoint with different options', () => {
  let testAppPath, tempAppDir;
  beforeAll(async () => {
    tempAppDir = await createTestApp(blankStoreOptions.appName);
    expect(tempAppDir).toBeDefined();
    testAppPath = path.resolve(tempAppDir.path, blankStoreOptions.appName);
  });

  afterAll(async () => {
    await tempAppDir.cleanup();
  });

  describe('create-swagger-endpoint:all  -  all the tests that will invoke create-endpoint with --swaggerUrl option', () => {
    beforeEach(() => {
      mockFetchResponse(swaggerUrlTestCatalog, new Response(mockSwaggerAPIResponseDataOAS2));
    });

    afterAll(() => {
      unmockFetchResponse(swaggerUrlTestCatalog);
    });

    test('create-swagger-endpoint:list-template-files - check that all swagger endpoint template files are present', () => {
      const swaggerEndpointsTemplatesParentDirectory = path.resolve(
        path.relative('.', __dirname),
        '..',
        'endpoints',
        'template-files'
      );
      const swaggerEndpointsFactoryPath = path.resolve(swaggerEndpointsTemplatesParentDirectory, 'factory');
      const swaggerEndpointsPluginPath = path.resolve(swaggerEndpointsTemplatesParentDirectory, 'endpoint-plugin');

      const expectedEndpointFactoryFileList = ['endpoint-factory.js'];
      expect(discoverTemplateFiles(swaggerEndpointsFactoryPath).sort()).toMatchObject(
        expectedEndpointFactoryFileList.sort()
      );

      const expectedEndpointPluginFileList = [
        path.join('__test__', 'index.spec.js'),
        'index.js',
        'meta.js',
        path.join('schema', 'input.js'),
        path.join('schema', 'output.js')
      ];
      expect(discoverTemplateFiles(swaggerEndpointsPluginPath).sort()).toMatchObject(
        expectedEndpointPluginFileList.sort()
      );
    });

    test('create-swagger-endpoint:create-an-already-existing-swagger-endpoint-factory - create a endpoint where an endpoint factory already existing in an specific app', async () => {
      const optionsFirstEndpoint = {
        ...blankStoreOptions,
        appDir: testAppPath,
        directoryName: 'firstSwaggerEndpointExample',
        swagger: swaggerUrlTestCatalog
      };
      const optionsSecondEndpoint = {...optionsFirstEndpoint};

      await expect(createEndpoint(optionsFirstEndpoint.appName, optionsFirstEndpoint)).resolves.not.toThrow();

      const endpointFactoryNamePath = `${dashCase(optionsFirstEndpoint.directoryName)}-endpoint`;

      mockFetchResponse(swaggerUrlTestCatalog, new Response(mockSwaggerAPIResponseDataOAS2));

      await expect(createEndpoint(optionsSecondEndpoint.appName, optionsSecondEndpoint)).rejects.toThrow(
        `Endpoint Factory "${endpointFactoryNamePath}", already exists in path ${path.resolve(
          optionsSecondEndpoint.appDir,
          ENDPOINT_FACTORY_PATH
        )}. Please provide a different name using --directoryName.`
      );
    });

    test('create-swagger-endpoint:create-an-already-existing-swagger-endpoint-plugin - create a endpoint where an endpoint plugin already existing in an specific app', async () => {
      const optionsFirstEndpoint = {
        ...blankStoreOptions,
        appDir: testAppPath,
        directoryName: 'secondSwaggerEndpointExample',
        swagger: swaggerUrlTestCatalog
      };
      const optionsSecondEndpoint = {...optionsFirstEndpoint};

      await expect(createEndpoint(optionsFirstEndpoint.appName, optionsFirstEndpoint)).resolves.not.toThrow();
      const endpointFactoryNamePath = `${dashCase(optionsFirstEndpoint.directoryName)}-endpoint`;
      const pathToEndpointFactory = path.resolve(
        optionsFirstEndpoint.appDir,
        ENDPOINT_FACTORY_PATH,
        endpointFactoryNamePath
      );
      fs.unlinkSync(`${pathToEndpointFactory}.js`);

      mockFetchResponse(swaggerUrlTestCatalog, new Response(mockSwaggerAPIResponseDataOAS2));

      await expect(createEndpoint(optionsSecondEndpoint.appName, optionsSecondEndpoint)).rejects.toThrow(
        `Endpoint Plugin "${optionsFirstEndpoint.directoryName}", already exists in path ${path.resolve(
          optionsSecondEndpoint.appDir,
          ENDPOINT_DEFAULT_PATH
        )}. Please provide a different name using --directoryName.`
      );
    });

    test('create-swagger-endpoint:check-for-imports-in-test-app-imports - create a swagger endpoint in the test app and check if imports exist', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        directoryName: 'thirdSwaggerEndpointExample',
        swagger: swaggerUrlTestCatalog
      };
      const copyOfOptions = {...options};
      await expect(createEndpoint(options.appName, options)).resolves.not.toThrow();
      const testAppEndpointPluginIndexPath = getPathToEndpointsIndex(options.appDir);
      const testAppEndpointPluginMetaPath = getPathToEndpointsMeta(options.appDir);

      const newSwaggerPluginDirectoryNamePath = `${copyOfOptions.directoryName}`;
      validateImports(testAppEndpointPluginIndexPath, `${newSwaggerPluginDirectoryNamePath}`);
      validateImports(testAppEndpointPluginMetaPath, `${newSwaggerPluginDirectoryNamePath}`);
    });

    test('create-swagger-endpoint:check-endpoint-content-in-test-app-content-OAS2 - create a swagger endpoint in the test app and check the content', async () => {
      const options = {
        ...blankStoreOptions,
        directoryName: 'oas2SwaggerEndpointExample',
        appDir: testAppPath,
        swagger: swaggerUrlTestCatalog,
        endpoints: 'listAddresses'
      };
      const copyOfOptions = {...options};

      await createEndpoint(options.appName, options);

      const newSwaggerEndpointPluginPath = path.resolve(
        options.appDir,
        ENDPOINT_DEFAULT_PATH,
        copyOfOptions.directoryName
      );
      const newSwaggerEndpointFactoryPath = path.resolve(options.appDir, ENDPOINT_FACTORY_PATH);

      validateOutputFiles(expectedSwaggerEndpointFactoryFilesOAS2, newSwaggerEndpointFactoryPath);
      validateOutputFiles(expectedSwaggerEndpointPluginFilesOAS2, newSwaggerEndpointPluginPath);
    });

    test('create-swagger-endpoint:check-endpoint-content-in-test-app-content-OAS2-from-local-file - create a swagger endpoint from a local file in the test app and check the content', async () => {
      const options = {
        ...blankStoreOptions,
        directoryName: 'oas2LocalSwaggerEndpointExample',
        appDir: testAppPath,
        swagger: mockSwaggerAPIResponseDataPathOAS2,
        endpoints: 'listAddresses'
      };
      const copyOfOptions = {...options};

      await createEndpoint(options.appName, options);

      const newSwaggerEndpointPluginPath = path.resolve(
        options.appDir,
        ENDPOINT_DEFAULT_PATH,
        copyOfOptions.directoryName
      );
      const newSwaggerEndpointFactoryPath = path.resolve(options.appDir, ENDPOINT_FACTORY_PATH);

      validateOutputFiles(expectedSwaggerEndpointFactoryFilesOAS2LocalFile, newSwaggerEndpointFactoryPath);
      validateOutputFiles(expectedSwaggerEndpointPluginFilesOAS2LocalFile, newSwaggerEndpointPluginPath);
    });
    test('create-swagger-endpoint:check-endpoint-content-in-test-app-content-OAS3 - create a swagger endpoint in the test app and check the content', async () => {
      const options = {
        ...blankStoreOptions,
        directoryName: 'oas3SwaggerEndpointExample',
        appDir: testAppPath,
        swagger: swaggerUrlTestCatalog,
        endpoints: 'listAddresses'
      };
      const copyOfOptions = {...options};

      unmockFetchResponse(swaggerUrlTestCatalog);
      mockFetchResponse(swaggerUrlTestCatalog, new Response(mockSwaggerAPIResponseDataOAS3));

      await createEndpoint(options.appName, options);

      const newSwaggerEndpointPluginPath = path.resolve(
        options.appDir,
        ENDPOINT_DEFAULT_PATH,
        copyOfOptions.directoryName
      );
      const newSwaggerEndpointFactoryPath = path.resolve(options.appDir, ENDPOINT_FACTORY_PATH);

      validateOutputFiles(expectedSwaggerEndpointFactoryFilesOAS3, newSwaggerEndpointFactoryPath);
      validateOutputFiles(expectedSwaggerEndpointPluginFilesOAS3, newSwaggerEndpointPluginPath);
    });

    test('create-swagger-endpoint:check-endpoint-content-in-test-app-content-OAS3-from-local-file - create a swagger endpoint from a local file in the test app and check the content', async () => {
      const options = {
        ...blankStoreOptions,
        directoryName: 'oas3LocalSwaggerEndpointExample',
        appDir: testAppPath,
        swagger: mockSwaggerAPIResponseDataPathOAS3,
        endpoints: 'listAddresses'
      };
      const copyOfOptions = {...options};

      unmockFetchResponse(swaggerUrlTestCatalog);
      mockFetchResponse(swaggerUrlTestCatalog, new Response(mockSwaggerAPIResponseDataOAS3));

      await createEndpoint(options.appName, options);

      const newSwaggerEndpointPluginPath = path.resolve(
        options.appDir,
        ENDPOINT_DEFAULT_PATH,
        copyOfOptions.directoryName
      );
      const newSwaggerEndpointFactoryPath = path.resolve(options.appDir, ENDPOINT_FACTORY_PATH);

      validateOutputFiles(expectedSwaggerEndpointFactoryFilesOAS3LocalFile, newSwaggerEndpointFactoryPath);
      validateOutputFiles(expectedSwaggerEndpointPluginFilesOAS3LocalFile, newSwaggerEndpointPluginPath);
    });
  });

  describe('create-endpoint-for-url:all  -  all the tests that will invoke create-endpoint with --url option', () => {
    test('create-endpoint-for-url:list-template-files - check that all swagger endpoint template files are present', () => {
      const swaggerEndpointsTemplatesParentDirectory = path.resolve(
        path.relative('.', __dirname),
        '..',
        'endpoints',
        'template-files'
      );
      const swaggerEndpointsPluginPath = path.resolve(swaggerEndpointsTemplatesParentDirectory, 'endpoint-plugin');
      const expectedEndpointPluginFileList = [
        path.join('__test__', 'index.spec.js'),
        'index.js',
        'meta.js',
        path.join('schema', 'input.js'),
        path.join('schema', 'output.js')
      ];
      expect(discoverTemplateFiles(swaggerEndpointsPluginPath).sort()).toMatchObject(
        expectedEndpointPluginFileList.sort()
      );
    });

    test('create-endpoint-for-url:create-an-already-existing-endpoint-url - create a endpoint where an endpoint already existing in an specific app', async () => {
      const optionsFirstEndpoint = {
        ...blankStoreOptions,
        appDir: testAppPath,
        directoryName: 'firstUrlEndpointExample',
        url: 'http://example.com/catalogApi',
        verb: 'GET'
      };
      const optionsSecondEndpoint = {...optionsFirstEndpoint};

      await expect(createEndpoint(optionsFirstEndpoint.appName, optionsFirstEndpoint)).resolves.not.toThrow();

      await expect(createEndpoint(optionsSecondEndpoint.appName, optionsSecondEndpoint)).rejects.toThrow(
        `Endpoint "${optionsFirstEndpoint.directoryName}", already exists in path ${path.resolve(
          optionsFirstEndpoint.appDir,
          ENDPOINT_DEFAULT_PATH
        )}.`
      );
    });

    test('create-endpoint-for-url:check-for-imports-in-test-app-imports - create an endpoint for a url in the test app and check if imports exist', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        directoryName: 'secondUrlEndpointExample',
        url: 'http://example.com/catalogApi',
        verb: 'GET'
      };

      await expect(createEndpoint(options.appName, options)).resolves.not.toThrow();
      const testAppEndpointPluginIndexPath = getPathToEndpointsIndex(options.appDir);
      const testAppEndpointPluginMetaPath = getPathToEndpointsMeta(options.appDir);

      const newSwaggerPluginDirectoryNamePath = options.directoryName;
      validateImports(testAppEndpointPluginIndexPath, `${newSwaggerPluginDirectoryNamePath}`);
      validateImports(testAppEndpointPluginMetaPath, `${newSwaggerPluginDirectoryNamePath}`);
    });

    test('create-endpoint-for-url:check-endpoint-content-in-test-app-content - create a swagger endpoint in the test app and check the content', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        directoryName: 'thirdUrlEndpointExample',
        url: 'http://example.com/catalogApi',
        verb: 'GET'
      };
      await createEndpoint(options.appName, options);

      const newUrlEndpointPluginPath = path.resolve(options.appDir, ENDPOINT_DEFAULT_PATH, options.directoryName);

      validateOutputFiles(expectedUrlEndpointFiles, newUrlEndpointPluginPath);
    });
  });

  describe('create-endpoint-bad-options:all  -  use cases that should not work when creating an endpoint', () => {
    test('create-endpoint-bad-options:no-url-option - run createEndpoint without url or swagger', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath
      };
      await expect(createEndpoint(options.appName, options)).rejects.toThrow(
        `The endpoint URL is missing. Please specify either '--swagger' or '--url' when creating endpoints.`
      );
    });

    test('create-endpoint-bad-options:both-url-and-swagger - using both options --url or --swagger to createEndpoint', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        swagger: swaggerUrlTestCatalog,
        url: 'http://example.com/catalogApi'
      };

      await expect(createEndpoint(options.appName, options)).rejects.toThrow(
        `Can't specify both '--swagger' and '--url' when creating an endpoint.`
      );
    });

    test('create-endpoint-bad-options:specify-verb-with-swagger - run createEndpoint without verb and swagger', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        verb: 'GET',
        swagger: swaggerUrlTestCatalog
      };
      await expect(createEndpoint(options.appName, options)).rejects.toThrow(
        `Can't specify 'verb' when creating endpoints from a swagger document.`
      );
    });

    test('create-endpoint-bad-options:specify-no-verb-with-Url - run createEndpoint without verb and url', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        url: 'http://example.com/catalogApi'
      };
      await expect(createEndpoint(options.appName, options)).rejects.toThrow(
        `Please provide a valid value for 'verb'.`
      );
    });
    test('create-endpoint-bad-options:specify-endpoints-with-url - run createEndpoint without url and endpoints', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        url: 'http://example.com/catalogApi',
        endpoints: 'anEndpoints'
      };
      await expect(createEndpoint(options.appName, options)).rejects.toThrow(
        `Can't specify 'endpoints' when creating endpoints for a URL.`
      );
    });

    test('create-endpoint-bad-options:specify-non-valid-verb-with-swagger - run createEndpoint with a non-valid verb and Url', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        verb: 'nonValidVerb',
        url: 'http://example.com/catalogApi'
      };
      await expect(createEndpoint(options.appName, options)).rejects.toThrow(
        `'${options.verb}' is an invalid value for option 'verb'.`
      );
    });
  });

  describe('create-endpoint-utility-functions:all  -  test each endpoint utils function individually', () => {
    beforeEach(() => {
      mockFetchResponse(swaggerUrlTestCatalog, new Response(mockSwaggerAPIResponseDataOAS2));
    });

    afterAll(() => {
      unmockFetchResponse(swaggerUrlTestCatalog);
    });

    test('create-endpoint-utility-functions:add-origin-to-app-config - check app-config before and after running create-endpoint', async () => {
      const options = {
        ...blankStoreOptions,
        appDir: testAppPath,
        directoryName: 'firstUtilitySwaggerEndpointExample',
        swagger: swaggerUrlTestCatalog
      };

      const pathToAppConfig = path.resolve(options.appDir, path.join('config', 'app-config', 'index.js'));

      let appConfigBefore = {};
      if (fs.existsSync(pathToAppConfig)) {
        appConfigBefore = require(pathToAppConfig);
      }

      // if endpointOrigin already exists, check that the specific API_NAME does not exists in it
      if (appConfigBefore.endpointOrigins) {
        expect(appConfigBefore.endpointOrigins[options.directoryName]).toBeFalsy();
      }
      await expect(createEndpoint(options.appName, options)).resolves.not.toThrow();

      const appConfigAfter = require(pathToAppConfig);

      expect(appConfigAfter.endpointOrigins[options.directoryName]).toBeTruthy();

      const parsedSwaggerFile = JSON.parse(mockSwaggerAPIResponseDataOAS2);
      const expectedCatalogOrigin = new URL(swaggerUrlTestCatalog).origin;

      expect(appConfigAfter.endpointOrigins[options.directoryName].origin).toEqual(`https://${parsedSwaggerFile.host}`);
      expect(appConfigAfter.endpointOrigins[options.directoryName].catalogOrigin).toEqual(expectedCatalogOrigin);
    });
  });
});
