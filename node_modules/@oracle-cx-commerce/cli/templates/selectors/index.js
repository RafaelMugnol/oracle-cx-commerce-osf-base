/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const {dashCase} = require('@oracle-cx-commerce/tools-util/strings');

const {selectorIndexExportString} = require('@oracle-cx-commerce/cli/templates/selectors/string-utils');

const {
  SELECTOR_DEFAULT_PATH,
  writeTemplateFiles,
  getPathToSelectorIndex,
  createOrUpdateImportsAndExports,
  generateTemplateFiles,
  verifyApp,
  validatePluginFolderExists,
  pluginExists,
  standardizePluginName
} = require('@oracle-cx-commerce/cli/templates/utils');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const logger = require('@oracle-cx-commerce/logger/cli');
const fse = require('fs-extra');

/**
 * Adds an export and import reference at the end of an index.js or meta.js file
 *
 * @param      {Object}  options   The command line options including appDir and other widget specific options
 */
async function checkAndUpdateSelectorExports(options) {
  const pathToSelectorsIndex = getPathToSelectorIndex(options.appDir);
  logger.info(___`Updating exports for files:`);
  await createOrUpdateImportsAndExports(pathToSelectorsIndex, selectorIndexExportString(options.selectorName));
  logger.info(___`\t${pathToSelectorsIndex}`);
}

/**
 * List all files and directories that need to be created for the new component.
 *
 * @param      {string}   name              selector name
 * @param      {Object}   options           The command line options including appDir and other widget specific options
 */

async function validateSelectorOptions(options) {
  if (!options.table && options.entityId) {
    throw new Error(___`Can't specify 'entityId' when 'table' is not specified.`);
  }
  if (!options.table && options.entity) {
    throw new Error(___`Can't specify 'entity' when 'table' is not specified.`);
  }
  if (options.entity && options.entityId) {
    throw new Error(___`Can't specify both entity and entityId together.`);
  }
}
async function createSelector(appName, options) {
  await validateSelectorOptions(options);
  // Validate/standardize plugin name
  if (!options.name) {
    if (
      options.repository !== undefined &&
      options.table === undefined &&
      options.entityId === undefined &&
      options.entity === undefined
    ) {
      options.selectorName = standardizePluginName(options.repository);
    }
    if (
      options.repository !== undefined &&
      options.table !== undefined &&
      options.entityId === undefined &&
      options.entity === undefined
    ) {
      options.selectorName = standardizePluginName(options.table);
    }
    if (
      options.repository !== undefined &&
      options.table !== undefined &&
      options.entityId !== undefined &&
      options.entity === undefined
    ) {
      options.selectorName = standardizePluginName(options.entityId);
    }
    if (
      options.repository !== undefined &&
      options.table !== undefined &&
      options.entityId === undefined &&
      options.entity !== undefined
    ) {
      options.selectorName = standardizePluginName(options.entity);
    }
  }
  if (options.name) {
    options.selectorName = standardizePluginName(options.name);
  }
  options.repository = standardizePluginName(options.repository);
  options.table = standardizePluginName(options.table);
  options.entityId = standardizePluginName(options.entityId);
  options.entity = standardizePluginName(options.entity);

  // Verify app exists
  await verifyApp(appName, options.appDir);
  // Check if 'selectors' folders exists, create if it does not.
  try {
    validatePluginFolderExists(options.appDir, SELECTOR_DEFAULT_PATH);
  } catch (err) {
    await fse.ensureDir(path.resolve(options.appDir, SELECTOR_DEFAULT_PATH));
  }

  // Check if selector with the same name already exists
  if (pluginExists(options.appDir, SELECTOR_DEFAULT_PATH, `${dashCase(options.selectorName)}`)) {
    throw new Error(
      ___`Selector "${dashCase(options.selectorName)}", already exists in path ${path.resolve(
        options.appDir,
        SELECTOR_DEFAULT_PATH
      )}.`
    );
  }

  // Log information about the selector to create
  logger.info(___`Selector name: ${options.selectorName}`);
  logger.info(___`\tPath to Selector files: ${path.join(options.appDir, SELECTOR_DEFAULT_PATH)}`);

  // Generate files content to be written
  const templatesDirectory = path.resolve(path.relative('.', __dirname), 'template-files');

  const filesToWrite = generateTemplateFiles(templatesDirectory, options);

  // Define destination for new selector
  const installPath = path.join(options.appDir, SELECTOR_DEFAULT_PATH);
  const newSelectorFolder = path.join(installPath, dashCase(options.selectorName));
  logger.info(___`Creating new selector folder ${newSelectorFolder}.`);

  // Write the files to the specified destination
  await writeTemplateFiles(newSelectorFolder, filesToWrite);

  // Update Exports
  await checkAndUpdateSelectorExports(options);
}

module.exports = {createSelector};
