/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const logger = require('@oracle-cx-commerce/logger/server');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});

// An array to hold all incoming tcp connections to the server
const connections = [];

// True when the server is terminating and passes a set timeout interval
let timedOut = false;

/**
 * Close idle connections if all is set to false,
 * Otherwise, close all connections.
 *
 * @param {boolean} all close all connections if set to true
 */
function closeIdleConnections(all = false) {
  connections.forEach(connection => {
    if (connection.isIdle || all) {
      connection.destroy();
      connections.splice(connections.indexOf(connection), 1);
    }
  });
  if (all) {
    logger.debug(___`Closed all remaining connections`);
  }
}

/**
 * Helper function to close all connections
 *
 */
function closeAllConnections() {
  closeIdleConnections(true);
}

/**
 * Recursively monitor the active connections. Close any connections
 * that become idle. Close server if all connections are closed,
 * or a timeout is encountered
 *
 * @param {HttpServer | HttpsServer} server the server to be monitored
 * @param {integer} timeout the number of milliseconds before forceful shutdown
 */
function monitorActiveConnections(server, timeout) {
  closeIdleConnections();

  // Close the server if there are no remaining connections
  if (connections.length === 0) {
    server.close(() => {
      logger.info(___`Successfully terminated the server`);
      process.exit(0);
    });

    return;
  }

  // Close the server on a timeout
  if (timedOut) {
    // Close all remaining active connections
    closeAllConnections();
    server.close(() => {
      logger.error(___`Terminating server due to timeout`);
      process.exit(1);
    });

    return;
  }

  // Ping the server 5 times before timing out
  setTimeout(() => {
    monitorActiveConnections(server, timeout);
  }, timeout / 5);
}

/**
 * Listen to connection and request events and update
 * the connections list accordingly
 *
 * @param {HttpServer | HttpsServer} server the server whose connections are to be watched
 */
function watchConnections(server) {
  // Listen to connection events
  server.on('connection', connection => {
    // Connections are assumed to be idle when created
    // A request event will mark them as active
    connection.isIdle = true;
    connections.push(connection);
  });

  // Listen to request events
  server.on('request', (req, res) => {
    // While the request is being handled, the connection is no longer idle
    req.connection.isIdle = false;
    res.on('finish', () => {
      // Once the response is finished, the connection is idle again
      req.connection.isIdle = true;
    });
  });
}

/**
 * Terminates the running server by closing all idle connections and waiting
 * for timeout ms before forcefully closing active connections
 *
 * @param {HttpServer | HttpsServer} server the server to be terminated
 * @param {integer} timeout the number of milliseconds before forceful shutdown
 */
function terminate(server, timeout) {
  logger.info(___`Terminate presentation server`);

  // Set the timedOut boolean to true, so monitorActiveConnections
  // can initiate a forced shutdown
  setTimeout(() => {
    timedOut = true;
  }, timeout);

  // Recursively monitor active connections and shutdown the server
  // When all connections are closed, or on a timeout
  monitorActiveConnections(server, timeout);
}

module.exports = {
  watchConnections,
  terminate
};
