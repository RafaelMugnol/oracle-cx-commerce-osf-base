/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const logger = require('@oracle-cx-commerce/logger/server');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});

// A Set to hold all incoming tcp connections to the server
const connections = new Set();

// True when the server is terminating and passes a set timeout interval
let timedOut = false;

/**
 * Close idle connections if all is set to false,
 * Otherwise, close all connections.
 *
 * @param {boolean} all close all connections if set to true
 */
function closeIdleConnections(all = false) {
  connections.forEach(connection => {
    const current = Date.now();
    // If the connection is older than 1 min, or closing all connections, close.
    if (all || current - connection.idleSince > 60000) {
      connection.destroy();
      connections.delete(connection);
    }
  });
  if (all) {
    logger.debug(___`Closed all remaining connections`);
  }
}

/**
 * Helper function to close all connections
 *
 */
function closeAllConnections() {
  closeIdleConnections(true);
}

/**
 * Recursively monitor the active connections. Close any connections
 * that become idle. Close server if all connections are closed,
 * or a timeout is encountered
 *
 * @param {HttpServer | HttpsServer} server the server to be monitored
 * @param {integer} timeout the number of milliseconds before forceful shutdown
 */
function monitorActiveConnections(server, timeout) {
  closeIdleConnections();

  // Close the server if there are no remaining connections
  if (connections.size === 0) {
    server.close(() => {
      logger.info(___`Successfully terminated the server`);
      process.exit(0);
    });

    return;
  }

  // Close the server on a timeout
  if (timedOut) {
    // Close all remaining active connections
    closeAllConnections();
    server.close(() => {
      logger.error(___`Terminating server due to timeout`);
      process.exit(1);
    });

    return;
  }

  // Ping the server 5 times before timing out
  setTimeout(() => {
    monitorActiveConnections(server, timeout);
  }, timeout / 5);
}

/**
 * Adds a connection to the list of connections to be monitored, so we know when
 * the server can be gracefully shutdown (all connections idle, preferably)
 * @param {net.Socket} connection
 */
function addConnection(connection) {
  // Connections are assumed to be idle when created
  // A request event will mark them as active
  connection.idleSince = Date.now();
  connections.add(connection);

  // When a connections is complete, remove it from the list to avoid memory leak
  connection.once('close', () => {
    connections.delete(connection);
  });
}

/**
 * Listen to connection and request events and update
 * the connections list accordingly
 *
 * @param {HttpServer | HttpsServer} server the server whose connections are to be watched
 */
function watchConnections(server) {
  // Listen to connection events
  server.on('connection', connection => {
    addConnection(connection);
  });

  // Listen to request events
  server.on('request', (req, res) => {
    // While the request is being handled, the connection is no longer idle (set its "idleSince" to max so it won't be deleted)
    req.connection.idleSince = Number.MAX_SAFE_INTEGER;
    res.on('finish', () => {
      // Once the response is finished, the connection is idle again
      req.connection.idleSince = Date.now();
    });
  });

  // Close idle connections every minute (was unnecessary for fixing mem leak)
  // setInterval(closeIdleConnections, 60000);
}

/**
 * Terminates the running server by closing all idle connections and waiting
 * for timeout ms before forcefully closing active connections
 *
 * @param {HttpServer | HttpsServer} server the server to be terminated
 * @param {integer} timeout the number of milliseconds before forceful shutdown
 */
function terminate(server, timeout) {
  logger.info(___`Terminate presentation server`);
  // TODO add server.close() here - otherwise the server won't stop accepting new
  // requests while it's waiting for existing requests to become idle. Technically
  // not an issue (nginx should stop routing to it) but also technically bad practice
  // Not changing it now because may be complicated/need to absolutely ensure that
  // the OSF server will *eventually* shutdown when called.

  // Set the timedOut boolean to true, so monitorActiveConnections
  // can initiate a forced shutdown
  setTimeout(() => {
    timedOut = true;
  }, timeout);

  // Recursively monitor active connections and shutdown the server
  // When all connections are closed, or on a timeout
  monitorActiveConnections(server, timeout);
}

module.exports = {
  watchConnections,
  terminate
};
