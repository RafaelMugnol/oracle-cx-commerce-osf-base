/*
 ** Copyright (c) 2022 Oracle and/or its affiliates.
 */

/* eslint-disable max-lines */
const {createRestClient} = require('@oracle-cx-commerce/tools-util').restclient;
const fsExtra = require('fs-extra');
const path = require('path');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, '../locales')});
const logger = require('@oracle-cx-commerce/logger/cli');

/* CONSTANTS */
const regionTypes = {
  HEADER: 100,
  MAIN: 101,
  FOOTER: 102
};

const structureTypes = {
  FLAT: 100,
  STACK: 101,
  SLOT: 102
};

const pageTypeToSpecialContainerMap = {
  category: 'DynamicProductListingContainer',
  cart: 'CartContainer',
  agentOrderDetails: 'ProfileOrderDetailsContainer',
  orderDetails: 'ProfileOrderDetailsContainer',
  confirmation: 'CheckoutOrderConfirmationContainer',
  profile: 'ResponsiveContainer',
  checkout: 'Container',
  agentCheckout: 'Container',
  product: 'ProductDetailsContainer'
};

/* DEFAULT LAYOUT STRUCTURES */
const STRUCTURES = {
  defaultHeaderRegion: {
    displayName: 'Adaptive Region',
    width: 12,
    resources: {
      en: {
        displayName: 'Adaptive Region'
      }
    },
    slot: 'header-with-notification-device-slot',
    type: 'header',
    structure: 'slot'
  },
  defaultFooterRegion: {
    components: ['footer'],
    width: 12,
    type: 'footer'
  },
  containerIndexFile: {
    type: 'Container'
  },
  dummyWidgetIndexFile: {
    type: 'PlaceholderWidget'
  },
  containerLayoutFile: {
    regions: [
      {
        components: [],
        width: 12,
        type: 'main'
      }
    ]
  },
  webContentIndexFile: {
    type: 'WebContent'
  }
};

//Map to store stack instance names of components to avoid duplicate names.
const stackInstancesMap = {};
//Map to store urls of sites mapped to their site ids.
const siteURLMap = {};

//Map which stores the updated instance names for associating and creating the instances if same instance is present in OOTB
const widgetMap = new Map();
//Map which stores the list of widgets created by this tool
const isWidgetCreatedMap = new Map();

//Method to invoke POST api.
const invokePostApi = async (url, params, restClient) => {
  try {
    const response = await restClient.request({
      method: 'post',
      url,
      headers: {
        'Content-Type': 'application/json; charset=UTF-8',
        'X-CCAsset-Language': 'en'
      },
      responseType: 'json',
      body: params
    });

    return response;
  } catch (err) {
    logger.error(err);
  }
};

//Method to invoke GET api.
const invokeGetApi = async (url, restClient) => {
  const {body = {}} = await restClient.request({
    method: 'get',
    url,
    headers: {
      'Content-Type': 'application/json; charset=UTF-8',
      'X-CCAsset-Language': 'en'
    },
    responseType: 'json'
  });

  return body;
};

//Method to create file at given path.
const createFileAtGivenPath = (fileName, folderPath, data, newFolderName = null) => {
  let file = `${folderPath}/${fileName}.json`;
  if (newFolderName) {
    newFolderName = newFolderName.replace(/:/g, '');
    file = `${folderPath}/${newFolderName}/${fileName}.json`;
    if (!fsExtra.existsSync(`${folderPath}/${newFolderName}`)) {
      fsExtra.mkdirSync(`${folderPath}/${newFolderName}`);
    }
  }
  fsExtra.writeFile(file, JSON.stringify(data, null, '\t'), error => {
    if (error) logger.error(error);
    else logger.debug(`created file ${fileName} at ${file}`);
  });
};

//Method to get asset filenames in kebab case.
const getFileNameFromDisplayName = (displayName = '') => {
  displayName = displayName.replace('-', ' ');
  displayName = displayName.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, '');
  displayName = displayName.trim();

  return displayName.replace(/\s+/g, '-').toLowerCase();
};

//Method to get asset folder names in kebab case.
const getComponentNameFromDisplayName = (displayName = '') => {
  displayName = displayName.replace(/[<>"/\\\\|?*]/g, '');
  displayName = displayName.trim();

  return displayName.replace(/:/g, '-');
};

/* ASSETS CONVERSION FUNCTIONS */
const getPageName = (layout = {}) => {
  const {displayName, pageTitle, pageDisplayName} = layout;
  if (displayName) return displayName;
  if (pageTitle) return pageTitle;

  return pageDisplayName;
};

//Method to add associated site urls to the app.
const mapAssociatedSites = (layout = {}) => {
  const {sites} = layout;

  if (sites.length > 0) {
    const associatedSites = [];

    for (const site in sites) {
      associatedSites.push(siteURLMap[sites[site]]);
    }

    return associatedSites;
  }

  return sites;
};

//Method to form the actual page contents for OSF app using the details of classic app.
const transformPageDetails = (pageDetails, shortName) => {
  const {route, name, layout = {}, defaultPage} = pageDetails;
  const sName = shortName === route.slice(1) || shortName === 'article' ? shortName : name;
  const details = {
    address: route,
    title: getPageName(layout),
    shortName: sName,
    defaultPage,
    layout: []
  };
  const siteAssociation = mapAssociatedSites(layout);
  const settings = {};

  for (const setting in layout) {
    if (setting === 'metaTags') {
      if (layout[setting] === '') {
        settings[setting] = [];
      } else {
        settings[setting] = layout[setting];
      }
    } else if (setting === 'sites') {
      if (siteAssociation.length > 0) {
        settings.sites = siteAssociation;
        Object.assign(settings, {sites: siteAssociation});
      }
    } else if (setting === 'layoutCollections') {
      if (layout[setting] === '') {
        settings['collections'] = [];
      } else {
        const layoutCollectionsArray = layout[setting].split(',');
        settings['collections'] = layoutCollectionsArray;
      }
    } else if (setting === 'layoutViewports' || setting === 'supportedDevices') {
      if (setting !== 'supportedDevices') {
        const devices = [];
        if (layout[setting].includes('xs') || layout[setting].includes('sm')) {
          devices.push('mobile');
        }
        if (layout[setting].includes('md') || layout[setting].includes('lg')) {
          devices.push('desktop');
        }

        details.supportedDevices = devices;
      }
    } else {
      settings[setting] = layout[setting];
    }
  }

  return {
    ...details,
    settings
  };
};
/**
 * compileLess API appends common CSS to widget's CSS, this function will extract only the widget specific CSS
 * 1. Find the indices of first and last occurrence of widget css selector.
 * 2. Take index of first occurrence as starting index and closing bracket of last occurrence as ending index.
 * 3. If last occurrence is inside a media query, find the closing bracket of media query and consider it as ending index.
 */
const getWidgetSpecificCss = (wholeCss = '', widgetCssSelector) => {
  const startIndex = wholeCss.indexOf(widgetCssSelector);
  const lastOccuranceIndex = wholeCss.lastIndexOf(widgetCssSelector);
  const closingBracketOfLastOccuranceIndex = wholeCss.indexOf('}', lastOccuranceIndex + 1);
  let endIndex = closingBracketOfLastOccuranceIndex + 1;

  let index = lastOccuranceIndex - 1;
  while (wholeCss.charAt(index) === ' ') index--;
  // if there is a opening bracket before widgetCssSelector then it should be present inside @media {}
  if (wholeCss.charAt(index) === '{') {
    const mediaQueryClosingBracketIndex = wholeCss.indexOf('}', closingBracketOfLastOccuranceIndex + 1);
    endIndex = mediaQueryClosingBracketIndex + 1;
  }

  return wholeCss.slice(startIndex, endIndex);
};

/**
 * Method to convert a web-content widget to corresponding OSF widget.
 * @param {Object} widget Widget object extracted from the layout region.
 * @param {string} assetsPath Path of the assets directory in the new app.
 * @param {Client} restClient The rest client to get required data from api calls.
 * @param {Object} notes The notes object extracted from the widget api call.
 */
const convertWebContentWidgetToOSF = async (widget, assetsPath, restClient, notes) => {
  const {repositoryId, displayName, descriptor = {}} = widget;
  const widgetCssId = `${descriptor.repositoryId}-${repositoryId}`;
  let folderName = getComponentNameFromDisplayName(displayName);
  folderName = folderName.toLowerCase();
  folderName = folderName
    .replace('-', ' ')
    .replace(/  +/g, ' ')
    .replace(/[<>:"/\\|?*]+/g, '');
  folderName = folderName.replace(/\s/g, '-');
  const {source = ''} = await invokeGetApi(`/ccadmin/v1/widgets/${repositoryId}/less`, restClient);
  const compileLessResponse = await invokePostApi(
    '/ccadmin/v1/themes/compileLess',
    JSON.stringify({src: source}),
    restClient
  );
  if (compileLessResponse !== undefined) {
    if (compileLessResponse.ok) {
      const widgetCode = await invokeGetApi(`/ccadmin/v1/widgets/${repositoryId}/code`, restClient);
      const widgetCss = getWidgetSpecificCss(compileLessResponse.body.src, `#${widgetCssId}`);
      const webContent = `<style> ${widgetCss} </style> <div id="${widgetCssId}"> ${widgetCode.source}</div>`;
      const pathToFile = `${assetsPath}/components`;
      const indexObject = STRUCTURES.webContentIndexFile;
      Object.assign(indexObject, {notes});
      createFileAtGivenPath('index', pathToFile, indexObject, folderName);
      createFileAtGivenPath('config', pathToFile, {webContent}, folderName);
    }
  }
};

/**
 * Converts a Classic widget to corresponding OSF widget based according to the type of widget (normal or web-content) by creating the required index.json and layout.json files.
 * @param {Object} widget Widget object extracted from the layout region.
 * @param {string} assetsPath Path of the assets directory in the new app.
 * @param {Client} restClient The rest client to get required data from api calls.
 * @returns {string} Name of the component(widget) folder to be created for the component.
 */
const convertWidgetToOSF = async (widget, assetsPath, restClient) => {
  const {repositoryId, displayName, descriptor = {}} = widget;
  const {notes} = await invokeGetApi(`/ccadminui/v1/widgets/${repositoryId}`, restClient);
  let folderName = getComponentNameFromDisplayName(displayName);
  folderName = folderName.toLowerCase();
  folderName = folderName
    .replace('-', ' ')
    .replace(/  +/g, ' ')
    .replace(/[<>:"/\\|?*]+/g, '');
  folderName = folderName.replace(/\s/g, '-');
  if (
    fsExtra.existsSync(`${assetsPath}/components/${folderName}`) &&
    isWidgetCreatedMap.get(folderName) === undefined
  ) {
    if (widgetMap.get(folderName) === undefined) {
      logger.info(___`<- Widget Instance name found in OOTB for ${folderName} ->`);
      widgetMap.set(folderName, `${folderName}-1`);
      logger.info(___`<- New instance for ${folderName} is ${widgetMap.get(folderName)} ->`);
      folderName = widgetMap.get(folderName);
    } else {
      folderName = widgetMap.get(folderName);
    }
  } else {
    isWidgetCreatedMap.set(folderName, true);
  }
  if (descriptor.repositoryId === 'webContent_v2' || descriptor.repositoryId.toString().includes('webContent')) {
    convertWebContentWidgetToOSF(widget, assetsPath, restClient, notes);

    return folderName;
  }
  const pathToFile = `${assetsPath}/components`;
  const indexObject = STRUCTURES.dummyWidgetIndexFile;
  Object.assign(indexObject, {notes});
  createFileAtGivenPath('index', pathToFile, indexObject, folderName);
  createFileAtGivenPath('layout', pathToFile, STRUCTURES.containerLayoutFile, folderName);

  return folderName;
};

/**
 * Calls widget conversion function for each widget present in the flat region and returns the corresponding flat region object for the page.
 * @param {Object} region The region object extracted from layout structure
 * @param {string} assetsPath Path of the assets directory in the new app.
 * @param {Client} restClient The rest client to get required data from api calls.
 * @param {Boolean} isPresentInsideSlotOrStack Flag to check if the region needs to be added to slot or stack.
 * @returns {Object} The converted region object to be added to the new layout.
 */
const convertFlatRegionToOSF = async (region, assetsPath, restClient, isPresentInsideSlotOrStack = false) => {
  const {width, widgets, displayName} = region;
  const componentNames = [];
  for (const widget of widgets) {
    componentNames.push(await convertWidgetToOSF(widget, assetsPath, restClient));
  }
  const flatRegion = {
    components: componentNames,
    width,
    type: 'main'
  };
  const slotOrStackProperties = {
    displayName,
    resources: {
      en: {
        displayName
      }
    }
  };

  return isPresentInsideSlotOrStack ? {...flatRegion, ...slotOrStackProperties} : flatRegion;
};

/**
 * Creates converted index.json and structure.json files for the new stack in the components folder and returns the corresponding stack region object for the page.
 * @param {Object} region The region object extracted from layout structure
 * @param {string} assetsPath Path of the assets directory in the new app.
 * @param {Client} restClient The rest client to get required data from api calls.
 * @returns {Object} The converted region object to be added to the new layout.
 */
const convertStackToOSF = async (region, assetsPath, restClient) => {
  const {name, width, regions} = region;
  let stackName = getFileNameFromDisplayName(name);
  stackName = stackName.toLowerCase();
  stackName = stackName
    .replace('-', ' ')
    .replace(/  +/g, ' ')
    .replace(/[<>:"/\\|?*]+/g, '');
  stackName = stackName.replace(/\s/g, '-');
  if (stackInstancesMap[stackName]) {
    stackInstancesMap[stackName]++;
    stackName = `${stackName}-${stackInstancesMap[stackName]}`;
  } else stackInstancesMap[stackName] = 1;
  const pathToFile = `${assetsPath}/components`;
  const regionsInStack = [];
  for (const region of regions) {
    regionsInStack.push(await convertFlatRegionToOSF(region, assetsPath, restClient, true));
  }
  const structureData = {
    regions: regionsInStack
  };
  const indexData = {
    type: 'PlaceholderStack'
  };
  createFileAtGivenPath('structure', pathToFile, structureData, stackName);
  createFileAtGivenPath('index', pathToFile, indexData, stackName);

  return {
    components: [stackName],
    width,
    type: 'main'
  };
};

/**
 * Creates converted index.json and structure.json files for the new slot in the slots folder and returns the corresponding slot region object for the page.
 * @param {Object} region The region object extracted from layout structure
 * @param {string} assetsPath Path of the assets directory in the new app.
 * @param {Client} restClient The rest client to get required data from api calls.
 * @returns {Object} The converted region object to be added to the new layout.
 */
const convertSlotToOSF = async (region, assetsPath, restClient) => {
  const {name, width, regions, descriptor: {repositoryId} = {}} = region;
  let folderName = getComponentNameFromDisplayName(name);
  folderName = folderName.toLowerCase();
  folderName = folderName
    .replace('-', ' ')
    .replace(/  +/g, ' ')
    .replace(/[<>:"/\\|?*]+/g, '');
  folderName = folderName.replace(/\s/g, '-');
  const pathToFile = `${assetsPath}/slots`;
  const regionsInSlot = [];
  for (const region of regions) {
    regionsInSlot.push(await convertFlatRegionToOSF(region, assetsPath, restClient, true));
  }
  const slotStructure = {
    regions: regionsInSlot
  };
  const indexData = {
    type: repositoryId
  };
  createFileAtGivenPath('structure', pathToFile, slotStructure, folderName);
  createFileAtGivenPath('index', pathToFile, indexData, folderName);

  return {
    displayName: name,
    width,
    resources: {
      en: {
        displayName: name
      }
    },
    components: [],
    slot: folderName,
    type: 'main',
    structure: 'slot'
  };
};

/**
 * Based on the type of region calls the appropriate method to convert the given region from classic to OSF.
 * @param {Object} region The region object extracted from layout structure
 * @param {string} assetsPath Path of the assets directory in the new app.
 * @param {Client} restClient The rest client to get required data from api calls.
 * @returns {Object} The converted region object to be added to the new layout.
 */
const convertRegion = async (region, assetsPath, restClient) => {
  const {structure} = region;
  switch (structure) {
    case structureTypes.SLOT:
      return convertSlotToOSF(region, assetsPath, restClient);
    case structureTypes.STACK:
      return convertStackToOSF(region, assetsPath, restClient);
    case structureTypes.FLAT:
      return convertFlatRegionToOSF(region, assetsPath, restClient);
    default:
      return {};
  }
};

/* PAGE CONVERSION FUNCTIONS */
/**
 * @param {Object} pageDetails Data to be added to the converted page.
 * @param {Object} layout Layout object extracted from the api response.
 * @param {Object} assetsPath Path of the assets directory in the new app.
 * @param {Client} restClient The rest client to get required data from api calls.
 * */
const convertPageToOSF = async (pageDetails, layout, assetsPath, restClient) => {
  const mainRegions = [];
  for (const region of layout.regions) {
    if (region.type === regionTypes.MAIN) {
      mainRegions.push(await convertRegion(region, assetsPath, restClient));
    }
  }

  return {
    ...pageDetails,
    layout: [STRUCTURES.defaultHeaderRegion, ...mainRegions, STRUCTURES.defaultFooterRegion]
  };
};

/**
 * Based on the type of Container present in the Classic app, converts the layout to corresponding OSF app.
 * @param {Object} pageDetails Data to be added to the converted page.
 * @param {Object} layout Layout object extracted from the api response.
 * @param {Object} pageType Type of the page for making corresponding page conversion call.
 * @param {Object} assetsPath Path of the assets directory in the new app.
 * */
const convertPageHavingSpecialContainerToOSF = async (pageDetails, layout, pageType, assetsPath, restClient) => {
  const {regions, displayName} = layout;
  const regionObjArray = [];
  for (const region of regions) {
    if (region.type === regionTypes.MAIN) {
      regionObjArray.push(await convertRegion(region, assetsPath, restClient));
    }
  }
  const fileName = getComponentNameFromDisplayName(displayName);
  // length of containerName should not exceed 50 characters.
  let containerName = fileName.length <= 40 ? `${fileName} Container` : `${fileName} c`;
  containerName = containerName.length > 50 ? fileName : containerName;
  containerName = containerName.toLowerCase();
  containerName = containerName
    .replace('-', ' ')
    .replace(/  +/g, ' ')
    .replace(/[<>:"/\\|?*]+/g, '');
  containerName = containerName.replace(/\s/g, '-');
  let pathToFile = `${assetsPath}/components`;
  const layoutObj = {
    regions: regionObjArray
  };
  createFileAtGivenPath('index', pathToFile, {type: `${pageTypeToSpecialContainerMap[pageType]}`}, containerName);
  createFileAtGivenPath('layout', pathToFile, layoutObj, containerName);

  //Create a container instance
  pathToFile = `${assetsPath}/containers`;
  const containerObj = {
    layout: regionObjArray,
    component: pageTypeToSpecialContainerMap[pageType],
    title: displayName
  };
  createFileAtGivenPath(containerName, pathToFile, containerObj);
  //Add container to page layout
  const mainRegion = {
    components: [containerName],
    width: 12,
    type: 'main'
  };
  let headerRegion = STRUCTURES.defaultHeaderRegion;
  if (pageType === 'checkout') {
    headerRegion = {...headerRegion, slot: 'checkout-header-with-notification-device-slot'};
  }

  return {
    ...pageDetails,
    layout: [headerRegion, mainRegion, STRUCTURES.defaultFooterRegion]
  };
};

/**Method to call the relevant method based on the type of layout and create the respective page.
 * @param {Array<string>} pageLayoutsGroups The array of Classic layouts to be converted.
 * @param {Client} restClient The rest client to get required data from api calls.
 * @param {string} assetsPath The path to the assets folder of the new app.
 * */
const addLayoutsToFile = async (pageLayoutsGroups, restClient, assetsPath) => {
  let convertedLayoutCount = 0;
  for (const pageLayoutsGroup of pageLayoutsGroups) {
    const {pageLayouts, shortName} = pageLayoutsGroup;
    for (const pageLayout of pageLayouts) {
      const {
        pageType,
        layout: {repositoryId}
      } = pageLayout;
      const osfPageDetails = transformPageDetails(pageLayout, shortName);
      const {layout = {}} = await invokeGetApi(`/ccadmin/v1/layouts/${repositoryId}/structure`, restClient);
      let convertedPage;
      // a special container needs to be added for some pages
      if (pageTypeToSpecialContainerMap[pageType]) {
        convertedPage = await convertPageHavingSpecialContainerToOSF(
          osfPageDetails,
          layout,
          pageType,
          assetsPath,
          restClient
        );
      } else convertedPage = await convertPageToOSF(osfPageDetails, layout, assetsPath, restClient);

      if (convertedPage) {
        const pageName = getPageName(pageLayout.layout);
        let fileName = getFileNameFromDisplayName(pageName);
        fileName = fileName.replace(/[<>:"/\\|?*]+/g, '');
        createFileAtGivenPath(fileName, assetsPath, convertedPage, 'pages');
        convertedLayoutCount++;
        logger.info(___`Created layout file ${fileName}.json`);
      }
    }
  }

  return convertedLayoutCount;
};

/**Main conversion method
 * 1. Creates a rest connection to the admin server and gets all the layouts from default app.
 * 2. For each layout, converts the classic layout to respective OSF layout.
 * 3. Depending on whether the layout has a special container present in the pageTypeToSpecialContainerMap,
 * calls the respective method to convert the layout.
 * @param {string} appPath The path to converted app.
 * @param {string} appName The name of the newly created app.
 * @param {string} appServerAdmin The admin server URL used for all requests made by the rest client.
 * @param {string} appKey The admin key used for all requests made by the rest client.
 * */

async function convertClassicAssets(appPath, appName, appServerAdmin, appKey) {
  if (fsExtra.existsSync(appPath)) {
    logger.info(___`Fetching layout information from ${appServerAdmin} `);
    const restClient = await createRestClient(appServerAdmin, appKey, true);
    const {items = []} = await invokeGetApi('/ccadmin/v1/layouts?x-occ-app=default', restClient);
    const assetsPath = path.resolve(`${appPath}/assets/`);
    const totalLayoutCount = items.reduce((count, item) => count + item.pageLayouts.length, 0);
    // Remove existing pages from the created app
    fsExtra.emptyDirSync(`${assetsPath}/pages`);

    //Fetching existing sites information
    const siteItems = await invokeGetApi('/ccadminui/v1/sites', restClient);
    for (const i in siteItems.items) {
      siteURLMap[siteItems.items[i].repositoryId] = siteItems.items[i].productionURL;
    }

    // Conversion Logic starts from here
    logger.info(___`Conversion Started for ${totalLayoutCount} layouts.`);
    const convertedLayoutCount = await addLayoutsToFile(items, restClient, assetsPath);
    logger.info(___`Conversion of ${convertedLayoutCount} layouts is completed.`);

    if (Object.keys(siteURLMap).length > 1) {
      logger.warn(
        ___`The source environment have ${
          Object.keys(siteURLMap).length
        } sites. Make sure these sites are created on the environment where the converted layouts will be seeded to avoid seed errors.`
      );
    }
    restClient.logout();
  } else {
    throw new Error(___`Failed to convert assets. Specified workspace name or app name does not exist.`);
  }
}

module.exports = {convertClassicAssets};
