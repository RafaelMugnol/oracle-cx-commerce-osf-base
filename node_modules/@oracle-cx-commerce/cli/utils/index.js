/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const {exec} = require('child_process');
const {promisify} = require('util');
const logger = require('@oracle-cx-commerce/logger/cli');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: require('path').join(__dirname, './locales')});
const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
const {getMinimumRequiredOCCVersion} = require('@oracle-cx-commerce/occ-metadata');

/**
 * Returns the OCC version from the appServer or appServerAdmin. If the request fails
 * or is otherwise unsuccessful, return undefined rather than throwing an error.
 * @param {Object} options the options passed through the CLI including the server whose version to get
 * @returns {String} occVersion, a string like '20.2', '20.1.1-SNAPSHOT', etc.
 * @throws if it couldn't fetch the version
 */
const getOCCVersion = async (options = {}) => {
  let response;
  try {
    logger.verbose(___`Checking the version of OCC on server: ${options.appServerURL}`);
    const restClient = new Client(options.appServerURL);
    response = await restClient.request({
      method: 'head',
      url: `${options.live ? '/ccstore' : '/ccadmin'}/v1/registry/`,
      responseType: 'json'
    });
  } catch (error) {
    logger.debug(___`getOCCVersion: ${error.message}`);
    response = error.response;
    // If there's no valid response captured, there's no way the function can succeed so throw the original error
    if (!response || !response.headers) {
      throw error;
    }
  }
  if (response && response.headers) {
    const occVersion = response.headers['oraclecommercecloud-version'];
    if (!occVersion) {
      throw new Error(___`Response did not contain 'oraclecommercecloud-version' header`);
    }
    logger.verbose(___`Your current OCC server version is ${occVersion}`);

    return occVersion;
  }
  // If response or response headers were empty, our request failed...
  throw new Error(___`Fetching OCC server version of ${options.appServerURL} failed.`);
};

/**
 * Returns whether the package is from Oracle Commerce or not.
 * @param {string} pkgName the name of the package
 * @returns {boolean} whether the given package name starts with @oracle-cx-commerce or not
 */
const isOracleCommerce = pkgName => {
  return (pkgName ? pkgName : '').startsWith('@oracle-cx-commerce');
};

/**
 * Version numbers are not assumed to be strict sem-ver, and may omit the last digit if it's 0.
 * Additionally, the pre-release tags on either version are ignored.
 * e.g. '20.1' === '20.1.0', '20.1.1-SNAPSHOT' === '20.1.1'
 * @param {String} occVersionFromServer the version returned from the configured OCC server
 * @param {String} minOccFromManifest the minimum required version of OCC as declared by OSF's manifest file
 * @returns {boolean} Whether the occVersionFromServer is greater than or equal
 *     to the minimum OCC version
 * @throws if either parameter is null, undefined, or empty, or contains non-integer
 *     values outside the pre-release tag
 */
const occServerSatisfiesMinVersion = (occVersionFromServer, minOccFromManifest) => {
  if (!occVersionFromServer || !minOccFromManifest) {
    throw new Error(___`Cannot compare null/empty version numbers: ${occVersionFromServer} to ${minOccFromManifest}`);
  }
  // Chop off the pre-release tags
  [occVersionFromServer] = occVersionFromServer.split('-');
  [minOccFromManifest] = minOccFromManifest.split('-');
  // Split two versions by dot into different pieces
  const serverVersion = occVersionFromServer.split('.');
  const manifestVersion = minOccFromManifest.split('.');
  // Compare each piece of the two versions
  for (let i = 0; i < Math.max(manifestVersion.length, serverVersion.length); i++) {
    const manifestDigit = i < manifestVersion.length ? Number(manifestVersion[i]) : 0;
    const serverDigit = i < serverVersion.length ? Number(serverVersion[i]) : 0;
    // If any version is not a number, print the error message
    if (isNaN(manifestDigit) || isNaN(serverDigit)) {
      throw new Error(___`Cannot compare the version numbers. The version number is an unexpected type`);
    }

    if (manifestDigit < serverDigit) {
      return true;
    }
    if (manifestDigit > serverDigit) {
      return false;
    }
    // Manifest and server version are equal on this digit - continue comparison
  }

  // Manifest and server version are completely equal, return true
  return true;
};

/**
 * Prints a logger message after comparing the minimum required OCC version with the OCC version
 * @param {Object} options
 * @returns {boolean} whether the OCC server was determined to be on a minimally-valid version for the given version of OSF
 */
const validateOCCVersion = async options => {
  const oracleCommerceCloudVersion = getMinimumRequiredOCCVersion();
  if (!oracleCommerceCloudVersion) {
    logger.warn(
      ___`Could not compare current OSF version to OCC server version - could not determine current OSF version.`
    );

    return;
  }
  let occVersion;
  try {
    occVersion = await getOCCVersion(options);
  } catch (error) {
    logger.warn(
      ___`Could not compare current OSF version to OCC server version - could not determine OCC server version.`
    );
    logger.debug(error.message);

    return;
  }

  try {
    // Determine if the occ server version satisfies the OSF constraint.
    // Log Verbose if so, Warn if not.
    const result = occServerSatisfiesMinVersion(occVersion, oracleCommerceCloudVersion);
    const log = result ? logger.verbose : logger.warn;
    log(___`The minimum required version is (${oracleCommerceCloudVersion}), OCC version is (${occVersion})`);

    return result;
  } catch (error) {
    logger.error(
      ___`Cannot compare the OSF-OCC version numbers. One of the version numbers is an unexpected type: ${occVersion}, ${oracleCommerceCloudVersion}`
    );

    return false;
  }
};

/**
 * @returns {Promise<string>} A string containing the registry from which @oracle-cx-commerce packages
 *    are configured to be fetched. Note that the url returned will end with '/'
 * @throws if no such registry is configured with yarn or the yarn command fails.
 */
const getOCCRegistry = async () => {
  const registry = (await promisify(exec)('yarn config get @oracle-cx-commerce:registry')).stdout.toString().trim();
  if (!/https?:\/\//.test(registry)) {
    // Invalid registry url, it should start with http or https...
    throw new Error(___`Unable to determine @oracle-cx-commerce registry from yarn settings. Got ${registry}`);
  }

  return registry.endsWith('/') ? registry : `${registry}/`;
};

module.exports = {getOCCVersion, validateOCCVersion, isOracleCommerce, getOCCRegistry, occServerSatisfiesMinVersion};
