/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {
  createCommaSeparatedStringFromArray,
  getAssetLanguageHeader,
  populateError,
  populateFieldParams
} from '@oracle-cx-commerce/endpoints/utils';
import {createEndpoint, getBodyAsJson} from '@oracle-cx-commerce/endpoints/factory';
import {getCategoryIdForCurrentPage, getPage} from '@oracle-cx-commerce/commerce-utils/selector';
import {transformProductsForListing} from '@oracle-cx-commerce/endpoints/utils/transform';

export const processInput = (
  {useCurrentPageForCollectionId = false, productIds, search, priceListGroupId, pageId, categoryId, ...rest},
  state
) => {
  console.assert(pageId, 'moreProducts requires a page ID');

  const calculatedCategoryId = useCurrentPageForCollectionId ? getCategoryIdForCurrentPage(state) : categoryId;

  return {
    headers: getAssetLanguageHeader(rest),
    params: [],
    query: {
      categoryId: calculatedCategoryId,
      productIds: createCommaSeparatedStringFromArray(productIds),
      q: search,
      storePriceListGroupId: priceListGroupId,
      ...rest,
      ...populateFieldParams(rest)
    }
  };
};

export const processOutput = async (response, state, {pageId}) => {
  const json = await getBodyAsJson(response);
  const page = getPage(state, {pageId});
  delete json.autoWrap;
  delete json.links;

  if (response.ok) {
    const prevProducts = state.pageRepository.pages[pageId].items;
    const prevOffset = state.pageRepository.pages[pageId].offset;

    const transformedProducts = transformProductsForListing(json, pageId, page);

    transformedProducts.pageRepository.pages[pageId].items = prevProducts.concat(
      transformedProducts.pageRepository.pages[pageId].items
    );
    transformedProducts.pageRepository.pages[pageId].offset =
      transformedProducts.pageRepository.pages[pageId].offset < prevOffset
        ? transformedProducts.pageRepository.pages[pageId].offset
        : prevOffset;

    return transformedProducts;
  }

  return populateError(response, json);
};

export default createEndpoint('moreProducts', {
  processInput,
  processOutput
});
