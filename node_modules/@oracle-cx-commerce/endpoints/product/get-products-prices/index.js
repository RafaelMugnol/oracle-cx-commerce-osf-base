/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {createEndpoint, getBodyAsJson} from '@oracle-cx-commerce/endpoints/factory';
// import {convertToSkuMap} from '@oracle-cx-commerce/endpoints/product/utils';
import {populateError} from '@oracle-cx-commerce/endpoints/utils';

/**
 * SKUs arrive in a number of different ways from the server.  This function converts those into a
 * common format.
 *
 * @param input an array of SKUs, or an object containing an array of child SKUs, or a single SKU.
 * @returns {*} a map keyed by SKU IDs, containing SKU objects.
 */
export const convertToSkuMap = input => {
  if (!input) {
    return {};
  }
  if (input.skuId || input.repositoryId) {
    return {[input.skuId || input.repositoryId]: input};
  }

  if (!Array.isArray(input)) {
    return {};
  }

  if (input.length > 0 && input[0].childSKUs) {
    const productSkuLists = input.map(subArray => convertToSkuMap(subArray.childSKUs));

    return Object.assign(...productSkuLists, {});
  }

  return input.reduce((current, item) => {
    current[item.skuId || item.repositoryId] = item;

    return current;
  }, {});
};

/**
 * Normalizes the output from the getAllProductsPrices endpoint.
 *
 * @param skuPrices an array of SKU prices inside an array of products.
 * @returns the skuPrices normalized within the priceRepository data structure.
 */
const normalizePriceOutput = skuPrices => {
  const prices = skuPrices.reduce(
    (current, productInfo) => {
      const productIdToPriceInfo = Object.entries(productInfo)[0];
      const priceData = productIdToPriceInfo[1];
      const skuPricesBySkuId = convertToSkuMap(priceData.skuPrices);

      for (const entry of Object.entries(skuPricesBySkuId)) {
        const [id, obj] = entry;
        current.skus[id] = obj;
      }

      // instead of deleting skuPrices property from priceData, destructure it and separate it out
      const {skuPrices: skuPricesData, ...deltaPriceData} = priceData;
      current.products[productIdToPriceInfo[0]] = deltaPriceData;

      return current;
    },
    {skus: {}, products: {}}
  );

  return {priceRepository: {...prices}};
};

export const processInput = payload => {
  console.assert(payload.productIds, 'getAllProductsPrices requires an array of product IDs.');

  return {query: {ids: payload.productIds}};
};

export const processOutput = async response => {
  const json = await getBodyAsJson(response);

  return response.ok ? normalizePriceOutput(json.items) : populateError(response, json);
};

export default createEndpoint('getAllProductsPrices', {
  processInput,
  processOutput
});
