/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {isEmptyObject, isObject} from '@oracle-cx-commerce/utils/generic';
import {getRequestContext, getCurrentProduct} from '@oracle-cx-commerce/commerce-utils/selector';

import {sortQuery} from '@oracle-cx-commerce/endpoints/utils';

/**
 * Adds an option to the sorted options
 * @param {Array} sortedOptions sortedOptions
 * @param {Object} optionValueMap
 * @param {String} variant
 */
const addSortedOption = (sortedOptions, optionValueMap, variant) => {
  if (Object.prototype.hasOwnProperty.call(optionValueMap, variant)) {
    sortedOptions.push({name: variant, value: optionValueMap[variant], disabled: null});
  }
};

/**
 * Sort and Map options based on product level ordering specified
 * @param {Object} optionValueMap
 * @param {Array} order sortingOrder
 * @return {Array} sorted options
 * @type String
 */
const sortAndMapOptions = (optionValueMap, order = []) => {
  const sortedOptions = [];
  if (order.length > 0) {
    for (const variant of order) {
      addSortedOption(sortedOptions, optionValueMap, variant);
    }
  } else {
    for (const variant in optionValueMap) {
      addSortedOption(sortedOptions, optionValueMap, variant);
    }
  }

  return sortedOptions;
};

/**
 * Get the listingVariantInfo from productVariantOptions
 * @param {Object} productVariantOptions the product variant options
 * @return {Object} the listingVariantInfo
 */
const getListingVariantInfo = ({productVariantOptions = []}) => {
  const skuVariantKeys = [];
  let listingVariantInfo = {};

  for (const productVariantOption of productVariantOptions) {
    const {mapKeyPropertyAttribute, listingVariant, optionId, optionValueMap} = productVariantOption;
    skuVariantKeys.push(mapKeyPropertyAttribute);
    if (listingVariant) {
      listingVariantInfo = {
        listingVariantKey: optionId,
        listingVariantKeyId: mapKeyPropertyAttribute,
        listingVariantOptionValueMap: optionValueMap
      };
    }
  }

  return {
    ...listingVariantInfo,
    skuVariantKeys
  };
};

/**
 * Build up a map of images for each listing variant option, in the case of style based product
 * @param {Object} product
 * @return {String} listingVariantImageMetadata
 */
const buildListingVariantImageMetadata = ({
  listingVariantKey,
  listingVariantKeyId,
  childSKUs = [],
  listingVariantOptionValueMap = {},
  product: {
    thumbImageURLs = [],
    smallImageURLs = [],
    mediumImageURLs = [],
    largeImageURLs = [],
    fullImageURLs = [],
    sourceImageURLs = [],
    primaryThumbImageURL,
    primarySmallImageURL,
    primaryMediumImageURL,
    primaryLargeImageURL,
    primaryFullImageURL
  }
}) => {
  if (!listingVariantKey) {
    return null;
  }

  const listingVariantImages = {};

  Object.entries(listingVariantOptionValueMap).forEach(([key, value]) => {
    for (const childSKU of childSKUs) {
      if (childSKU.productListingSku && childSKU[listingVariantKey] === key) {
        const {
          thumbImageURLs: skuThumbImageURLs = [],
          smallImageURLs: skuSmallImageURLs = [],
          mediumImageURLs: skuMediumImageURLs = [],
          largeImageURLs: skuLargeImageURLs = [],
          fullImageURLs: skuFullImageURLs = [],
          sourceImageURLs: skuSourceImageURLs = [],
          primaryThumbImageURL: skuPrimaryThumbImageURL = primaryThumbImageURL,
          primarySmallImageURL: skuPrimarySmallImageURL = primarySmallImageURL,
          primaryMediumImageURL: skuPrimaryMediumImageURL = primaryMediumImageURL,
          primaryLargeImageURL: skuPrimaryLargeImageURL = primaryLargeImageURL,
          primaryFullImageURL: skuPrimaryFullImageURL = primaryFullImageURL
        } = childSKU;

        listingVariantImages[`${listingVariantKeyId}=${value}`] = {
          thumbImageURLs: [...skuThumbImageURLs, ...thumbImageURLs],
          smallImageURLs: [...skuSmallImageURLs, ...smallImageURLs],
          mediumImageURLs: [...skuMediumImageURLs, ...mediumImageURLs],
          largeImageURLs: [...skuLargeImageURLs, ...largeImageURLs],
          fullImageURLs: [...skuFullImageURLs, ...fullImageURLs],
          sourceImageURLs: [...skuSourceImageURLs, ...sourceImageURLs],
          primaryThumbImageURL: skuPrimaryThumbImageURL,
          primarySmallImageURL: skuPrimarySmallImageURL,
          primaryMediumImageURL: skuPrimaryMediumImageURL,
          primaryLargeImageURL: skuPrimaryLargeImageURL,
          primaryFullImageURL: skuPrimaryFullImageURL
        };
      }
    }
  });

  return listingVariantImages;
};

/**
 * Returns link information for the next set of products, based on the responses
 * current offset and limit.
 *
 * @param {*} response the product listing response.
 * @returns            a query string for the next set of products.
 */
const next = response => {
  if (response.offset + response.limit < response.totalResults) {
    return `?offset=${response.offset + response.limit}&limit=${response.limit}${sortQuery(response)}`;
  }
};

/**
 *  Returns link information for the previous set of products.
 *
 * @param {*} response the product listing response.
 * @returns a query string for the previous set of products
 */
const prev = response => {
  const {offset, limit} = response;
  const calculatedOffset = offset - limit > 0 ? offset - limit : 0;

  return `?offset=${calculatedOffset}&limit=${response.limit}${sortQuery(response)}`;
};

/**
 * Returns an array of product ids from products page response.
 *
 * @param {*} response
 * @returns list of products ids
 */
const mapProducts = response => {
  if (!isObject(response) || isEmptyObject(response)) {
    return {};
  }

  return response.items.map(product => {
    return product.id;
  });
};

/**
 * Build up a product variant option object that can be used to seed the data in the component
 *
 * @param {Array} productVariantOptions the product variant options
 * @param {Object} variantValuesOrder variantValuesOrder at product level
 * @param {Array} productTypeVariants variants at productType
 * @return {Object} A product variant object map
 */
export const getVariantOptionsSeed = ({
  productVariantOptions = [],
  variantValuesOrder = {},
  productTypeVariants = []
} = {}) => {
  // Get ProductTypeLevel variants order
  const productTypeLevelVariantOrder = {};
  for (const variant of productTypeVariants) {
    productTypeLevelVariantOrder[variant.id] = variant.values;
  }

  return (
    productVariantOptions.reduce((current, option) => {
      const {mapKeyPropertyAttribute, optionId, optionName, optionValueMap} = option;
      //Get product level order
      const productLevelOrder = variantValuesOrder[optionId];

      // sort the options, based on provided productLevelOrder or ProductTypeLevel order
      const options = sortAndMapOptions(
        optionValueMap,
        productLevelOrder ? productLevelOrder : productTypeLevelVariantOrder[optionId]
      );

      current[mapKeyPropertyAttribute] = {
        optionName,
        optionId,
        selectedValue: null,
        options
      };

      return current;
    }, {}) || {}
  );
};

/**
 * Build a variant to sku array that can be used to quickly find a sku id for a variant combination
 * i.e. [{sku-WomensApparel_color=2;sku-WomensApparel_size=0;: "sku12345"}]
 *
 *  Build up a string of all product variant combinations, separated by a pipe.
 * This will be used to disable invalid combinations on the UI
 * i.e. sku-WomensApparel_color=16;sku-WomensApparel_size=0;|sku-WomensApparel_color=16;sku-WomensApparel_size=1;

 * @param {Array} childSKUs the child skus for a product
 * @param {Array} skuVariantKeys the sku variant options
 * @return {Object} object.variantToSkuLookup - A product variant to sku lookup object
 *                  object.variantOptionPermutations - the variant permutations
 */
const generateVariantOptionsAndPermutations = ({childSKUs = [], skuVariantKeys = []}) => {
  const variantToSkuLookup = {};
  let variantOptionPermutations = [];

  for (const {dynamicPropertyMapLong, repositoryId} of childSKUs) {
    if (dynamicPropertyMapLong) {
      const mappedOptions = [];

      for (const key of skuVariantKeys) {
        const value = dynamicPropertyMapLong[key];
        mappedOptions.push(`${key}=${value};`);
      }

      const compositeVariantKey = mappedOptions.join('');
      // build variant options permutations and sku lookup objects
      variantOptionPermutations.push(compositeVariantKey);
      variantToSkuLookup[compositeVariantKey] = repositoryId;
    }
  }

  // create the permutations string, splitting the composite keys by a pipe
  variantOptionPermutations = variantOptionPermutations.join('|');

  return {
    variantToSkuLookup,
    variantOptionPermutations
  };
};

/**
 * Transforms a single product into an exploded representation of all its data within the application's
 * storage format.  This includes relatedProducts and child SKUS.
 *
 * @type {import('.').Transform}
 * @param product the product to be transformed
 * @param state the state to be updated
 * @returns the product(s) and sku(s) within the 'catalogRepository' store item
 */
export const transformProduct = (product, state) => {
  if (!isObject(product) || !product.repositoryId) {
    return {};
  }

  const result = {catalogRepository: {skus: {}, products: {}}};
  const {childSKUs = [], route, productVariantOptions, variantValuesOrder} = product;
  // if a variant/style based display then the child skus for a particular product can have specific images
  // build up the images for use on UI
  const {
    listingVariantKey = null,
    listingVariantKeyId = null,
    listingVariantOptionValueMap = {},
    skuVariantKeys
  } = getListingVariantInfo({
    productVariantOptions: productVariantOptions || []
  });
  const listingVariantImages = buildListingVariantImageMetadata({
    listingVariantKey,
    listingVariantKeyId,
    childSKUs: [...childSKUs],
    listingVariantOptionValueMap,
    product
  });

  // add the product information
  // add the variant options and permutations
  // add the variant options seed object
  const transformedProduct = {
    ...product,
    // Remove leading '/' from route so it resolves relative to document baseURI.
    route: route ? route.replace(/^\//, '') : route,
    ...generateVariantOptionsAndPermutations({childSKUs, skuVariantKeys}),
    variantOptionsSeed: getVariantOptionsSeed({productVariantOptions: productVariantOptions || [], variantValuesOrder}),
    listingVariantValues: listingVariantImages,
    listingVariantKeyId
  };

  // Pull out the child SKUs and store them separately, saving only the IDs in the product itself.
  // && Array.isArray(product.childSKUs) && product.childSKUs.length > 0 && (typeof product.childSKUs[0] !== 'string')) {
  if (childSKUs) {
    for (const sku of childSKUs) {
      result.catalogRepository.skus[sku.repositoryId] = sku;
    }
    transformedProduct.childSKUs = childSKUs.map(childSku => childSku.repositoryId);
  }

  // Pull out the related products and store them as peers of this one.
  if (transformedProduct.relatedProducts) {
    for (const relatedProduct of product.relatedProducts) {
      const {id} = relatedProduct;
      const transformed = transformProduct(relatedProduct);
      /* Checking whether the relatedProduct when equal to the currentPageId then preserve the variantOptionPermutations, variantOptionsSeed, variantToSkuLookup from state.
       * This is done as the list Product call for recommended product will not return the product variant option and will update the state with out the above property.
       * Thus the details about the product on PDP page will not be displayed correctly */
      if (state && getRequestContext(state).productId === id && transformed.catalogRepository.products[id]) {
        const {variantOptionPermutations, variantOptionsSeed, variantToSkuLookup} = getCurrentProduct(state);
        if (variantOptionPermutations) {
          transformed.catalogRepository.products[id].variantOptionPermutations = variantOptionPermutations;
        }
        if (variantOptionsSeed) {
          transformed.catalogRepository.products[id].variantOptionsSeed = variantOptionsSeed;
        }
        if (variantToSkuLookup) {
          transformed.catalogRepository.products[id].variantToSkuLookup = variantToSkuLookup;
        }
      }
      result.catalogRepository.products = {
        ...result.catalogRepository.products,
        ...transformed.catalogRepository.products
      };
      result.catalogRepository.skus = {...result.catalogRepository.skus, ...transformed.catalogRepository.skus};
    }
    transformedProduct.relatedProducts = product.relatedProducts.map(relatedProduct => relatedProduct.repositoryId);
  }

  result.catalogRepository.products[transformedProduct.repositoryId] = transformedProduct;

  return result;
};

/**
 * Transforms list of products into an exploded representation of all its data within the application's
 * storage format.  This includes relatedProducts and child SKUS.
 *
 * @type {import('.').Transform}
 * @param {*} response
 * @param state the state to be updated
 * @returns the product(s) and sku(s) within the 'catalogRepository' store item
 */
export const transformProducts = (response, state) => {
  if (!isObject(response) || isEmptyObject(response)) {
    return {};
  }

  const result = {catalogRepository: {products: {}, skus: {}}};
  const products = response.items;
  for (const product of products) {
    const transformedProduct = transformProduct(product, state);
    result.catalogRepository.products = {
      ...result.catalogRepository.products,
      ...transformedProduct.catalogRepository.products
    };
    result.catalogRepository.skus = {...result.catalogRepository.skus, ...transformedProduct.catalogRepository.skus};
  }

  return result;
};

/**
 * Transforms list of Gift products into an exploded representation of all its data within the application's
 * storage format.  This includes relatedProducts and child SKUS.
 *
 * @type {import('.').Transform}
 * @param {*} response
 * @returns the product(s) and sku(s) within the 'catalogRepository' store item
 */
export const transformGiftPurchaseChoicesProducts = response => {
  if (!isObject(response) || isEmptyObject(response)) {
    return {};
  }

  const result = {catalogRepository: {products: {}, skus: {}}};
  const products = response.items;
  for (const productData of products) {
    //productData contains product and sku details of the gift
    const transformedProduct = transformProduct(productData.product);
    result.catalogRepository.products = {
      ...result.catalogRepository.products,
      ...transformedProduct.catalogRepository.products
    };
    result.catalogRepository.skus = {...result.catalogRepository.skus, ...transformedProduct.catalogRepository.skus};
  }

  return result;
};

/**
 * Transforms products page response into an exploded representation of all its data within the application's
 * storage format.
 *
 * @param {*} response
 * @param {*} pageId
 * @param {*} page
 * @returns the product(s) and sku(s) within the 'catalogRepository' store item and page within pageRepository
 */
export const transformProductsForListing = (response, pageId, page) => {
  if (!isObject(response) || isEmptyObject(response)) {
    return {};
  }
  if (!response.items) {
    return {};
  }
  const items = mapProducts(response);

  return {
    pageRepository: {
      pages: {
        [pageId]: {
          items,
          offset: response.offset,
          expandedOffset: response.offset,
          limit: response.limit,
          total: response.totalResults,
          totalExpandedResults: response.totalExpandedResults,
          self: `?offset=${response.offset}&limit=${response.limit}${sortQuery(response.sort)}`,
          ...(response.totalResults > items.length && {next: next(response)}),
          ...(response.offset > 0 && {prev: prev(response)}),
          categoryId: page.categoryId || page.context.contextId,
          sort: response.sort
        }
      }
    },
    ...transformProducts(response)
  };
};

/**
 * Transforms the sku stockStatus response format to set into the inventoryRepository.
 *
 * @param skuStockStatus the sku stockStatus format as returned by the endpoint.
 * @returns the transformed stock statuses.
 */
export const transformSkuStockStatusResponse = skuStockStatus => {
  if (!isObject(skuStockStatus) || isEmptyObject(skuStockStatus)) {
    return {};
  }
  const locationId = skuStockStatus.locationId ? skuStockStatus.locationId : 'default';
  const skuStockDetails = {};
  skuStockDetails[skuStockStatus.catRefId] = {};
  skuStockDetails[skuStockStatus.catRefId][locationId] = {...skuStockStatus};

  return skuStockDetails;
};

export const transformProductSkuStockStatusResponse = productSkuStockStatus => {
  if (!isObject(productSkuStockStatus) || isEmptyObject(productSkuStockStatus)) {
    return {};
  }
  const productStockStatus = {};
  const locationId = productSkuStockStatus.locationId ? productSkuStockStatus.locationId : 'default';
  //productId is not available in product scope, so getting from sku level
  const {productId} = productSkuStockStatus.productSkuInventoryDetails[0];
  //Product state is being prepared below
  const {productSkuInventoryDetails, productSkuInventoryStatus, ...productStockDetails} = productSkuStockStatus;
  productStockStatus[productId] = {};
  productStockStatus[productId][locationId] = {
    ...productStockDetails
  };

  return productStockStatus;
};

/**
 * Transforms the stockStatuses endpoint response format into the inventoryRepository format.
 *
 * @param response the stockStatuses format as returned by the endpoint.
 * @returns the transformed stock statuses.
 */
export const transformStockStatusResponse = (response = []) => {
  if (response.length === 0) {
    return {};
  }
  const productsStockStatus = {};
  const skusStockStatus = response.reduce((current, item) => {
    //Condition to check whether sku inventory details are present when only product is given as param
    if (item.productSkuInventoryDetails && item.productSkuInventoryDetails.length > 0) {
      const {productId} = item.productSkuInventoryDetails[0];
      productsStockStatus[productId] = {
        ...productsStockStatus[productId],
        ...transformProductSkuStockStatusResponse(item)[productId]
      };
      item.productSkuInventoryDetails.forEach(skuStockStatus => {
        //When expandStockDetails flag is false, location and stockStatus are not present in sku level
        skuStockStatus = {...skuStockStatus, locationId: item.locationId, stockStatus: item[skuStockStatus.catRefId]};
        current[skuStockStatus.catRefId] = {
          ...current[skuStockStatus.catRefId],
          ...transformSkuStockStatusResponse(skuStockStatus)[skuStockStatus.catRefId]
        };
      });
    }
    //When product:sku is given as params
    else {
      current[item.catRefId] = {...current[item.catRefId], ...transformSkuStockStatusResponse(item)[item.catRefId]};
    }

    return current;
  }, {});

  return {
    inventoryRepository: {
      skus: {
        ...skusStockStatus
      },
      products: {
        ...productsStockStatus
      }
    }
  };
};
