/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {arrayToMap, isEmptyObject, isObject} from '@oracle-cx-commerce/utils/generic';
import {getCurrentOrder, getCurrentOrderId} from '@oracle-cx-commerce/commerce-utils/selector';

/**
 * Returns Client repository structure
 * @returns {Object} Client repository structure in state
 */
const clientRepo = {
  clientRepository: {
    context: {}
  }
};

/**
 * Transforms Order properties
 *  * Transforms commerceItems array to Object with id as key
 *  * Transforms ShippingGroups array to Object with shippingGroupId as key
 *  * Transforms Payments array to Object with PaymentGroupId as key
 * @param {Object} order
 * @returns {Object} transformed order object
 */
export const transformOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }

  const commerceItems = arrayToMap(order.items, 'id');
  delete order.items;

  const paymentGroups = arrayToMap(order.payments, 'paymentGroupId');
  delete order.payments;

  const shippingGroups = arrayToMap(order.shippingGroups, 'shippingGroupId');

  const result = {
    ...order,
    commerceItems,
    shippingGroups,
    paymentGroups
  };

  return result;
};

/**
 * Clean up Gift With Purchase Message and Promotion Up sell Message
 * And populate changes from Order API during update and create calls
 * @param {Object} pricingMessages
 * @param {Object} id
 * @param {Object} result
 */
export const populatePricingMessage = (pricingMessages, id, result) => {
  if (!id) {
    return {};
  }

  if (
    !isObject(pricingMessages) ||
    isEmptyObject(pricingMessages) ||
    (pricingMessages && !pricingMessages.giftWithPurchaseMessages)
  ) {
    result.orderRepository.giftWithPurchaseMessages = {};
    result.orderRepository.giftWithPurchaseMessages[id] = {};
    result.orderRepository.giftWithPurchaseMessages[id].messages = [];
  }

  if (
    !isObject(pricingMessages) ||
    isEmptyObject(pricingMessages) ||
    (pricingMessages && !pricingMessages.promotionUpsellMessages)
  ) {
    result.orderRepository.promotionUpsellMessages = {};
    result.orderRepository.promotionUpsellMessages[id] = {};
    result.orderRepository.promotionUpsellMessages[id].messages = [];
  }

  if (pricingMessages && pricingMessages.promotionUpsellMessages) {
    if (!result.orderRepository.promotionUpsellMessages) {
      result.orderRepository.promotionUpsellMessages = {};
    }
    if (!result.orderRepository.promotionUpsellMessages[id]) {
      result.orderRepository.promotionUpsellMessages[id] = {};
      result.orderRepository.promotionUpsellMessages[id].messages = [];
    }
    result.orderRepository.promotionUpsellMessages[id].messages = pricingMessages.promotionUpsellMessages;
  }

  if (pricingMessages && pricingMessages.giftWithPurchaseMessages) {
    if (!result.orderRepository.giftWithPurchaseMessages) {
      result.orderRepository.giftWithPurchaseMessages = {};
    }
    if (!result.orderRepository.giftWithPurchaseMessages[id]) {
      result.orderRepository.giftWithPurchaseMessages[id] = {};
      result.orderRepository.giftWithPurchaseMessages[id].messages = [];
    }
    result.orderRepository.giftWithPurchaseMessages[id].messages = pricingMessages.giftWithPurchaseMessages;
  }
};

// /**
//  * Transforms orders array to an object with id property as key
//  * and transforms each in the array.
//  * @param {Object} orders
//  * @returns {Object} transformed orders
//  */
// export const transformOrders = (orders = []) => {
//   console.assert(!Array.isArray(orders), 'orders must be array!!!');

//   return arrayToMap(orders, 'id', transformOrder);
// };

// /**
//  * Transforms orders array into Order Object like structure and
//  * populate in the order repository structure
//  * @param {Object} orders
//  * @returns {Object} Orders include in the order repository
//  */
// // TODO-Rename this method
// export const populateOrders = (orders = []) => {
//   const result = orderRepository;

//   const ordersObj = transformOrders(orders);
//   result.orderRepository.orders = {...ordersObj};

//   return result;
// };

/**
 * Transform order from the response and populate order object in order repository structure.
 * @param {Object} order
 * @returns {Object} Order included in the order repository
 */
// TODO-Rename this method
export const populateOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }

  const result = {
    orderRepository: {
      orders: {}
    }
  };
  const {pricingMessages, ...orderRest} = order;

  const orderObj = transformOrder(orderRest);
  const orderId = order.id || order.orderId || order.repositoryId;
  result.orderRepository.orders[orderId] = {...orderObj};
  populatePricingMessage(pricingMessages, orderId, result);

  return result;
};

/*
 * Clear the current order id from session object and include
 * uuid in request on successful order submission
 *
 * @returns {Object} Order as null and uuid in request object in the client repository
 */
export const updateSessionOnOrderSubmission = order => {
  if (!order) {
    return {};
  }

  const result = clientRepo;
  result.clientRepository.context.session = {order: null};
  result.clientRepository.context.request = {uuid: order.uuid};

  return result;
};

/*
 * Clear the current order id from request object and include
 * uuid in request on successful order submission
 *
 * @returns {Object} Order as '' and uuid in request object in the client repository
 */
export const updateRequestContext = order => {
  if (!order) {
    return {};
  }

  return {
    clientRepository: {
      context: {
        request: {
          uuid: order.uuid,
          order: ''
        }
      }
    }
  };
};

/*
 * Clear the current order id from session object
 * on successful quote submission
 *
 * @returns {Object} Order as null request object in the client repository
 */
export const clearCurrentOrderFromSession = order => {
  if (!order) {
    return {};
  }

  return {
    clientRepository: {
      context: {
        session: {
          order: ''
        }
      }
    }
  };
};

/**
 * Populated current order id in session object
 * @param {String} currentOrderId
 * @returns {Object} Order id included in the client repository
 */
// TODO-Rename this method
export const populateCurrentOrderId = currentOrderId => {
  if (!currentOrderId) {
    return {};
  }

  return {
    clientRepository: {
      context: {
        session: {
          order: currentOrderId
        }
      }
    }
  };
};

/**
 * Populates pricingMessages in request object for empty Cart.
 * @param {Object} pricingMessages.
 * @param {id} orderId
 * @returns {Object} pricingMessages are included in the orderRepository.
 */
export const populatePricingMessagesForEmptyCart = pricingMessages => {
  if (!(pricingMessages && pricingMessages.promotionUpsellMessages)) {
    return {};
  }
  const {promotionUpsellMessages} = pricingMessages;

  return {
    orderRepository: {
      promotionUpsellMessages: {
        unqualifiedUpsellMessages: {
          messages: promotionUpsellMessages
        }
      }
    }
  };
};

export const addUUIDToContext = order => {
  if (!order) {
    return {};
  }

  const result = clientRepo;
  result.clientRepository.context.uuidToOrder = {};
  result.clientRepository.context.uuidToOrder[order.uuid] = order.id;

  return result;
};

/**
 * Transform order from the confirmation response and populate order object in order repository structure.
 *
 * @param {*} order
 */
export const populateConfirmation = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }
  const result = {...populateOrder(order), ...addUUIDToContext(order)};

  return result;
};

/**
 * Default exclude params for order endpoints.
 * These are set of properties on response which are not useful.
 */
const DEFAULT_EXCLUDE_PARAMS_FOR_GET_ORDER = 'shippingGroup,shippingMethod,shippingAddress';

/**
 * Default exclude params for order endpoints.
 * These are set of properties on response which are not useful.
 */
const DEFAULT_EXCLUDE_PARAMS_FOR_CANCEL_ORDER = 'order.shippingGroup,order.shippingMethod,order.shippingAddress';
/**
 * Default exclude params for order endpoints.
 * These are set of properties on response which are not useful.
 */
const DEFAULT_EXCLUDE_PARAMS_FOR_GET_INCOMPLETE_ORDER = 'shippingMethod';

/**
 * Default exclude params for order subResource endpoints.
 * These are set of properties on response which are not useful.
 */
const DEFAULT_EXCLUDE_PARAMS_FOR_SUBRESOURCE_ENDPOINTS =
  'embedded.order.shippingGroup,embedded.order.shippingMethod,embedded.order.shippingAddress';

/**
 * Default exclude params for copy order endpoint.
 * These are set of properties on response which are not useful.
 */
const DEFAULT_EXCLUDE_PARAMS_FOR_COPY_ORDER = 'shippingMethod,shippingAddress';

/**
 * Merges the default exclude params with the exclude params from the query params
 * @param {string} queryParams
 * @returns {string}  Merged exclude params from query string with default exclude params
 */
export const mergeExcludeParams = (queryParams, pEndpointId) => {
  let excludeParams = '';
  switch (pEndpointId) {
    case 'getOrder':
      excludeParams = DEFAULT_EXCLUDE_PARAMS_FOR_GET_ORDER;
      break;
    case 'getIncompleteOrder':
      excludeParams = DEFAULT_EXCLUDE_PARAMS_FOR_GET_INCOMPLETE_ORDER;
      break;
    case 'subResourceEndpoint':
      excludeParams = DEFAULT_EXCLUDE_PARAMS_FOR_SUBRESOURCE_ENDPOINTS;
      break;
    case 'cancelOrder':
      excludeParams = DEFAULT_EXCLUDE_PARAMS_FOR_CANCEL_ORDER;
      break;
    case 'copyOrder':
      excludeParams = DEFAULT_EXCLUDE_PARAMS_FOR_COPY_ORDER;
      break;
    default:
      excludeParams = '';
  }

  if (!isObject(queryParams) || isEmptyObject(queryParams)) {
    return excludeParams;
  }

  if (queryParams.exclude) {
    // It might result into some duplicate params but doe snot have any side effect on serve. so leaving them as-is
    excludeParams += `,${queryParams.exclude}`;
    delete queryParams.exclude;
  }

  return excludeParams;
};

/**
 * Transforms getOrder endpoint response to generic form
 * @param {Object} order
 * @returns {Object}  Order included in the order repository
 */
export const transformGetOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }
  order.items = order.order ? order.order.items : [];
  if (isObject(order.order)) {
    delete order.order.items;
  }
  const otherProps = order.order ? order.order : {};
  if (isObject(order.order)) {
    delete order.order;
  }

  return populateOrder({...order, ...otherProps});
};

/**
 * Transforms incomplete order endpoints response to generic form
 * @param {Object} order
 * @returns {Object}  Order included in the order repository
 */
export const transformIncompleteOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }

  const {shoppingCart, orderId, id = orderId, ...orderRest} = order;
  const {items = [], ...shoppingCartRest} = shoppingCart || {};

  const newOrder = {...orderRest, items, id};

  return {
    ...populateOrder({...newOrder, ...shoppingCartRest}),
    ...populateCurrentOrderId(id)
  };
};

/**
 * Switches incomplete orderId in client repository.
 * @param {Object} order
 * @returns {Object}  OrderId included in the client repository
 */
export const switchIncompleteOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }

  const {orderId} = order;

  return {
    ...populateCurrentOrderId(orderId)
  };
};

/**
 * delete incomplete order from orderRepository.
 * @param {Object} order
 * @returns {Object}  Order included in the order repository
 */
export const deleteIncompleteOrder = (orderResponse, state) => {
  if (!isObject(orderResponse) || isEmptyObject(orderResponse)) {
    return {};
  }
  const result = clientRepo;
  const order = getCurrentOrderId(state) === orderResponse.orderId ? '' : getCurrentOrderId(state);

  result.clientRepository.context.session = {order};

  return {
    ...result
  };
};

/**
 * Transforms initiate cancel order endpoints response to generic form
 * @param {Object} order
 * @returns {Object}  Order included in the order repository
 */
export const transformInitiateCancelOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }

  // transforming the order response so that transformOrder method could be used as is.
  const {commerceItems: items, shippingGroups, paymentGroups: payments, ...orderRest} = order.cancelOrder;

  // Transform Order uses shippingGroupId to change the structure instead of id in the response.
  shippingGroups.forEach(shippingGroup => {
    shippingGroup.shippingGroupId = shippingGroup.id;
    delete shippingGroup.id;
  });

  const formattedOrder = {items, shippingGroups, payments, ...orderRest};

  return populateOrder(formattedOrder);
};

/**
 * Transforms embedded order json response to generic form
 * @param {Object} order
 * @returns {Object}  Order included in the order repository
 */
export const transformEmbeddedOrder = pJson => {
  if (!isObject(pJson) || isEmptyObject(pJson)) {
    return {};
  }

  if (!pJson.embedded || !pJson.embedded.order) {
    return {};
  }

  return transformIncompleteOrder(pJson.embedded.order);
};

/**
 * Transforms response of currentCheckoutOrder endpoints response to generic form
 * @param {Object} order
 * @returns {Object}  Order included in the order repository
 */
export const transformCheckoutOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }

  const {shoppingCart, ...orderRest} = order;
  const {items = [], ...shoppingCartRest} = shoppingCart || {};

  const newOrder = {...orderRest, items};

  return {
    ...populateOrder({...newOrder, ...shoppingCartRest})
  };
};

/**
 * Transforms response of currentCheckoutOrder endpoints response to generic form
 * @param {Object} order
 * @returns {Object}  Order included in the order repository
 */
export const transformOrderConfirmation = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return {};
  }
  const {shoppingCart, ...orderRest} = order;
  const {items = [], ...shoppingCartRest} = shoppingCart || {};

  const newOrder = {...orderRest, items};

  return {
    ...populateConfirmation({...newOrder, ...shoppingCartRest})
  };
};

/**
 * Transforms response of getUp sell Messages endpoints response to generic form
 * @param {Object} messages
 * @returns {Object} response with promotion messages.
 */
export const transformPricingMessage = messages => {
  if (!isObject(messages) || isEmptyObject(messages)) {
    return {};
  }
  const pricingMessage = populatePricingMessagesForEmptyCart(messages);

  return pricingMessage;
};

/**
 * Transforms a list of shipping methods into an object which contains:
 * 1. Map of shipping method details stored corresponding to shipping method repositoryId.
 * 2. Array of shippingMethods repositoryIds for each shipping groups
 *
 * @param {Array} items contains list of shipping methods per shipping group.
 * @returns {Object} An Object containing sgIdToListOfShippingMethodsMap map and smIdToShippingMethodDetails array.
 */
export const transformShippingMethods = items => {
  if (!Array.isArray(items)) {
    return {};
  }

  const sgIdToListOfShippingMethodsMap = {};
  let smIdToShippingMethodDetails = {};
  for (const item of items) {
    const shippingMethodObjects = arrayToMap(item.shippingMethods, 'repositoryId');

    smIdToShippingMethodDetails = {
      ...smIdToShippingMethodDetails,
      ...shippingMethodObjects
    };
    sgIdToListOfShippingMethodsMap[item.shippingGroupId] = [...Object.keys(shippingMethodObjects)];
  }

  const result = {
    sgIdToListOfShippingMethodsMap,
    smIdToShippingMethodDetails
  };

  return result;
};

/**
 * Transforms response of getAllOrdersForProfile endpoint from array to object format.
 * Also each order is converted to generic format for uniformity.
 * @param {Object} items array
 * @returns {Object} Object containing transformed orders.
 */
export const transformOrdersForProfile = items => {
  if (!items || !Array.isArray(items)) {
    return {};
  }

  const ordersMap = items.reduce((accumlator, item) => {
    const {orderId, id = orderId, ...orderRest} = item;
    const order = {...orderRest, id};

    return {
      ...accumlator,
      ...populateOrder(order).orderRepository.orders
    };
  }, {});

  return ordersMap;
};

/**
 * Transforms response of getAllOrdersForProfile endpoint from array to object format.
 * Also each order is converted to generic format except current order.
 * @param {Object} items array
 * @param {Object} state object
 * @returns {Object} Object containing transformed orders.
 */
export const transformOrdersForListCarts = (items, state) => {
  if (!items || !Array.isArray(items)) {
    return {};
  }
  const currentOrder = getCurrentOrder(state);
  const currentOrderId = getCurrentOrderId(state);
  const ordersMap = items.reduce((accumlator, item) => {
    const {orderId, id = orderId, ...orderRest} = item;
    const order = {...orderRest, id};

    return {
      ...accumlator,
      ...populateOrder(order).orderRepository.orders
    };
  }, {});
  const orderStructure = !isEmptyObject(currentOrder) ? {...ordersMap, ...{[currentOrderId]: currentOrder}} : ordersMap;

  return orderStructure;
};

/**
 * Transforms given commerce item of current order to generic form.
 * @param {Object} pJson
 * @param {Object} state
 * @returns {Object}  Order included in the order repository
 */
export const transformOrderCommerceItem = (pJson, state) => {
  if (!isObject(pJson) || isEmptyObject(pJson)) {
    return {};
  }

  const currentOrderId = getCurrentOrderId(state);

  if (!currentOrderId) {
    return {};
  }

  const {commerceItems} = state.orderRepository.orders[currentOrderId];
  const commerceItem = {...commerceItems[pJson.commerceItemId], ...pJson};

  return {
    orderRepository: {
      orders: {
        [currentOrderId]: {
          commerceItems: {
            ...commerceItems,
            [pJson.commerceItemId]: commerceItem
          }
        }
      }
    }
  };
};

/**
 * Transforms commerce items of current order to generic form.
 * @param {Object} pJson
 * @param {Object} state
 * @returns {Object}  Order included in the order repository
 */
export const transformOrderCommerceItems = (pJson, state) => {
  if (!isObject(pJson) || isEmptyObject(pJson)) {
    return {};
  }

  if (!pJson.items || !Array.isArray(pJson.items)) {
    return {};
  }

  const currentOrderId = getCurrentOrderId(state);

  if (!currentOrderId) {
    return {};
  }

  const resCommerceItems = arrayToMap(pJson.items, 'commerceItemId');

  const {commerceItems} = state.orderRepository.orders[currentOrderId];

  for (const id of Object.keys(resCommerceItems)) {
    commerceItems[id] = {...commerceItems[id], ...resCommerceItems[id]};
  }

  return {
    orderRepository: {
      orders: {
        [currentOrderId]: {
          commerceItems
        }
      }
    }
  };
};

/**
 * Transforms given shipping group of current order to generic form.
 * @param {Object} pJson
 * @param {Object} state
 * @returns {Object}  Order included in the order repository
 */
export const transformOrderShippingGroup = (pJson, state) => {
  if (!isObject(pJson) || isEmptyObject(pJson)) {
    return {};
  }

  const currentOrderId = getCurrentOrderId(state);

  if (!currentOrderId) {
    return {};
  }

  const {shippingGroups} = state.orderRepository.orders[currentOrderId];
  const shippingGroup = {...shippingGroups[pJson.shippingGroupId], ...pJson};

  return {
    orderRepository: {
      orders: {
        [currentOrderId]: {
          shippingGroups: {
            ...shippingGroups,
            [pJson.shippingGroupId]: shippingGroup
          }
        }
      }
    }
  };
};

/**
 * Transforms shipping groups of current order to generic form.
 * @param {Object} pJson
 * @param {Object} state
 * @returns {Object}  Order included in the order repository
 */
export const transformOrderShippingGroups = (pJson, state) => {
  if (!isObject(pJson) || isEmptyObject(pJson)) {
    return {};
  }

  if (!pJson.items || !Array.isArray(pJson.items)) {
    return {};
  }

  const currentOrderId = getCurrentOrderId(state);
  if (!currentOrderId) {
    return {};
  }

  const resShippingGroups = arrayToMap(pJson.items, 'shippingGroupId');
  const {shippingGroups} = state.orderRepository.orders[currentOrderId];

  for (const id of Object.keys(resShippingGroups)) {
    shippingGroups[id] = {...shippingGroups[id], ...resShippingGroups[id]};
  }

  return {
    orderRepository: {
      orders: {
        [currentOrderId]: {
          shippingGroups
        }
      }
    }
  };
};

/**
 * Transforms cancelReasons response to generic form to generic form.
 * @param {Object} items cancelReasons
 * @returns {Object}  cancel reason included in the merchant repository.
 */

export const transformCancelReasons = items => {
  if (!items || !Array.isArray(items)) {
    return {};
  }

  return {
    merchantRepository: {
      settings: {
        cancelReasons: [...items]
      }
    }
  };
};
