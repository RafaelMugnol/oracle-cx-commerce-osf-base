/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {arrayToMap, isEmptyObject} from '@oracle-cx-commerce/utils/generic';
import {
  getCurrentProfileId,
  getProfile,
  getSavedCardsForProfile,
  getRememberMeEnabled
} from '@oracle-cx-commerce/commerce-utils/selector';
import {transformMember} from '@oracle-cx-commerce/endpoints/utils/transform/organization-member';

const {keys} = Object;

/**
 * @deprecated
 *
 * Transforms the information of  a profile
 * @param {Object} json JSON response returned from getCurrentProfile endpoint
 * @returns {Object} The profile information made part of state structure
 */
export const transformProfile = (json, state) => {
  if (!state || isEmptyObject(json)) return {};

  const rememberMeEnabled = getRememberMeEnabled(state);
  const rememberMe = {
    login: json.email,
    loginName: json.firstName
  };

  const clientRepository = {
    context: {
      session: {
        profile: json.id,
        ...(rememberMeEnabled && {rememberMe: {...rememberMe}})
      }
    }
  };

  //Code to support b2b feature
  if (json.currentOrganization) {
    const result = transformMember(json);
    result.profileRepository.profiles['anonymous'] = {};
    result.clientRepository = clientRepository;

    return result;
  }

  return {
    profileRepository: {
      profiles: {
        anonymous: {},
        [json.id]: json
      }
    },
    clientRepository
  };
};

/**
 * Returns saved cards map after resetting default card (if any present)
 * @param {Object} cards - Saved cards map
 * @returns {Object} - Saved cards map after reset
 */
export const resetDefaultSavedCard = cards => {
  if (!isEmptyObject(cards)) {
    //reset default cards (if any)
    const resetCards = keys(cards).map(id => {
      return {...cards[id], isDefault: false};
    });

    // return a new map of cards
    return arrayToMap(resetCards, 'savedCardId');
  }

  return {};
};

/**
 * Forms delta state for saved cards
 * @param {Object} state - Application state
 * @param {Object} cards - Cards to be mapped in state
 * @param {Array} cardIds - Cards Ids to be mapped in state
 * @return {Object} - The delta state containing saved cards map (profileRepository.savedCards.<profileId>.savedCardsMap)
 * and profile specific saved card ids (profileRepository.savedCards.<profileId>.profileSavedCardIds)
 */
export const formDeltaStateForSavedCards = (state, cards = {}, cardIds = []) => {
  if (!state) return {};
  const profileId = getCurrentProfileId(state);

  return {
    profileRepository: {
      savedCards: {
        [profileId]: {
          savedCardsMap: cards,
          profileSavedCardIds: cardIds
        }
      }
    }
  };
};

/**
 * This method transforms all retrieved cards into delta state
 *
 * @param {Object} state - The state object
 * @param {Array} savedCards - Array of retrieved saved cards
 * @param {Object} - The delta state for saved cards
 */
export const transformListSavedCardsResponse = (state, savedCards) => {
  //check whether 'savedCards' is array or not
  if (!Array.isArray(savedCards) || savedCards.length === 0) {
    return {};
  }
  const cardIds = savedCards.map(card => card.savedCardId);

  return formDeltaStateForSavedCards(state, arrayToMap(savedCards, 'savedCardId'), cardIds);
};

/**
 * This method merges retrieved/updated/added card with existing saved
 * cards present under profileRepository.savedCards.<profileId>.savedCardsMap
 * and transform them in delta state
 *
 * @param {Object} state - the state object
 * @param {Object} savedCard - the added/retrieved/updated saved card object
 * @return {Object} - The delta state for saved cards
 */
export const transformSavedCardResponse = (state, savedCard) => {
  if (isEmptyObject(savedCard)) {
    return {};
  }

  let {savedCardsMap = {}, profileSavedCardIds = []} = getSavedCardsForProfile(state);

  if (!profileSavedCardIds.includes(savedCard.savedCardId)) {
    profileSavedCardIds = [...profileSavedCardIds, savedCard.savedCardId];
  }

  //if 'savedCard' is a default card then reset existing default card (if any)
  if (savedCard.isDefault) {
    savedCardsMap = resetDefaultSavedCard(savedCardsMap);
  }

  //merge 'savedCard' with existing cards and transform them
  return formDeltaStateForSavedCards(
    state,
    {...savedCardsMap, [savedCard.savedCardId]: savedCard},
    profileSavedCardIds
  );
};

/**
 * This method removes specific card from existing saved
 * cards present under profileRepository.savedCards.<profileId>.savedCardsMap
 * and returns delta state
 *
 * @param {Object} state - the state object
 * @param {Object} response - the response for removed saved card
 * @return {Object} - The delta state for saved cards
 */
export const removeSavedCard = (state, response) => {
  if (!response || !response.id) {
    return {};
  }

  const savedCards = getSavedCardsForProfile(state);
  const {savedCardsMap = {}} = savedCards;
  let {profileSavedCardIds = []} = savedCards;
  const {[response.id]: removedCard, ...remainingCards} = savedCardsMap;

  if (profileSavedCardIds.includes(response.id)) {
    profileSavedCardIds = profileSavedCardIds.filter(id => id !== response.id);
  }

  //transform remaining cards and required card ids
  return formDeltaStateForSavedCards(state, remainingCards, profileSavedCardIds);
};

/**
 * This method transforms all retrieved cards from current site in a map and merges with
 * existing saved cards present under profileRepository.savedCards.<profileId>.savedCardsMap
 *
 * @param {Object} state - The state object
 * @param {Array} savedCards - Array of retrieved saved cards from current site
 * @returns {Object} - The delta state containing saved cards map (profileRepository.savedCards.<profileId>.savedCardsMap)
 * and current site specific saved card ids (profileRepository.savedCards.<profileId>.currentSiteSavedCardIds)
 */
export const transformCurrentSiteSavedCardsResponse = (state, savedCards) => {
  //check whether 'savedCards' is array or not
  if (!Array.isArray(savedCards) || savedCards.length === 0) {
    return {};
  }

  const profileId = getCurrentProfileId(state);
  const cardIds = savedCards.map(card => card.savedCardId);
  const {savedCardsMap} = getSavedCardsForProfile(state);
  const mergeCards = {...savedCardsMap, ...arrayToMap(savedCards, 'savedCardId')};

  return {
    profileRepository: {
      savedCards: {
        [profileId]: {savedCardsMap: mergeCards, currentSiteSavedCardIds: cardIds}
      }
    }
  };
};

/**
 * @deprecated
 *
 * This method transforms address items array into address map.
 * It maps address details to addressType for each address in array.
 *
 * @param {Array} items - Array of address objects containing addressType and address fields.
 * @returns {Object} - Address Map where address details are mapped to corresponding addressType.
 */
export const transformSecondaryAddresses = items => {
  if (!Array.isArray(items)) return {};
  const transformAddressItemCallback = addressObject => {
    return addressObject.address;
  };
  const addressMap = arrayToMap(items, 'addressType', transformAddressItemCallback);

  return addressMap;
};

const transformProfileShippingAddresses = shippingAddresses => {
  if (!Array.isArray(shippingAddresses)) return {};

  const modShippingAddresses = shippingAddresses.map(address => {
    const {isDefaultAddress, alias, ...restAddress} = address;

    return {addressType: alias, ...restAddress};
  });

  return arrayToMap(modShippingAddresses, 'repositoryId');
};

/**
 * Transforms the information of  a profile without including session details
 * in client repository.
 *
 * @param {Object} json JSON response returned from getCurrentProfile endpoint
 * @returns {Object} The profile information made part of state structure
 */
const normalizeProfile = json => {
  if (!json || isEmptyObject(json)) return {};

  //Removing secondary addresses which is same shipping addresses for b2c user.
  const {secondaryAddresses, ...restProfile} = json;
  const profileAddresses = {};

  if (json.shippingAddress) {
    const {shippingAddress} = json;
    profileAddresses[shippingAddress.repositoryId] = shippingAddress;
    restProfile.shippingAddress = shippingAddress.repositoryId;
  }

  if (json.contactShippingAddress) {
    const {contactShippingAddress} = json;
    profileAddresses[contactShippingAddress.repositoryId] = contactShippingAddress;
    restProfile.contactShippingAddress = contactShippingAddress.repositoryId;
  }

  if (json.contactBillingAddress) {
    const {contactBillingAddress} = json;
    profileAddresses[contactBillingAddress.repositoryId] = contactBillingAddress;
    restProfile.contactBillingAddress = contactBillingAddress.repositoryId;
  }

  const shippingAddresses = transformProfileShippingAddresses(json.shippingAddresses);

  restProfile.shippingAddresses = keys(shippingAddresses);

  const contactInfos = {...profileAddresses, ...shippingAddresses};

  //Code to support b2b feature
  if (restProfile.currentOrganization) {
    const result = transformMember(restProfile);
    result.profileRepository.profiles['anonymous'] = {};
    result.profileRepository.contactInfos = contactInfos;

    return result;
  }

  return {
    profileRepository: {
      profiles: {
        anonymous: {},
        [restProfile.id]: restProfile
      },
      contactInfos
    }
  };
};

/**
 * Transforms the information of  a profile
 * @param {Object} json JSON response returned from getCurrentProfile endpoint
 * @returns {Object} The profile information made part of state structure
 */
export const transformProfileV2 = (json, state) => {
  if (!state || isEmptyObject(json)) return {};

  const rememberMeEnabled = getRememberMeEnabled(state);
  const rememberMe = {
    login: json.email,
    loginName: json.firstName
  };

  const clientRepository = {
    context: {
      session: {
        profile: json.id,
        ...(rememberMeEnabled && {rememberMe: {...rememberMe}})
      }
    }
  };

  const result = normalizeProfile(json);
  result.clientRepository = clientRepository;

  return result;
};

/**
 * This method transforms address items array into address map.
 * It maps address details to addressType for each address in array.
 *
 * @param {Array} items - Array of address objects containing addressType and address fields.
 * @returns {Object} - Address Map where address details are mapped to corresponding addressType.
 */
export const transformProfileAddresses = items => {
  if (!Array.isArray(items)) return {};

  const addresses = items.map(item => {
    const {addressType, address} = item;

    return {addressType, ...address};
  });

  const addressMap = arrayToMap(addresses, 'repositoryId');

  return addressMap;
};

/**
 * This method transforms profile address. It maps address details to addressId.
 *
 * @param {Object} json - address object containing addressType and address fields.
 * @returns {Object} - Repository representation of address object.
 */
export const transformProfileAddress = json => {
  if (!json || isEmptyObject(json)) {
    return {};
  }

  const result = {profileRepository: {contactInfos: {}}};

  const {addressType, address} = json;
  const {isDefaultBillingAddress, isDefaultShippingAddress, ...restAddress} = address;
  result.profileRepository.contactInfos[address.repositoryId] = {addressType, ...restAddress};

  return result;
};

/**
 * This method transforms profile address. It maps address details to addressId.
 * Also updates default address field in profile object.
 *
 * @param {Object} json - address object containing addressType and address fields.
 * @param {Object} state - Redux state object.
 * @returns {Object} - Repository representation of address object and updated default profile
 *                     address fields.
 */
export const transformAddressAndUpdateProfileDefaultAddress = (json, state) => {
  if (!json || isEmptyObject(json)) {
    return {};
  }

  const {address} = json;
  const result = transformProfileAddress(json);

  const defaultAddressField = {};

  //default shipping address field
  if (address.isDefaultShippingAddress) {
    defaultAddressField.contactShippingAddress = address.repositoryId;
    defaultAddressField.shippingAddress = address.repositoryId;
  }

  //default billing address field
  if (address.isDefaultBillingAddress) {
    defaultAddressField.contactBillingAddress = address.repositoryId;
  }

  result.profileRepository.profiles = {};
  const profileId = getCurrentProfileId(state);
  result.profileRepository.profiles[profileId] = {
    ...defaultAddressField
  };

  return result;
};

/**
 * This method updates default address field in profile object.
 *
 * @param {Object} json - address object containing addressType and address fields.
 * @param {Object} state - Redux state object.
 * @returns {Object} - Repository representation of address object and updated default profile
 *                     address fields.
 */
export const transformMarkDefaultShippingAddress = (json, state) => {
  if (!json || isEmptyObject(json)) {
    return {};
  }

  const result = {profileRepository: {profiles: {}}};

  const profileId = getCurrentProfileId(state);

  const {address} = json;

  //Mark address as default shipping address
  result.profileRepository.profiles[profileId] = {
    contactShippingAddress: address.repositoryId,
    shippingAddress: address.repositoryId
  };

  return result;
};

const addNewAddressInShippingAddresses = (state, {address}) => {
  const profile = getProfile(state);
  const shippingAddresses = profile.shippingAddresses ? [...profile.shippingAddresses] : [];

  //Add new address in shipping address field.
  shippingAddresses.push(address.repositoryId);

  return shippingAddresses;
};

/**
 * This method transforms profile address. It maps address details to addressId.
 * Also updates default address field in profile object and adds newly added
 * addressId into shipping address field.
 *
 * @param {Object} json - address object containing addressType and address fields.
 * @param {Object} state - Redux state object.
 * @returns {Object} - Repository representation of address object and updated default profile
 *                     address fields.
 */
export const transformNewProfileAddress = (json, state) => {
  if (!json || isEmptyObject(json)) {
    return {};
  }

  const result = transformAddressAndUpdateProfileDefaultAddress(json, state);

  const profileId = getCurrentProfileId(state);
  result.profileRepository.profiles[profileId].shippingAddresses = addNewAddressInShippingAddresses(state, json);

  return result;
};

/**
 * This method removes profile address from profile object.
 * Also updates default address field in profile object.
 *
 * @param {Object} json - object containing addressId of deleted profile address object.
 * @param {Object} state - Redux state object.
 * @returns {Object} - Repository representation of profile object and updated profile
 *                     address fields.
 */
export const deleteAddressFromProfile = (json, state) => {
  if (!json || isEmptyObject(json)) {
    return {};
  }

  const currentProfile = getProfile(state);
  const profileId = getCurrentProfileId(state);
  const {shippingAddresses} = currentProfile;

  const updatedProfile = {};
  if (shippingAddresses) {
    updatedProfile.shippingAddresses = shippingAddresses.filter(addressId => addressId !== json.repositoryId);
  }

  if (
    json.repositoryId === currentProfile.shippingAddress ||
    json.repositoryId === currentProfile.contactShippingAddress
  ) {
    updatedProfile.shippingAddress = null;
    updatedProfile.contactShippingAddress = null;
  }

  if (json.repositoryId === currentProfile.contactBillingAddress) {
    updatedProfile.contactBillingAddress = null;
  }

  return {
    profileRepository: {
      profiles: {
        [profileId]: updatedProfile
      }
    }
  };
};

/**
 * Return the updated normalized profile item from the JSON payload
 *
 * @param {Object} json - the son from the response
 * @return {Object} The response JSON
 */
export const updateProfileRepositories = json => {
  if (!json || isEmptyObject(json)) {
    return {};
  }

  return {
    ...normalizeProfile(json),
    clientRepository: {context: {session: {profile: json.id}}}
  };
};
