/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import {arrayToMap, argCheckForEmptyObjects} from '@oracle-cx-commerce/utils/generic';

/**
 * Transforms a list of countries and associated regions into an object structured for placement in the
 * countryRegionRepository store item.
 *
 * @param {Object} result contains the response structure.
 * @param {Object} countries contains the countries and regions list.
 * @returns {Object} An object containing a properties that have a key of the country code and a value containing the country and region info.
 */
const transformCountries = (result, countries) => {
  if (!Array.isArray(countries)) {
    return {};
  }

  if (!countries || typeof countries[Symbol.iterator] !== 'function') {
    return result;
  }

  const normalizedCountriesAndRegions = {};

  for (const countryAndRegion of countries) {
    const {country, regions} = countryAndRegion;

    normalizedCountriesAndRegions[country.countryCode] = {
      ...country,
      regions: Object.values(
        arrayToMap([...regions, ...(normalizedCountriesAndRegions[country.countryCode]?.regions || [])], 'repositoryId')
      )
    };
  }

  return normalizedCountriesAndRegions;
};

/**
 * Transforms a list of countries and associated regions into an object structured for placement in the
 * countryRegionRepository.shippingCountries or countryRegionRepository.billingCountries store item.
 *
 * @param {Object} countries contains the countries and regions list.
 * @param {String} type: billingCountries or shippingCountries
 * @returns {Object} An object containing a properties that have a key of the country code and a value containing the country and region info.
 */

const transformShippingAndBillingCountries = (countries, type) => {
  let result = {};
  const normalizedCountriesAndRegions = transformCountries(result, countries);
  if (Object.keys(normalizedCountriesAndRegions).length !== 0) {
    result = {
      countryRegionRepository: {
        [type]: normalizedCountriesAndRegions
      }
    };
  }

  return result;
};

export const transformShippingCountries = countries => {
  return transformShippingAndBillingCountries(countries, 'shippingCountries');
};

export const transformBillingCountries = countries => {
  return transformShippingAndBillingCountries(countries, 'billingCountries');
};

/**
 * Transforms a list of locations into an object structured for placement in the
 * locationRepository.locations store item.
 *
 * @param {Object} locations contains the array of location data.
 * @returns {Object} An object containing a properties that have a key of the locationId and a value containing the location info.
 */
export const transformLocations = locations => {
  if (!Array.isArray(locations)) {
    return {};
  }

  const result = {locationRepository: {locations: {}}};

  const normalizedLocations = {};

  for (const location of locations) {
    normalizedLocations[location.locationId] = {...location};
  }
  result.locationRepository.locations = normalizedLocations;

  return result;
};

/**
 * Transforms a list of shopper settings into an object structured for placement in the
 * merchantRepository.settings store item.
 *
 * @param {Object} settings contains the array of shopper settings data.
 * @returns {Object} An object containing shopper settings that have a key of shopper setting name and a value containing the respective setting value.
 */
export const populateShopperSettings = settings => {
  if (argCheckForEmptyObjects(settings)) {
    return {};
  }

  const result = {merchantRepository: {settings: {shopperSettings: settings}}};

  return result;
};

/**
 * Transforms the common resources into an object structured for placement in the
 * pageRepository.resources store item.
 *
 * @param {Object} resources contains the common resources data.
 * @returns {Object} An object containing common resources data with key as common and value as map of properties.
 */
export const populateCommonResources = resources => {
  if (argCheckForEmptyObjects(resources)) {
    return {};
  }

  const result = {pageRepository: {resources: {common: resources.resources}}};

  return result;
};

/**
 * Transforms a list of sites into an object structured for placement in the
 * siteRepository.sites store item.
 *
 * @param {Object} items contains the array of sites.
 * @returns {Object} An object containing sites that have a key of site name and a value containing the respective site description.
 */
export const transformListSitesResponse = items => {
  if (!items || !Array.isArray(items)) {
    return {};
  }

  const sites = arrayToMap(items, 'id');

  return {
    siteRepository: {sites: {...sites}}
  };
};

/**
 * Transforms SAML settings into an object structured for placement in the
 * merchantRepository.settings store item.
 *
 * @param {Object} merchantSettings contains the SAML settings.
 * @returns {Object} An object containing SAML settings key and a value containing the respective setting value.
 */
export const transformSamlSettings = merchantSettings => {
  if (argCheckForEmptyObjects(merchantSettings)) {
    return {};
  }
  if (merchantSettings && merchantSettings.links) {
    delete merchantSettings.links;
  }

  return {merchantRepository: {settings: {samlSettings: merchantSettings}}};
};

/**
 * Transforms production face book response into an object structured for placement in the
 * merchantRepository.settings store item.
 *
 * @param {Object} merchantSettings contains the production face book settings.
 * @returns {Object} An object containing production face book key and a value containing the respective setting value.
 */
export const transformProductionFacebookResponse = merchantSettings => {
  if (argCheckForEmptyObjects(merchantSettings)) {
    return {};
  }
  const {serviceData: {displayName, name, applicationId} = {}} = merchantSettings;

  return {merchantRepository: {settings: {productionFacebook: {displayName, name, applicationId}}}};
};

/**
 * Transforms production experiments response into an object structured for placement in the
 * merchantRepository.settings store item.
 *
 * @param {Object} merchantSettings contains the production experiments settings.
 * @returns {Object} An object containing production experiments key and a value containing the respective setting value.
 */
export const transformProductionExperimentsResponse = merchantSettings => {
  if (argCheckForEmptyObjects(merchantSettings)) {
    return {};
  }
  const experimentsData = Object.assign({}, merchantSettings);
  delete experimentsData.links;
  if (experimentsData.serviceData && experimentsData.serviceData.EETagConfiguration) {
    const {serviceData} = experimentsData;
    const Configuration = {
      '-host': serviceData.EETagConfiguration['-rules-host'],
      '-ms': serviceData.EETagConfiguration['-eeTimeout'],
      '-static': serviceData.EETagConfiguration['-static-host'],
      '-reMax': serviceData.EETagConfiguration['-retryMax'],
      '-reMs': serviceData.EETagConfiguration['-retryMS']
    };
    const serviceDataStateObj = {TagUrl: serviceData.EETagUrl || '', Configuration, host: serviceData.host || ''};
    experimentsData.serviceData = serviceDataStateObj;

    return {
      merchantRepository: {
        settings: {externalServiceConfiguration: {productionExperiments: experimentsData}}
      }
    };
  }
};

/**
 * Transforms production recommendations response into an object structured for placement in the
 * merchantRepository.settings store item.
 *
 * @param {Object} merchantSettings contains the production recommendations settings.
 * @returns {Object} An object containing production recommendations key and a value containing the respective setting value.
 */
export const transformProductionRecommendationsResponse = merchantSettings => {
  if (argCheckForEmptyObjects(merchantSettings)) {
    return {};
  }
  const {serviceData: {displayName, host, name, path, port, protocol, tenantId} = {}} = merchantSettings;

  return {
    merchantRepository: {
      settings: {productionRecommendations: {displayName, name, host, path, port, protocol, tenantId}}
    }
  };
};

export const transformCloudConfiguration = merchantSettings => {
  if (argCheckForEmptyObjects(merchantSettings)) {
    return {};
  }
  if (merchantSettings && merchantSettings.links) {
    delete merchantSettings.links;
  }
  if (merchantSettings && merchantSettings.clientConfiguration) {
    delete merchantSettings.clientConfiguration;
  }

  return {merchantRepository: {settings: {cloudConfiguration: merchantSettings}}};
};

/**
 * Function adds contextual information to the catalogRepository section
 * of the state model.  This takes category custom properties in the response
 * and maps them into a model expected by the state.
 *
 * @param {Object} response the response.
 * @returns {Object} the transformed state model.
 */
export const populateCategoryCustomProperties = response => {
  if (argCheckForEmptyObjects(response)) {
    return {};
  }
  let customProperties = {};
  const {id, specifications = []} = response;

  if (response && response.specifications) {
    customProperties[id] = {};
  }
  if (specifications.length) {
    customProperties = {[id]: {specifications}};
  }

  return {catalogRepository: {customProperties: {...customProperties}}};
};

/**
 * Function adds contextual information to the profileRepository section
 * of the state model.  This takes user custom properties in the response
 * and maps them into a model expected by the state.
 *
 * @param {Object} response the response.
 * @returns {Object} the transformed state model.
 */
export const populateUserCustomProperties = response => {
  if (argCheckForEmptyObjects(response)) {
    return {};
  }
  let customProperties = {};
  const {id, specifications = []} = response;

  if (response && response.specifications) {
    customProperties[id] = {};
  }
  if (specifications.length) {
    customProperties = {[id]: {specifications}};
  }

  return {profileRepository: {customProperties: {...customProperties}}};
};

/**
 * Function adds contextual information to the orderRepository section
 * of the state model.  This takes order custom properties in the response
 * and maps them into a model expected by the state.
 *
 * @param {Object} response the response.
 * @returns {Object} the transformed state model.
 */
export const populateOrderCustomProperties = response => {
  if (argCheckForEmptyObjects(response)) {
    return {};
  }
  let customProperties = {};
  const {id, specifications = []} = response;

  if (response && response.specifications) {
    customProperties[id] = {};
  }
  if (specifications.length) {
    customProperties = {[id]: {specifications}};
  }

  return {orderRepository: {customProperties: {...customProperties}}};
};

/**
 * Function adds contextual information to the profileRepository section
 * of the state model.  This takes contactInfo custom properties in the response
 * and maps them into a model expected by the state.
 *
 * @param {Object} response the response.
 * @returns {Object} the transformed state model.
 */
export const populateContactInfoCustomProperties = response => {
  if (argCheckForEmptyObjects(response)) {
    return {};
  }
  let customProperties = {};
  const {id, specifications = []} = response;

  if (response && response.specifications) {
    customProperties[id] = {};
  }
  if (specifications.length) {
    customProperties = {[id]: {specifications}};
  }

  return {profileRepository: {customProperties: {...customProperties}}};
};

/**
 * Function adds contextual information to the orderRepository section
 * of the state model.  This takes CommerceItem custom properties in the response
 * and maps them into a model expected by the state.
 *
 * @param {Object} response the response.
 * @returns {Object} the transformed state model.
 */
export const populateCommerceItemCustomProperties = response => {
  if (argCheckForEmptyObjects(response)) {
    return {};
  }
  let customProperties = {};
  const {id, specifications = []} = response;

  if (response && response.specifications) {
    customProperties[id] = {};
  }
  if (specifications.length) {
    customProperties = {[id]: {specifications}};
  }

  return {orderRepository: {customProperties: {...customProperties}}};
};

/**
 * Function adds contextual information to the catalogRepository section
 * of the state model.  This takes Product custom properties in the response
 * and maps them into a model expected by the state.
 *
 * @param {Object} response the response.
 * @returns {Object} the transformed state model.
 */
export const populateProductCustomProperties = response => {
  if (argCheckForEmptyObjects(response)) {
    return {};
  }
  let customProperties = {};
  const {id, specifications = []} = response;

  if (response && response.specifications) {
    customProperties[id] = {};
  }
  if (specifications.length) {
    customProperties = {[id]: {specifications}};
  }

  return {catalogRepository: {customProperties: {...customProperties}}};
};

export * from '@oracle-cx-commerce/endpoints/utils/transform/assets';
export * from '@oracle-cx-commerce/endpoints/utils/transform/configurations';
export * from '@oracle-cx-commerce/endpoints/utils/transform/order';
export * from '@oracle-cx-commerce/endpoints/utils/transform/organization';
export * from '@oracle-cx-commerce/endpoints/utils/transform/organization-address';
export * from '@oracle-cx-commerce/endpoints/utils/transform/organization-member';
export * from '@oracle-cx-commerce/endpoints/utils/transform/payments';
export * from '@oracle-cx-commerce/endpoints/utils/transform/products';
export * from '@oracle-cx-commerce/endpoints/utils/transform/profile';
export * from '@oracle-cx-commerce/endpoints/utils/transform/purchase-list';
export * from '@oracle-cx-commerce/endpoints/utils/transform/registration-request';
export * from '@oracle-cx-commerce/endpoints/utils/transform/return';
export * from '@oracle-cx-commerce/endpoints/utils/transform/scheduled-order';
export * from '@oracle-cx-commerce/endpoints/utils/transform/share-setting';
export * from '@oracle-cx-commerce/endpoints/utils/transform/shopper-context';
export * from '@oracle-cx-commerce/endpoints/utils/transform/role';
