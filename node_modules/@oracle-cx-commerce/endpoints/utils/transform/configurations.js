/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {isEmptyObject, isObject} from '@oracle-cx-commerce/utils/generic';

/**
 * Returns a list of menu items that are valid for a given configurable attribute based on the current
 * state of the configuration instance. All possible options for menu based configurable attributes will
 * be returned in the layout response; this list needs to be filtered to remove any items that are not
 * valid selections based on the state of the active configuration instance. The state  contains a list
 * of constraints.
 * @param {Array} allAttributeMenuItems
 * @param {Object} attributeDomainData
 * @return {Array} filtered menu items
 */
const getConstrainedMenuItems = (allAttributeMenuItems, attributeDomainData = {}) => {
  let {availableElements: availableMenuItems = []} = attributeDomainData;
  const {constraintList = [], constraintType} = attributeDomainData;

  if (!constraintList.length) {
    return allAttributeMenuItems;
  }

  if (constraintType === 'DISALLOWED') {
    // remove constraintList items from availableMenuItems
    availableMenuItems = availableMenuItems.filter(el => !constraintList.includes(el.value));
  } else {
    // constraintType === 'ALLOWED' so
    // remove everything from availableMenuItems that is not in constraintList
    availableMenuItems = availableMenuItems.filter(el => constraintList.includes(el.value));
  }

  const returnValue = [];

  // The menu items from attributeDomainData contains a subset of all the required properties
  // so merge the objects from availableMenuItems with the equivalent objects in allAttributeMenuItems
  // matching on "value" as it is the common unique identifier.
  // TODO - allowing type coercion in the value equality check as allAttributeMenuItems (layout menu items)
  // uses strings for numeric values and availableMenuItems (domain constraint menu items) uses numbers
  for (let i = 0; i < availableMenuItems.length; i++) {
    returnValue.push({
      ...availableMenuItems[i],
      ...allAttributeMenuItems.find(item => item.value === `${availableMenuItems[i].value}`)
    });
  }

  return returnValue;
};

/**
 * Checks if the passed component contains menu items and if
 * so creates a new property on the component's menuItems object named
 * "constrainedItems". "constrainedItems" will contain only those the menu items allowable
 * by the configuration instance state constraint rules.
 * @param {Object} component
 * @param {Object} configData
 * @return {Object} transformed layout component
 */
const transformLayoutComponent = (component, configData) => {
  if (component.componentTypeCode.lookupCode === 'ARRAY_SET') {
    component.components.items = component.components.items.map(asItem => {
      if (
        asItem.resourceAttributeData &&
        asItem.resourceAttributeData.menuItems &&
        asItem.resourceAttributeData.menuItems.items &&
        asItem.resourceAttributeData.menuItems.items.length
      ) {
        const asDomainData =
          configData &&
          configData[`${component.resourceVariableName.variableName}`] &&
          configData[`${component.resourceVariableName.variableName}`]._state &&
          configData[`${component.resourceVariableName.variableName}`]._state.attributes &&
          configData[`${component.resourceVariableName.variableName}`]._state.attributes[
            asItem.resourceAttributeVarName
          ] &&
          configData[`${component.resourceVariableName.variableName}`]._state.attributes[
            asItem.resourceAttributeVarName
          ].domain;

        asItem.resourceAttributeData.menuItems.constrainedItems = getConstrainedMenuItems(
          asItem.resourceAttributeData.menuItems.items,
          asDomainData
        );
      }

      return asItem;
    });
  }

  if (
    component.resourceAttributeData &&
    component.resourceAttributeData.menuItems &&
    component.resourceAttributeData.menuItems.items &&
    component.resourceAttributeData.menuItems.items.length
  ) {
    const attributeDomainData =
      configData &&
      configData._state &&
      configData._state.attributes &&
      configData._state.attributes[component.resourceAttributeVarName] &&
      configData._state.attributes[component.resourceAttributeVarName].domain;
    component.resourceAttributeData.menuItems.constrainedItems = getConstrainedMenuItems(
      component.resourceAttributeData.menuItems.items,
      attributeDomainData
    );
  }

  return component;
};

/**
 * Recursive function to transform each component in the passed
 * array of components
 * @param {Array} items
 * @param {Object} configData
 * @return {Array} array of transformed layout components
 */
const transformLayoutComponents = (items = [], configData) => {
  for (let index = 0; index < items.length; index++) {
    items[index] = transformLayoutComponent(items[index], configData);

    if (items[index].components && items[index].components.items) {
      items[index].components.items = transformLayoutComponents(items[index].components.items, configData);
    }
  }

  return items;
};

/**
 * Starts transforming layout components - if the layout object
 * contains a collection of component items.
 */
export const transformLayout = (layout = {}, configData = {}, layoutNameSpace = null, arraySetVariableNames = []) => {
  if (!isObject(layout) || isEmptyObject(layout)) {
    return {};
  }

  if (
    layout.items &&
    layout.items.components &&
    layout.items.components.items &&
    layout.items.components.items.length
  ) {
    layout.items.components.items = transformLayoutComponents(layout.items.components.items, configData);
  }

  layout.arraySetVariableNames = arraySetVariableNames;

  return {
    [layoutNameSpace]: {
      [layout.varName]: layout
    }
  };
};

/**
 * Transforms configuration response into an exploded representation of all its data
 * within the application's storage format.
 *
 * @param {*} data The data to be transformed.
 * @returns The configuration within the 'configurationRepository' store item
 */
export const transformConfiguration = (data, {productFamily, productLine, model} = {}) => {
  if (!isObject(data) || isEmptyObject(data)) {
    return {};
  }

  const {
    cacheInstanceId,
    configData,
    layoutNamespace,
    layoutFlowVariableName,
    layout,
    arraySetVariableNames,
    templates,
    uiSettings,
    links
  } = data;

  return {
    configurationRepository: {
      configurations: {
        current: {
          cacheInstanceId,
          productFamily,
          productLine,
          model,
          configData,
          ...(layoutNamespace ? {layoutNamespace} : ''),
          ...(layoutFlowVariableName ? {layoutFlowVariableName} : ''),
          ...(arraySetVariableNames ? {arraySetVariableNames} : []),
          ...(links ? {links} : [])
        }
      },
      layouts: {
        ...(!isEmptyObject(layout) && transformLayout(layout, configData, layoutNamespace, arraySetVariableNames))
      },
      ...(!isEmptyObject(templates) ? {templates} : {}),
      ...(!isEmptyObject(uiSettings) ? {uiSettings} : {})
    }
  };
};
