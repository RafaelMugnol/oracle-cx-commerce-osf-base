/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {arrayToMap, isEmptyObject, isObject} from '@oracle-cx-commerce/utils/generic';
import {
  PAYMENT_TYPE_GIFTCARD,
  PAYMENT_TYPE_LOYALTYPOINTS,
  PAYMENT_TYPE_STORECREDIT
} from '@oracle-cx-commerce/commerce-utils/constants';
import {
  getCurrentOrder,
  getCurrentOrderId,
  getCurrentProfileId,
  getInquireBalanceResponseForCurrentUser,
  getOrder
} from '@oracle-cx-commerce/commerce-utils/selector';
import {populateOrder} from '@oracle-cx-commerce/endpoints/utils/transform/order';

/**
 * Transforms a list of card types into an object structured for placement in the
 * paymentRepository.cardTypes store item.
 *
 * @param {Object} cardTypes contains the array of card types.
 * @returns {Object} An object containing a properties that have a key of the cardType Id and a value containing the card type info.
 */
export const transformCardTypes = cardTypes => {
  if (!Array.isArray(cardTypes)) {
    return {};
  }

  const result = {
    paymentRepository: {
      cardTypes: arrayToMap(cardTypes, 'repositoryId')
    }
  };

  return result;
};
/**
 * Transforms payment response from add or initiate payment operation into an object structured for placement in the
 * orderRepository.orders.orderID store item.
 *
 * @param {Object} paymentResponse contains the payment response.
 * @returns {Object} An object containing order details.
 */
export const transformPaymentResponse = paymentResponse => {
  if (!isObject(paymentResponse)) {
    return {};
  }
  const {
    embedded: {order}
  } = paymentResponse;

  const {shoppingCart, ...orderRest} = order;
  const {items = [], ...shoppingCartRest} = shoppingCart || {};
  const newOrder = {...orderRest, items};

  return populateOrder({...newOrder, ...shoppingCartRest});
};

/**
 * Transforms response from inquire balance operation into an object structured for placement in the
 * profileRepository.inquireBalanceResponses.<profileId> store item.
 *
 * @param {Object} paymentResponses contains the response from inquireBalance operation.
 * @param {Object} state the current state.
 * @returns {Object} the inquireBalanceResponses containing giftCards,loyaltyPrograms,storeCredits within profileRepository store item.
 */
export const transformInquireBalanceResponse = (paymentResponses, state) => {
  if (!Array.isArray(paymentResponses)) {
    return {};
  }

  let {giftCards = {}, loyaltyPrograms = {}, storeCredits = {}} = getInquireBalanceResponseForCurrentUser(state);
  const profileId = getCurrentProfileId(state);

  for (const paymentResponse of paymentResponses) {
    //Merge the existing state for giftCards, loyaltyPrograms,storeCredits with the response received.
    if (paymentResponse.type === PAYMENT_TYPE_GIFTCARD) {
      giftCards = {
        ...giftCards,
        [paymentResponse.giftCardNumber]: {...paymentResponse}
      };
    } else if (paymentResponse.type === PAYMENT_TYPE_LOYALTYPOINTS) {
      const {customPaymentProperties = {}, ...programDetails} = loyaltyPrograms;
      loyaltyPrograms = {
        ...programDetails,
        ...arrayToMap(paymentResponse.loyaltyPrograms, 'programId'),
        customPaymentProperties: {...customPaymentProperties, ...paymentResponse.customPaymentProperties}
      };
    } else if (paymentResponse.type === PAYMENT_TYPE_STORECREDIT) {
      const {customPaymentProperties = {}, ...storeCreditDetails} = storeCredits;
      storeCredits = {
        ...storeCreditDetails,
        ...arrayToMap(paymentResponse.storeCredits, 'storeCreditNumber'),
        customPaymentProperties: {...customPaymentProperties, ...paymentResponse.customPaymentProperties}
      };
    }
  }
  const result = {
    profileRepository: {
      inquireBalanceResponses: {
        [profileId]: {
          ...(!isEmptyObject(giftCards) && {giftCards}),
          ...(!isEmptyObject(loyaltyPrograms) && {loyaltyPrograms}),
          ...(!isEmptyObject(storeCredits) && {storeCredits})
        }
      }
    }
  };

  return result;
};

/**
 * Include selectedCountry, selectedState and state_ISOCode fields as part of billingAddress
 * Assign selectedCountry to the value of country, selectedState to value of state
 * and state_ISOCode to value of country-state.
 * @param {Object} billingAddress contains the billingAddressDetails.
 * @returns {Object} BillingAddress object with selectedCountry,selectedState and state_ISOCode fields included.
 *
 */
export const includeDerivedPropertiesToBillingAddress = billingAddress => {
  if (!isObject(billingAddress)) {
    return {};
  }

  const {country, state} = billingAddress;
  if (country && state) {
    return {
      ...billingAddress,
      selectedCountry: country,
      selectedState: state,
      // eslint-disable-next-line camelcase
      state_ISOCode: `${country}-${state}`
    };
  }

  return billingAddress;
};

/**
 * Properties to be sent in the getPaymentGroup response.
 * @type {Map<any, any>}
 */
const paymentGroupMappingProperties = new Map();
paymentGroupMappingProperties.set('paymentState', 'stateAsString');
paymentGroupMappingProperties.set('cardType', 'creditCardType');
paymentGroupMappingProperties.set('cardNumber', 'creditCardNumber');
paymentGroupMappingProperties.set('paymentGroupId', 'id');
paymentGroupMappingProperties.set('expiryMonth', 'expirationMonth');
paymentGroupMappingProperties.set('expiryYear', 'expirationYear');

/**
 * Updates the payment group in order
 * @param state
 * @param paymentGroup
 * @returns {{}|{orderRepository: {orders: {}}}}
 */
export const updatePaymentGroup = (state, paymentGroup, orderId) => {
  if (!isObject(paymentGroup) || isEmptyObject(paymentGroup)) {
    return {};
  }

  let order;
  if (!orderId || orderId instanceof Object) {
    order = getCurrentOrder(state);
    orderId = getCurrentOrderId(state);
  } else {
    order = getOrder(state, {id: orderId});
  }
  const orderRepo = {
    orderRepository: {
      orders: {}
    }
  };

  const {id} = paymentGroup;

  const newPaymentGroup = {};

  for (const property of paymentGroupMappingProperties.keys()) {
    const mappedKey = paymentGroupMappingProperties.get(property);
    if (Object.keys(paymentGroup).includes(mappedKey)) {
      newPaymentGroup[property] = paymentGroup[mappedKey];
      delete paymentGroup[paymentGroupMappingProperties.get(property)];
    }
  }

  order.state = paymentGroup.orderStatus;
  delete paymentGroup['orderStatus'];
  order.paymentGroups[id] = Object.assign(order.paymentGroups[id], Object.assign(newPaymentGroup, paymentGroup));
  const result = orderRepo;
  result.orderRepository = state.orderRepository;

  result.orderRepository.orders[orderId] = order;

  return result;
};
