/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {isEmptyObject, isObject} from '@oracle-cx-commerce/utils/generic';

/**
 * Returns an array of asset ids from assets page response.
 *
 * @param {*} data The data to be mapped.
 * @returns A list of asset ids.
 */
const mapAssets = data => {
  if (!isObject(data) || isEmptyObject(data)) {
    return {};
  }

  return data.items.map(asset => {
    return asset.assetId;
  });
};

/**
 * Returns link information for the next set of assets, based on the responses
 * current offset and limit.
 *
 * @param {*} data The asset listing response.
 * @returns A query string for the next set of assets.
 */
const next = data => {
  if (data.hasMore) {
    return `?offset=${data.offset + data.limit}&limit=${data.limit}`;
  }
};

/**
 *  Returns link information for the previous set of assets.
 *
 * @param {*} data The asset listing response.
 * @returns A query string for the previous set of assets.
 */
const prev = data => {
  const {offset, limit} = data;
  const calculatedOffset = offset - limit > 0 ? offset - limit : 0;

  return `?offset=${calculatedOffset}&limit=${data.limit}`;
};

/**
 * Transforms a single asset into an exploded representation of all its data within the application's
 * storage format. This includes descendant assets.
 *
 * @type {import('.').Transform}
 * @param asset The asset to be transformed.
 * @returns The assets(s) and descendant asset(s) within the 'assetRepository' store item.
 */
export const transformAsset = asset => {
  if (!isObject(asset)) {
    return {};
  }

  const result = {assetRepository: {assets: {}}};

  // add the asset information
  const transformedAsset = {
    ...asset
  };

  // Pull out the descendant assets and store them as peers of this one.
  if (transformedAsset.descendantAssets) {
    for (const descendantAsset of asset.descendantAssets) {
      const transformed = transformAsset(descendantAsset);
      result.assetRepository.assets = {
        ...result.assetRepository.assets,
        ...transformed.assetRepository.assets
      };
    }
    transformedAsset.descendantAssets = asset.descendantAssets.map(descendantAsset => descendantAsset.assetId);
  }

  result.assetRepository.assets[transformedAsset.assetId] = transformedAsset;

  return result;
};

/**
 * Transforms list of assets into an exploded representation of all its data within the application's
 * storage format.  This includes descendantAssets.
 *
 * @type {import('.').Transform}
 * @param {*} data The data to be transformed.
 * @returns The assets(s) within the 'assetRepository' store item.
 */
export const transformAssets = data => {
  if (!isObject(data) || isEmptyObject(data)) {
    return {};
  }

  const result = {assetRepository: {assets: {}}};
  const assets = data.items;
  for (const asset of assets) {
    const transformedAsset = transformAsset(asset);
    result.assetRepository.assets = {
      ...result.assetRepository.assets,
      ...transformedAsset.assetRepository.assets
    };
  }

  return result;
};

/**
 * Transforms assets page response into an exploded representation of all its data within the application's
 * storage format.
 *
 * @param {*} data The data to be transformed.
 * @param {*} pageId The assets page id that will be used as a key to reference the page data.
 * @returns The asset(s) within the 'assetRepository' store item and page within pageRepository
 */
export const transformAssetsForListing = (data, pageId) => {
  if (!isObject(data) || isEmptyObject(data)) {
    return {};
  }
  const items = mapAssets(data);

  return {
    pageRepository: {
      pages: {
        [pageId]: {
          items,
          offset: data.offset,
          limit: data.limit,
          total: data.totalResults,
          hasMore: data.hasMore,
          self: `?offset=${data.offset}&limit=${data.limit}`,
          ...(data.hasMore && {next: next(data)}),
          ...(data.offset > 0 && {prev: prev(data)})
        }
      }
    },
    ...transformAssets(data)
  };
};
