/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {valueIsTrue, isEmptyObject} from '@oracle-cx-commerce/utils/generic';
import {getCurrentProfileId, getContactInfos} from '@oracle-cx-commerce/commerce-utils/selector';

export const getBodyAsJson = async body => {
  try {
    return await body.json();
  } catch (error) {
    return {};
  }
};

const {assign} = Object;

/**
 * Return the error response object from the response and JSON payload
 * Entire json object is included in payload in case things like devMessage are passed and needed
 *
 * @param {Response} response - the response
 * @param {Object} json - the json from the response
 * @return {Object} The error response JSON
 */
export const populateError = (response, json) => {
  const {status} = response;

  return {
    error: {
      ...json,
      status
    }
  };
};

/**
 * Returns whether a property exists in an object
 *
 * Used to map checkbox string true into a boolean needed by the endpoint
 *
 * @param {object} prop The property to look for
 * @param {obj} prop The object to look in
 * @return {Boolean} Whether the property exists in the object was true.
 */
export const propertyExistsInObject = (prop, obj) => {
  if (obj === null || typeof obj !== 'object') {
    return false;
  }

  return prop in obj;
};

/**
 * Builds the query param string for the sort options on the query
 *
 * @param {*} sort
 * @returns a query param string with sort option added, if applicable.
 */
export const sortQuery = sort => {
  if (sort && sort.length > 0) {
    const s = sort[0];

    return `&sort=${s.property}:${s.order}`;
  }

  return '';
};

/**
 * Gets the asset language header from the payload if it's present.
 *
 * @param {Object} payload The object containing the assetLanguage property
 * @return {Object} Object containing the asset language in the format expected by the OCCS WAPI.
 */
export const getAssetLanguageHeader = payload => {
  const assetLanguageHeader = payload.assetLanguage;

  return assetLanguageHeader ? {'X-CCAsset-Language': assetLanguageHeader} : undefined;
};

/**
 * Tests whether the passed param is a array of type string.
 *
 * @param {*} fieldValue variable to test the typeof
 * @return {boolean} Indicates if passed param is a valid string array.
 */
export const validateIsStringArray = fieldValue => {
  // ensure it's an array
  if (Array.isArray(fieldValue) === false) {
    return false;
  }

  if (fieldValue.length === 0) {
    return false;
  }

  // ensure each value is a string
  return !fieldValue.some(field => !(typeof field === 'string' || field instanceof String));
};

/**
 * Creates a comma separated string from an array.
 *
 * @param {Array} arrayOfFields An array of values to be converted to a comma separated string.
 * @return {string}  A comma separated string of the array values.
 */
export const createCommaSeparatedStringFromArray = arrayOfFields => {
  if (arrayOfFields === undefined) {
    return arrayOfFields;
  }

  return arrayOfFields.toString();
};

/**
 * Extracts the fields, include and exclude params from the passed payload object and populates these in the format expected by the OCCS WAPI on the object returned.
 * If the passed field, include or exclude property value is not a valid string array, then the output object will exclude that property.
 *
 * @param {Object} payload Payload object that contains the fields params.
 * @return {Object} Object containing the OCCS WAPI formatted fields, include and exclude params if applicable.
 */
export const populateFieldParams = payload => {
  const {fields, include, exclude} = payload;

  const queryParams = {};
  fields !== undefined &&
    validateIsStringArray(fields) &&
    (queryParams.fields = createCommaSeparatedStringFromArray(fields));
  include !== undefined &&
    validateIsStringArray(include) &&
    (queryParams.include = createCommaSeparatedStringFromArray(include));
  exclude !== undefined &&
    validateIsStringArray(exclude) &&
    (queryParams.exclude = createCommaSeparatedStringFromArray(exclude));

  return queryParams;
};

/* Sets a property in an object to a boolean value, if necessary
 *
 * If the property passed in exists in the payload convert it to a boolean
 * to avoid any server errors from a string being passed.
 *
 *
 * @param {object} payload The payload possibly containing the property to check
 * @return {Object} The payload.
 */
export const convertPropertyToBoolean = (object, property) => {
  const propertyExists = propertyExistsInObject(property, object);

  if (propertyExists) {
    const propertyVal = valueIsTrue(object[property]);

    return assign({}, object, {[property]: propertyVal});
  }

  return object;
};

/**
 * Returns a new profile object for a payload
 *
 * @param {Object} payload The payload containing the fields to populate.
 * @return {Object} A new profile object.
 */
export const getNewProfile = payload => {
  const {receiveEmailGlobal = null, GDPRProfileP13nConsentGrantedGlobal = null} = payload;

  if (valueIsTrue(receiveEmailGlobal)) {
    payload.receiveEmail = 'yes';
  }

  if (valueIsTrue(GDPRProfileP13nConsentGrantedGlobal)) {
    payload.GDPRProfileP13nConsentGranted = true;
  } else {
    // set the GDPRProfileP13nConsentGranted flag to a boolean, if it exists in the payload
    // the payload may have it as a string so it needs converted
    payload = convertPropertyToBoolean(payload, 'GDPRProfileP13nConsentGranted');
  }

  return payload;
};

/**
 * Gets the shipping addresses from a profile
 *
 * @param {Object} profile The profile containing shippingAddresses.
 * @return {Object} The shippingAddresses collection.
 */
export const getExistingShippingAddresses = profile => {
  return profile.shippingAddresses && profile.shippingAddresses.length ? profile.shippingAddresses : [];
};

/**
 * Returns a new address object for a payload
 *
 * @param {Object} payload The payload containing the fields to populate.
 * @return {Object} A new address object.
 */
export const getNewProfileAddress = payload => {
  if (isEmptyObject(payload)) {
    return null;
  }

  return assign({}, payload, {isDefaultAddress: valueIsTrue(payload.isDefaultAddress)});
};

/**
 * Create or update a client address
 *
 * @param {Object} address The address to create or update.
 * @param {Object} profile The profile containing shippingAddress and shippingAddresses collection.
 * @return {Object} The shippingAddresses with the new or updated address.
 */
export const createUpdateProfileAddress = (address, profile) => {
  let currentAddresses = getExistingShippingAddresses(profile);

  if (address === null) {
    return {shippingAddresses: [...currentAddresses]};
  }

  // if there are existing addresses update them
  if (currentAddresses.length) {
    // if there is a repository id then it's an update of an existing address
    if (address.repositoryId) {
      currentAddresses = currentAddresses.filter(e => e.repositoryId !== address.repositoryId);
    }

    // if it's got the default address flag passed in then set the others to false
    if (address.isDefaultAddress) {
      currentAddresses = currentAddresses.map(currentAddress => assign(currentAddress, {isDefaultAddress: false}));
    }
  }

  return {shippingAddresses: [address, ...currentAddresses]};
};

/**
 * Delete a client address
 *
 * @param {Object} addressId The address id to delete.
 * @param {Object} profile The profile containing shippingAddress and shippingAddresses collection.
 * @return {Object} The shippingAddresses without the updated address to be deleted.
 */
export const deleteProfileAddress = (addressId, profile) => {
  let currentAddresses = getExistingShippingAddresses(profile);

  // check if there is an addressId passed in and also that we have addresses
  if (addressId && currentAddresses.length) {
    // remove the address based on the repository id
    // server will update the default address, if this was the default
    currentAddresses = currentAddresses.filter(currentAddress => currentAddress.repositoryId !== addressId);
  }

  return {shippingAddresses: [...currentAddresses]};
};

/**
 * Update an address as the default for the profile
 *
 * @param {Object} addressId The address id to set as default.
 * @param {Object} profile The profile containing shippingAddress and shippingAddresses collection.
 * @return {Object} The shippingAddresses with the updated default address.
 */
export const updateDefaultProfileAddress = (addressId, profile) => {
  let currentAddresses = getExistingShippingAddresses(profile);

  // if there is a repository id then it's an update of an existing address
  if (addressId && currentAddresses.length) {
    currentAddresses = currentAddresses.map(currentAddress =>
      assign(currentAddress, {isDefaultAddress: currentAddress.repositoryId === addressId})
    );
  }

  return {shippingAddresses: [...currentAddresses]};
};

/**
 * Return the updated repository from the JSON payload
 *
 * @param {Object} json - the son from the response
 * @return {Object} The response JSON
 */
export const populateProfileRepositories = json => {
  return {
    profileRepository: {profiles: {[json.id]: json}},
    clientRepository: {context: {session: {profile: json.id}}}
  };
};

/**
 * Return the sire properties response mapping any site properties into
 * the profile object for the site and all the site properties into the
 * site properties object within the profile
 *
 * @param {Object} json - the properties to map
 * @return {Object} The response JSON
 */
export const mapSitePropertiesResponse = (state, json) => {
  const {items = []} = json;

  const profileId = getCurrentProfileId(state);

  let receiveEmailGlobal = items.length > 0;
  let GDPRProfileP13nConsentGrantedGlobal = items.length > 0;

  const sites = [];
  for (const {properties, site} of items) {
    const {receiveEmail = 'no', GDPRProfileP13nConsentGranted = false} = properties;

    receiveEmailGlobal = receiveEmailGlobal && receiveEmail === 'yes';
    GDPRProfileP13nConsentGrantedGlobal = GDPRProfileP13nConsentGrantedGlobal && GDPRProfileP13nConsentGranted;

    sites.push({
      id: site.id,
      ...properties
    });
  }

  return {
    profileRepository: {
      siteProperties: {
        [profileId]: {
          receiveEmailGlobal,
          GDPRProfileP13nConsentGrantedGlobal,
          sites
        }
      }
    }
  };
};

/**
 * Returns a new address object for a payload
 *
 * @param {Object} payload The payload containing the fields to populate.
 * @return {Object} A new address object.
 */
export const getUpdatedAddress = payload => {
  if (isEmptyObject(payload)) {
    return {};
  }

  return assign(
    {},
    payload,
    {isDefaultShippingAddress: valueIsTrue(payload.isDefaultShippingAddress)},
    {isDefaultBillingAddress: valueIsTrue(payload.isDefaultBillingAddress)}
  );
};

export const updateDefaultShippingAddress = (addressId, state) => {
  const address = getContactInfos(state) && getContactInfos(state)[addressId] ? getContactInfos(state)[addressId] : {};
  const {addressType, ...restAddress} = address;

  // It should always be an update of existing address
  const newAddress = assign({}, restAddress, {isDefaultShippingAddress: true}, {isDefaultBillingAddress: false});

  return {addressType, address: newAddress};
};
