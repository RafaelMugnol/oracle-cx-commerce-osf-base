/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {identity, noop} from '@oracle-cx-commerce/utils/generic';
import {getBodyAsJson} from '@oracle-cx-commerce/endpoints/utils';
import {getGlobalContext} from '@oracle-cx-commerce/commerce-utils/selector';

const FORM_URLENCODED = new RegExp('application/x-www-form-urlencoded');

const PARAM = /{}/g;

const urlEncode = data => {
  const encodedData = new URLSearchParams();

  for (const [key, value] of Object.entries(data)) {
    encodedData.append(key, value);
  }

  return encodedData;
};

const getDefaultApiCatalog = () =>
  import('@oracle-cx-commerce/endpoints/utils/endpoint-factory/get-swagger-api-catalog');

/**
 * Create an endpoint factory for a particular swagger based API catalog.
 *
 * @param {*} options Specify all arguments in a named options map
 * @param {Array} options.apiCatalogPaths An array of swagger API catalog paths--e.g. ["/my/api-catalog"]
 * @param {Function} options.getApiCatalog A function that returns the origin (domain) on which the Swagger Document is hosted
 * @param {Function} options.getOrigin A function that returns the origin (domain) on which the APIs are running --e.g. location.origin
 * @param {Function} [options.getHeaders] A function that returns headers to be set on the requests
 * @returns {Function} An endpoint factory function for this API catalog
 */
export const createEndpointFactory = ({
  apiCatalogPaths,
  getApiCatalog,
  getOrigin = noop,
  getApiCatalogOrigin,
  getHeaders = identity
}) => {
  console.assert(
    apiCatalogPaths,
    'Invalid argument "apiCatalogPaths"--expected an array of catalog paths e.g. ["/my/api-catalog"]'
  );

  console.assert(
    !getApiCatalog || typeof getApiCatalog === 'function',
    'Invalid argument "getApiCatalog"--expected a function that returns api catalog'
  );

  let catalog;

  getApiCatalogOrigin = getApiCatalogOrigin || getOrigin;

  const getConfig = async context => {
    const {fetch, endpointId, state} = context;

    if (!catalog || !(await catalog)[endpointId]) {
      const fetchApiCatalog = async () => {
        const origin = getApiCatalogOrigin(context);

        const apiCalalogUrls = apiCatalogPaths.map(path => new URL(path, origin));

        const headers = {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        };

        const {isPreview} = getGlobalContext(state);

        const options = {
          // Passing cookies in preview mode causes errors
          credentials: isPreview ? 'omit' : 'same-origin',
          headers
        };

        const responses = await Promise.all(apiCalalogUrls.map(url => fetch(url, options)));

        return Promise.all(responses.map(response => response.json()));
      };

      if (!getApiCatalog) {
        getApiCatalog = (await getDefaultApiCatalog()).default;
      }

      catalog = getApiCatalog({fetchApiCatalog, ...context});
    }

    return (await catalog)[endpointId];
  };

  return (endpointId, {processInput = identity, processOutput = getBodyAsJson} = {}) => {
    console.assert(endpointId != null, 'Invalid argument "endpointId"--expected non-empty string or number');

    return {
      endpointId,

      async getRequest(payload = {}, state = {}) {
        const {fetch, location} = typeof self !== 'undefined' ? self : state.global;

        console.assert(typeof fetch === 'function', `Missing "fetch" function`);

        console.assert(typeof location === 'object', `Missing "location" object`);

        // Context is used to simply argument passing
        const context = {
          fetch,
          location,
          endpointId,
          payload,
          state
        };

        const config = await getConfig(context);

        console.assert(config, `"${endpointId}" is not a valid occ endpoint id`);

        console.assert(typeof config.url === 'string' && config.url.length > 0, 'Missing endpoint configuration "url"');

        // Add to context
        context.config = config;

        payload = processInput(payload, state);

        /*
          Create Request URL
         */
        const origin = getOrigin(context);

        const {params = [], query = {}} = payload;

        let matchCount = 0;

        const replacer = match => {
          return params.length > matchCount ? params[matchCount++] : match;
        };

        const url = new URL(config.url.replace(PARAM, replacer), origin);

        const queryEntries = query instanceof URLSearchParams ? query.entries() : Object.entries(query);
        for (const [key, value] of queryEntries) {
          if (value != null) {
            url.searchParams.append(key, value);
          }
        }

        // Add to context
        context.url = url;

        /*
          Create Request Options
         */
        const headers = {
          Accept: config.responseType || 'application/json',
          'Content-Type': config.requestType || 'application/json',
          // User specified headers (browser and server)
          ...getHeaders(context),
          // User specified headers passed as args--will override all previously set headers
          ...payload.headers
        };

        const body = FORM_URLENCODED.test(config.requestType) ? urlEncode(payload.body) : JSON.stringify(payload.body);

        const {isPreview} = getGlobalContext(state);

        const options = {
          // Passing cookies in preview mode causes errors
          credentials: isPreview ? 'omit' : 'same-origin',
          ...config,
          headers,
          body
        };

        return new Request(url, options);
      },

      getResponse(response, state = {}, payload = {}) {
        console.assert(response instanceof Response, 'Missing endpoint response');

        let json;

        response.getJson = async () => {
          if (json === undefined) {
            json = await processOutput(response, state, payload);
          }

          return json;
        };

        return response;
      }
    };
  };
};
