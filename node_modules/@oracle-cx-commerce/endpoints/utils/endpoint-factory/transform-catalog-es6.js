/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */

/**
 * Converts a string into camel-case.
 *
 * @param      {string}  text    The text to convert.
 * @return     {string}  The text converted to camel-case format.
 */
function camelCase(text) {
  const capitalize = s => s[0].toUpperCase() + s.slice(1);
  if (!text || typeof text !== 'string' || !text.trim()) {
    return;
  }
  const matches = text.trim().match(/^[a-z]+|[a-z]+|[A-Z][a-z]+|\d+|[A-Z]+(?![a-z])/g);
  const capitalizedString = matches.map(word => capitalize(word)).join('');

  return capitalizedString[0].toLowerCase() + capitalizedString.slice(1);
}

function transformCatalogToEndpointMapping(rawCatalog) {
  const catalog = {};
  const {basePath = '', paths = {}} = rawCatalog;

  for (const [pathName, pathValue] of Object.entries(paths)) {
    for (const [methodName, methodValue] of Object.entries(pathValue)) {
      const {consumes, produces} = methodValue;
      let {operationId = `${methodName}${basePath}${pathName}`} = methodValue;
      operationId = methodValue.operationId ? operationId : camelCase(operationId);

      catalog[operationId] = {
        id: operationId,
        url: basePath + pathName.replace(/{.*?}/g, '{}'),
        method: methodName
      };

      if (consumes) {
        catalog[operationId].requestType = consumes.join(',');
      }

      if (produces) {
        catalog[operationId].responseType = produces.join(',');
      }
    }
  }

  return catalog;
}
/**
 * Transform a swagger ApiCatalog into an endpoint mapping
 * @param {*} currentCatalog
 * @param {*} rawCatalog
 */
export function updateCatalog(currentCatalog, rawCatalog) {
  const transformedCatalog = transformCatalogToEndpointMapping(rawCatalog);

  return Object.assign(currentCatalog, transformedCatalog);
}
