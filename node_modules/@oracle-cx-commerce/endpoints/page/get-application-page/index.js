/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {createEndpoint, getBodyAsJson} from '@oracle-cx-commerce/endpoints/factory';
import {getCookieFromSetCookieHeader, getValueFromSetCookieHeader} from '@oracle-cx-commerce/utils/node';

import {getGlobalContext} from '@oracle-cx-commerce/commerce-utils/selector';
import {getPageId} from '@oracle-cx-commerce/utils/isomorphic';
import {noop} from '@oracle-cx-commerce/utils/generic';

// mapping of region types from DS number identifiers to their actual element types.
const TYPES = {
  100: 'header',
  101: 'main',
  102: 'footer'
};

const STRUCTURES = {
  100: 'flat',
  101: 'stack'
};

const transformRegions = (data, transformedPage, nested = false) => {
  let transformedRegions = {};

  for (const {
    components,
    name,
    displayName,
    repositoryId,
    type,
    width,
    structure,
    regions,
    metadata,
    cssClass
  } of data) {
    if (!nested) {
      // Add this region into the appropriate slot--header, main, footer.
      transformedPage[TYPES[type]].push(repositoryId);
    }

    // Create a region.
    transformedRegions[repositoryId] = {
      id: repositoryId,
      name: name || '',
      type: TYPES[type],
      structure: STRUCTURES[structure],
      widgets: structure === 101 ? [] : components.map(({repositoryId}) => repositoryId),
      width,
      metadata,
      displayName: displayName || '',
      cssClass: cssClass || ''
    };

    if (components) {
      for (const component of components) {
        if (component.regions) {
          transformedRegions = {
            ...transformedRegions,
            ...transformRegions(component.regions, transformedPage, true)
          };
        }
      }
    }

    if (structure === 101 && regions) {
      transformedRegions = {
        ...transformedRegions,
        ...transformRegions(regions, transformedPage, true)
      };
    }
  }

  return transformedRegions;
};

const transformStacks = data => {
  let transformedStacks = {};

  for (const {
    name,
    repositoryId,
    type,
    width,
    structure,
    regions,
    stackType,
    nextButton,
    previousButton,
    displayName,
    components
  } of data) {
    if (structure === 101) {
      // Create a stack.
      transformedStacks[repositoryId] = {
        id: repositoryId,
        name: name || '',
        stackId: stackType || repositoryId,
        type: TYPES[type],
        structure: STRUCTURES[structure],
        steps: regions ? regions.map(({repositoryId}) => repositoryId) : [],
        width,
        nextButton,
        previousButton,
        displayName
      };

      if (regions) {
        transformedStacks = {
          ...transformedStacks,
          ...transformStacks(regions)
        };
      }
    }

    if (components) {
      for (const component of components) {
        if (component.regions) {
          transformedStacks = {
            ...transformedStacks,
            ...transformStacks(component.regions)
          };
        }
      }
    }
  }

  return transformedStacks;
};

const transformWidgets = data => {
  let transformedWigets = {};

  for (const {regions, components, structure} of data) {
    for (const {repositoryId, component, regions, configuration, resources} of components) {
      // Create a widget.
      transformedWigets[repositoryId] = {
        ...configuration,
        ...resources,
        id: repositoryId,
        componentId: component.name,
        regions: regions && regions.map(({repositoryId}) => repositoryId)
      };

      if (regions) {
        transformedWigets = {
          ...transformedWigets,
          ...transformWidgets(regions)
        };
      }
    }

    if (structure === 101 && regions) {
      transformedWigets = {
        ...transformedWigets,
        ...transformWidgets(regions)
      };
    }
  }

  return transformedWigets;
};

const getVisitor = response => {
  const visitor = {earlyVisitInitialized: true};

  const cookie = response.headers.get('Set-Cookie');

  const visitorIdCookie = getCookieFromSetCookieHeader(cookie, 'xd.*?');

  if (visitorIdCookie) {
    // Visitor id is the bit before the ":"
    // eslint-disable-next-line prefer-destructuring
    visitor.visitorId = (getValueFromSetCookieHeader(visitorIdCookie, 'xd.*?') || '').split(':')[0];
  }

  const visitIdCookie = getCookieFromSetCookieHeader(cookie, 'xv.*?');

  if (visitIdCookie) {
    visitor.visitId = getValueFromSetCookieHeader(visitIdCookie, 'xv.*?');
  }

  return visitor;
};

const isCacheable = (data, response) => {
  let isCacheable = true;

  const cacheControl = (response.headers.get('Cache-Control') || '').toLowerCase();

  const {metadata: {secured} = {}} = data;

  if (response.ok !== true) {
    isCacheable = false;
  } else if (
    cacheControl.includes('no-store') ||
    cacheControl.includes('no-cache') ||
    (cacheControl.includes('must-revalidate') && cacheControl.includes('max-age=0'))
  ) {
    isCacheable = false;
  } else if (secured === true) {
    isCacheable = false;
  }

  return isCacheable;
};

const transformPage = (data, response, state) => {
  const currentLastPublishedTime = response.headers.get('lastpublishedtime');

  const {initialLastPublishedTime = currentLastPublishedTime} = getGlobalContext(state);

  const {baseURI, pageId, resources = {}, stylesheetURIs = []} = data;

  const transformedPage = {
    pageId,
    ...data.context,
    ...data.metadata,
    isCacheable: isCacheable(data, response)
  };

  // Ensure path is escaped to prevent XSS
  transformedPage.path = encodeURI(transformedPage.path);

  // Create named region slots: header, main, footer.
  for (const type of Object.values(TYPES)) {
    transformedPage[type] = [];
  }

  const {
    layout: {regions}
  } = data;

  //currentOrganization should be taken from profile repository as transformedPage might have stale data
  const delta = {
    clientRepository: {
      context: {
        global: {
          ...getVisitor(response),
          baseURI,
          isPreview: transformedPage.isPreview,
          locale: transformedPage.locale,
          lang: transformedPage.locale.replace('_', '-'),
          priceListGroup: transformedPage.currentPriceGroupId,
          site: transformedPage.siteId,
          initialLastPublishedTime,
          currencyCode: transformedPage.currencyCode,
          symbol: transformedPage.symbol
        },
        request: {
          page: pageId,
          productId: transformedPage.contextId,
          currentLastPublishedTime
        }
      }
    },
    pageRepository: {
      pages: {[pageId]: transformedPage},
      regions: transformRegions(regions, transformedPage),
      stacks: transformStacks(regions),
      widgets: transformWidgets(regions),
      resources,
      stylesheetURIs
    }
  };

  if (response.status === 401) {
    delta.clientRepository.session = {token: null, tokenType: null};
  }

  return delta;
};

const getBaseURI = (page, state) => {
  const {productionURL} = page.context;

  const locale = page.context.locale.replace('-', '_');

  const {baseUrl = '', path} = getGlobalContext(state);
  const siteContext = productionURL ? productionURL.substring(productionURL.indexOf('/') + 1) : '';

  let baseURI = baseUrl;

  if (siteContext && siteContext.length > 0 && path.includes(`/${siteContext}`)) {
    baseURI += `/${siteContext}`;
  }

  if (path.includes(`/${locale}`)) {
    baseURI += `/${locale}`;
  }

  baseURI += '/';

  return baseURI;
};

const hasLayout = ({context, layout, metadata, status}) => {
  return context && layout && metadata && status;
};

const isRedirect = ({status = {}}) => {
  return status.status && status.location;
};

export const processInput = (payload, state) => {
  const {application, baseURI, baseUrl} = getGlobalContext(state);

  const pageId = getPageId(payload.url, baseURI || `${baseUrl}/`);

  return {
    params: [application, pageId.replace(/^\//, '')]
  };
};

export const processOutput = async (response, state, payload) => {
  const json = await getBodyAsJson(response);

  let transformedJson;

  if (hasLayout(json) && !isRedirect(json)) {
    const baseURI = getBaseURI(json, state);

    const {getLocalPage = noop} = payload;

    const data = {
      ...json,
      ...getLocalPage(json),
      baseURI,
      pageId: getPageId(payload.url, baseURI)
    };

    transformedJson = transformPage(data, response, state);
  }

  return {
    ...transformedJson,
    json
  };
};

export default createEndpoint('getApplicationPage', {
  processInput,
  processOutput
});
