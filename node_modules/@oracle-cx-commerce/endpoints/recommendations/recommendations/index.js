/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {getProductionRecommendations, getRecommendationsRepository} from '@oracle-cx-commerce/commerce-utils/selector';
import {getBodyAsJson, populateError} from '@oracle-cx-commerce/endpoints/utils';

/**
 * Convert response data into an object to be merged into the application state.
 */
export const processOutput = async response => {
  const json = await getBodyAsJson(response);

  return response.ok ? {recommendationsRepository: json} : populateError(response, json);
};

/**
 * Return an object that implements the endpoint adapter interface.
 */
export default {
  /** The id of the endpoint */
  endpointId: 'recommendations',

  /**
   * Return a Fetch API Request object to be used for invoking the endpoint.
   *
   * @param payload Optional payload to be included in the request
   * @param state The current application state
   * @return Request object for invoking the endpoint via Fetch API
   */
  async getRequest(payload = {}, state = {}) {
    const {
      host: recsHost,
      port: recsPort,
      path: recsPath,
      tenantId,
      protocol: recsProtocol = ''
    } = getProductionRecommendations(state);

    if (!recsHost || !recsPath || !tenantId) {
      throw new Error('Invalid configuration for Recommendations');
    }

    const {visitorId, sessionId} = getRecommendationsRepository(state).tracking || {};
    let recsPortPart = '';
    if (recsPort && recsPort !== null && recsPort !== '' && recsPort !== '0') {
      recsPortPart = `:${recsPort}`;
    }
    let recsProtocolPart = '';
    if (recsProtocol) {
      recsProtocolPart = `${String(recsProtocol)}:`;
    }
    const recsHostPortPath = `${recsProtocolPart}//${recsHost}${recsPortPart}/${recsPath}`;
    // Get resources and params from payload
    const {resources, params = {}} = payload;

    if (!resources || !resources.length > 0) {
      throw new Error('Recommendations must have at least one resource');
    }

    // Note: reordering of resources so view is first and recommendations is last happens in the action.
    // eslint-disable-next-line spellcheck/spell-checker
    // TODO: Where do we want to do all the logic from SF1's recsRequest.js?
    const url = `${recsHostPortPath}/\
${resources.join('/')}/3.0/json/${tenantId}\
${visitorId ? `/${visitorId}` : ''}\
${sessionId ? `?sessionId=${sessionId}` : ''}`;

    // Do we need to set the content type header like in SF1?
    // The default appears to be: "text/plain;charset=UTF-8"
    const options = {
      method: 'POST',
      mode: 'cors',
      body: JSON.stringify(params)
    };

    return new Request(url, options);
  },

  /**
   * Return a Fetch API Response object containing data from the endpoint.
   *
   * @param response The Response object returned by the fetch call
   * @param state The current application state
   * @param payload Optional payload that was included in the request
   * @return Response object, augmented with an async getJson function to return
   * an object to be merged into the application state
   */
  getResponse(response, state = {}, payload = {}) {
    console.assert(response instanceof Response, 'Missing endpoint response');

    let json;
    response.getJson = async () => {
      if (json === undefined) {
        json = processOutput ? await processOutput(response, state, payload) : await getBodyAsJson(response);
      }

      return json;
    };

    return response;
  }
};
