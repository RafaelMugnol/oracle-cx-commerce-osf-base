/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */

const url = require('url');
const path = require('path');
const fs = require('fs');
const esbuild = require('esbuild');
const {requireFromString} = require('../utils/require-from-string');
const {DEFAULT_EXTERNAL} = require('../consts/defaults');
const alias = require('./plugins/alias');
const cssInJs = require('./plugins/css-in-js');
const {createManifest} = require('./utils/manifest');
const {parseOutputOptions} = require('./utils/parse-output-options');
const {readPackageJson} = require('../utils/read-package');

function createBuilder({
  appDir: absWorkingDir = process.cwd(),
  production: minify = true,
  watch = false,
  write = true
} = {}) {
  absWorkingDir = path.resolve(absWorkingDir);

  const min = minify ? 'min/' : '';

  const {occ: {external = [], esbuild: {loader = {}} = {}} = {}} = readPackageJson(absWorkingDir);

  const sharedOptions = {
    absWorkingDir,
    bundle: true,
    metafile: true,
    sourcemap: true,
    minify,
    watch,
    write,
    loader,
    drop: minify ? ['debugger', 'console'] : [],
    define: {
      __OCC_DEV__: !minify,
      __ENABLE_USER_TIMING_API__: !minify,
      'process.env.NODE_ENV': minify ? '"production"' : '"development"'
    }
  };

  const clientOptions = {
    ...sharedOptions,
    entryPoints: ['src/client.js'],
    entryNames: '[dir]/[name]-[hash]',
    outdir: `dist/esm/${min}`,
    target: 'es2020',
    format: 'esm',
    splitting: true,
    external: [],
    plugins: [alias(), cssInJs()]
  };

  const serverOptions = {
    ...sharedOptions,
    entryPoints: ['src/server.js'],
    outfile: `dist/cjs/${min}server.js`,
    target: 'node14.18',
    format: 'cjs',
    platform: 'node',
    external: [...DEFAULT_EXTERNAL, ...external],
    plugins: [alias(), cssInJs()]
  };

  function build(options) {
    const {outdir, outfile} = parseOutputOptions(options);

    const entrySpecifier = path.join(absWorkingDir, outfile);

    const buildResult = {
      listeners: new Map(),

      subscribe(listener) {
        if (!this.listeners.has(listener)) {
          this.listeners.set(listener, () => {
            if (this.listeners.has(listener)) {
              this.listeners.delete(listener);
            }
          });
        }

        return this.listeners.get(listener);
      },

      update(result, error) {
        Object.assign(this, {...result, error});

        for (const listener of this.listeners.keys()) {
          listener(this);
        }
      },

      async importEntry() {
        if (write) {
          if (options.format === 'cjs') {
            return require(entrySpecifier);
          }

          return import(url.pathToFileURL(entrySpecifier));
        }

        if (options.format === 'cjs') {
          const entryText = this.outputFiles.find(file => file.path === entrySpecifier).text;

          return requireFromString(entryText, entrySpecifier);
        }

        throw new Error('esm not supported...yet');

        //return import(`data:text/javascript,${entryText}`);
      }
    };

    if (watch) {
      watch = {
        onRebuild(error, result) {
          // TODO: duplicate onBuild callback
          if (write) {
            if (options.format === 'cjs') {
              try {
                delete require.cache[require.resolve(entrySpecifier)];
              } catch (error) {
                console.error(error.stack);
              }
            }

            if (!error) {
              fs.writeFileSync(path.join(absWorkingDir, outdir, 'meta.json'), JSON.stringify(result.metafile, null, 2));

              result.manifest = createManifest(result.metafile, options);

              fs.writeFileSync(
                path.join(absWorkingDir, outdir, 'manifest.json'),
                JSON.stringify(result.manifest, null, 2)
              );
            }
          }

          buildResult.update(result, error);
        }
      };
    }

    return esbuild.build({...options, watch}).then(result => {
      // TODO: duplicate onBuild callback
      result.manifest = createManifest(result.metafile, options);

      if (write) {
        fs.writeFileSync(path.join(absWorkingDir, outdir, 'meta.json'), JSON.stringify(result.metafile, null, 2));

        fs.writeFileSync(path.join(absWorkingDir, outdir, 'manifest.json'), JSON.stringify(result.manifest, null, 2));
      }

      buildResult.update(result);

      return buildResult;
    });
  }

  return {
    buildClient: () => build(clientOptions),
    buildServer: () => build(serverOptions),
    build: () => Promise.all([build(clientOptions), build(serverOptions)])
  };
}

module.exports = {
  createBuilder
};
