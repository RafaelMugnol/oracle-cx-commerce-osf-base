/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import React from 'react';
import PropTypes from 'prop-types';

const {useContext, useEffect} = React;

/*
  Collection of caches (one per application) to record whether a component style
  has already been rendered in a given application.

  NB This is to facilitate server-side rendering. During browser rendering 
  there is one user at a given time, so one application context is sufficient.
  During server-side rendering there are multiple simultaneous requests from 
  different users, so multiple application contexts are necessary.
 */
const styleTagAlreadyInDocumentCaches = new WeakMap();

const styleTagAlreadyInDocument = (store, id) => {
  if (!styleTagAlreadyInDocumentCaches.has(store)) {
    styleTagAlreadyInDocumentCaches.set(store, {});
  }

  const styleTagAlreadyInDocumentCache = styleTagAlreadyInDocumentCaches.get(store);

  if (!Object.prototype.hasOwnProperty.call(styleTagAlreadyInDocumentCache, id)) {
    styleTagAlreadyInDocumentCache[id] = true;

    return false;
  }

  return true;
};

/*
  Hoist style from body to head.
 */
const useCss = (id, css) =>
  useEffect(() => {
    // Already hoisted?
    if (!document.querySelector(`head>style[data-component="${id}"]`)) {
      // Insert into head
      const styleTag = document.createElement('style');

      styleTag.dataset.component = id;

      styleTag.append(document.createTextNode(css));

      document.head.append(styleTag);

      // "Remove" from body
      /*
        Unfortunately we can't remove the style tags from the body without React throwing errors.
        Instead we delete the style rules manually from the DOM.
        
        NB The style tags remain present in the markup, but inactive.
       */
      const styleSheet = document.querySelector(`body style[data-component="${id}"]`);

      if (styleSheet) {
        const {sheet} = styleSheet;
        const {length} = sheet.cssRules;

        for (let i = 0; i < length; i++) {
          sheet.deleteRule(0);
        }
      }
    }
  }, [css, id]);

/**
 * Applies the specified styles in the sub section
 */
const Styled = ({children, id, css}) => {
  const store = useContext(StoreContext);

  /*
    (2) After render (browser only)
    As the contents of the body is volatile (due to component instances being added and removed)
    it is sensible to hoist the style tag into the head which is less volatile, to avoid having
    destroy and recreate style tags.
   */
  useCss(id, css);

  /*
    (1) Render (browser & server)
    As it's not practical to render style tags into the head during server-side rendering
    we must render into the body; however, as multiple instance of the same component may be
    rendered into the boy we must ensure duplicate styles are not created.
   */
  return (
    <>
      {!styleTagAlreadyInDocument(store, id, css) && (
        <style
          data-component={id}
          // eslint-disable-next-line react/no-danger
          dangerouslySetInnerHTML={{__html: css}}
        />
      )}
      {children}
    </>
  );
};

Styled.propTypes = {
  /**
   * ID of the element
   */
  id: PropTypes.string.isRequired,

  /**
   * Css to be applied in the section
   */
  css: PropTypes.string,

  /**
   * Child nodes to by displayed
   */
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired
};

Styled.defaultProps = {
  css: undefined
};

export default Styled;
