/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useEffect} from 'react';
import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import {getCurrentPageId, isPublishDetected} from '@oracle-cx-commerce/commerce-utils/selector';
import {noop} from '@oracle-cx-commerce/utils/generic';
import PropTypes from 'prop-types';

const HASH = /#/;

const ABSOLUTE_URL = /^(http[s]?:\/\/|\/)/i;

const linkHasTarget = anchor => anchor.target;

const isLeftMouseClick = event => event.button === 0;

const isHashChange = url => HASH.test(url.href) && url.origin === location.origin && url.pathname === location.pathname;

const isModifiedEvent = event => {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

const spaNavigate = (action, url, onNavigate, redirect) => {
  history.replaceState(
    {
      top: document.documentElement.scrollTop,
      left: document.documentElement.scrollLeft,
      previousPath: history.state && history.state.previousPath
    },
    '',
    location.href
  );

  if (url.href === location.href || redirect) {
    history.replaceState({previousPath: location.pathname + location.search}, '', url.href);
  } else {
    history.pushState({previousPath: location.pathname + location.search}, '', url.href);
  }

  onNavigate();

  action('getApplicationPage', {url}).then(({json}) => {
    if (json && json.status && json.status.status && json.status.location) {
      // Server return redirect location so navigate there
      spaNavigate(action, new URL(json.status.location, document.baseURI), noop, true);
    }

    scrollTo({top: 0, left: 0});
  });
};

export const useNavigator = (defaultPath, onNavigate = noop) => {
  const {action, getState} = useContext(StoreContext);

  if (!defaultPath) {
    defaultPath = getCurrentPageId(getState()).replace('/', '');
  }

  return useCallback(
    (path = defaultPath, {redirect, target} = {}) => {
      const url = new URL(path, document.baseURI);
      if (target) {
        window.open(url.href, target);
      } else if (ABSOLUTE_URL.test(path) || isHashChange(url) || isPublishDetected(getState())) {
        if (redirect) {
          location.replace(path);
        } else {
          location.assign(path);
        }
      } else {
        spaNavigate(action, url, onNavigate, redirect);
      }
    },
    [action, defaultPath, getState, onNavigate]
  );
};

let isInitialized = false;

/*
  The Link component renders an anchor <a> tag that intercept clicks, suppressing the default behavior and calling the `getState({url})` action instead.

  NB Hash links and absolute url links are NOT intercepted and WILL cause a full page reload.
 */
const Link = ({children, onClick = noop, onNavigate = noop, tabIndex = undefined, ...props}) => {
  const {className, displayName, route, href, title, ariaLabel} = props;
  const {action, getState} = useContext(StoreContext);

  // Handle link click.
  const click = useCallback(
    event => {
      onClick(event);
      const anchor = event.target.closest('a');

      if (!anchor || !anchor.href) {
        return;
      }

      const url = new URL(anchor.href);

      if (
        !event.defaultPrevented &&
        isLeftMouseClick(event) &&
        !isModifiedEvent(event) &&
        !ABSOLUTE_URL.test(anchor.attributes.href.value) &&
        !linkHasTarget(anchor) &&
        !isHashChange(url) &&
        !isPublishDetected(getState())
      ) {
        event.preventDefault();

        spaNavigate(action, url, onNavigate);
      }
    },
    [action, getState, onClick, onNavigate]
  );

  // Handle back/forward buttons.
  const popstate = useCallback(
    event => {
      const {state: {top = 0, left = 0} = {}} = event;

      action('getApplicationPage', {url: location, popstate: true}).then(() => {
        scrollTo({top, left});
      });
    },
    [action]
  );

  // Run effect once and only once!
  useEffect(() => {
    if (isInitialized !== true) {
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }

      addEventListener('popstate', popstate);

      isInitialized = true;
    }
  }, [popstate]);

  return (
    <a
      className={className}
      href={href || route}
      title={title || displayName}
      onClick={click}
      tabIndex={tabIndex}
      aria-label={ariaLabel}
    >
      {typeof children === 'function' ? children(props) : children || displayName}
    </a>
  );
};

Link.propTypes = {
  /**
   * Child nodes to by displayed
   */
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),

  /**
   * Function to be called on click operation
   */
  onClick: PropTypes.func,

  /**
   * Function to be called on navigate operation
   */
  onNavigate: PropTypes.func,

  /**
   * tabIndex attribute for the anchor tag
   */
  tabIndex: PropTypes.number,

  /**
   * Class name attribute for anchor tag
   */
  className: PropTypes.string,

  /**
   * Href attribute for anchor tag
   */
  href: PropTypes.string,

  /**
   * Href attribute for anchor tag in case the 'href' prop is empty
   */
  route: PropTypes.string,

  /**
   * title and children attributes for anchor tag when title or children prop is empty
   */
  displayName: PropTypes.string,

  /**
   * title attribute for anchor tag
   */
  title: PropTypes.string,

  /**
   * aria-Label attribute for anchor tag
   */
  ariaLabel: PropTypes.string
};

Link.defaultProps = {
  children: undefined,
  onClick: noop,
  onNavigate: noop,
  tabIndex: undefined,
  className: undefined,
  href: undefined,
  route: undefined,
  displayName: undefined,
  title: undefined,
  ariaLabel: undefined
};

export default Link;
