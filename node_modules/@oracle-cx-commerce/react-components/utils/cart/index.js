/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {isEmptyObject, noop} from '@oracle-cx-commerce/utils/generic';
import {
  SHIPPING_GROUP_HARDGOOD,
  SHIPPING_GROUP_IN_STORE_PICKUP
} from '@oracle-cx-commerce/commerce-utils/constants/shipping';
import {OUT_OF_STOCK} from '@oracle-cx-commerce/commerce-utils/constants/cart';

/**
 * Sets the invalid quantity items and corresponding error messages when quantity is changed at current line item.
 * @param {*} setInvalidItems - Setter method for Invalid Items.
 * @param {*} commerceId - Commerce Id of the current line item.
 * @param {*} shippingGroupId - Shipping GroupId Id of the current line item.
 * @param {*} quantity - quantity of the current line item.
 * @param {*} errorMsg - Invalid quantity error message to be set.
 * @param {*} setInvalidItemsOnQuantityChange - Setter method for Object containing Invalid Items Based on Quantity Change.
 */
export const setInvalidItemsQtyAndErrorMessage = ({
  setInvalidItems = noop,
  setInvalidItemsOnQuantityChange = noop,
  shippingGroupId,
  commerceId,
  quantity = 0,
  errorMsg = ''
}) => {
  const itemRef = `${shippingGroupId}${commerceId}`;
  setInvalidItems(prevState => {
    let itemRefArrayNewState = prevState && prevState.length > 0 ? [...prevState] : [];

    if (!itemRefArrayNewState.indexOf(itemRef) !== -1) {
      itemRefArrayNewState = [...itemRefArrayNewState, itemRef];
    }

    return [...itemRefArrayNewState];
  });

  setInvalidItemsOnQuantityChange(prevInvalidItemsOnQuantityChangeState => {
    const invalidItemEntry = {quantity: quantity ? quantity : null, errorMsg: errorMsg ? errorMsg : ''};
    const prevInvalidQuantityItemsNewState =
      prevInvalidItemsOnQuantityChangeState && prevInvalidItemsOnQuantityChangeState.invalidItemsQtyAndErrorMsg
        ? {...prevInvalidItemsOnQuantityChangeState.invalidItemsQtyAndErrorMsg}
        : {};
    if (quantity !== 0 && errorMsg) {
      prevInvalidQuantityItemsNewState[itemRef] = invalidItemEntry;
    }

    return {
      ...prevInvalidItemsOnQuantityChangeState,
      invalidItemsQtyAndErrorMsg: {...prevInvalidQuantityItemsNewState}
    };
  });
};

/**
 * Get item quantity from existing shipping groups
 */
export const getTotalItemQuantityFromOtherSGs = ({
  skuId,
  selectedStore,
  isPickupInStoreOptionSelected,
  shippingGroups
}) => {
  let itemQtyInCart = 0;
  let locationBasedCommerceItem = null;
  let hardgoodSGCommerceItemTotalQty = 0;

  //check for the existing shipping group type of the current item
  if (Object.keys(shippingGroups).length > 0) {
    Object.keys(shippingGroups).forEach(function (shippingGroupId) {
      shippingGroups[shippingGroupId].items.forEach(function (item) {
        if (item.catRefId === skuId) {
          if (shippingGroups[shippingGroupId].type === SHIPPING_GROUP_HARDGOOD) {
            hardgoodSGCommerceItemTotalQty = hardgoodSGCommerceItemTotalQty + item.quantity;
          } else if (
            isPickupInStoreOptionSelected === true &&
            selectedStore.locationId &&
            shippingGroups[shippingGroupId].type === SHIPPING_GROUP_IN_STORE_PICKUP &&
            shippingGroups[shippingGroupId].store.locationId === selectedStore.locationId
          ) {
            locationBasedCommerceItem = item;
          }
        }
      });
    });

    if (locationBasedCommerceItem) {
      itemQtyInCart = locationBasedCommerceItem.quantity;
    } else if (
      (isPickupInStoreOptionSelected === false || !selectedStore.locationId) &&
      hardgoodSGCommerceItemTotalQty > 0
    ) {
      itemQtyInCart = hardgoodSGCommerceItemTotalQty;
    }
  }

  return itemQtyInCart;
};

/**
 * Failure handler
 */
const onFailure = (action, {error: {message = ''} = {}} = {}) => {
  action('notify', {level: 'error', message});
};

/**
 * It will make priceCart action to get order total.
 *
 * @param { action }  take store action
 */
export const priceOrderTotal = action => {
  return action('priceCart').then(response => {
    if (!response.ok) {
      onFailure(action, response);
    }
  });
};

/**
 * It invokes listProducts action with list of product Id from commerceItems provided.
 *
 * @param { action }  take store action
 * @param { commerceItems }  take list of commerceItems
 */
export const getProductDetails = (action, {commerceItems}) => {
  const productIds = [];
  for (const commerceId in commerceItems) {
    productIds.push(commerceItems[commerceId].productId);
  }
  action('listProducts', {productIds});
};

/**
 * It invokes getStockStatus action with list of product Ids and location from commerceItems provided.
 *
 * @param { action }  take store action
 * @param { commerceItems }  take list of commerceItems
 */
export const getOrderStockStatus = (action, {currentOrder = {}}) => {
  if (!isEmptyObject(currentOrder.shippingGroups) && !isEmptyObject(currentOrder.commerceItems)) {
    const products = [];
    const locationBasedProducts = new Set();
    const {commerceItems, shippingGroups} = currentOrder;
    const locationIds = [];
    // Iterate through each in-store shipping groups.
    for (const shippingGroupId in shippingGroups) {
      if (shippingGroups[shippingGroupId].type === SHIPPING_GROUP_IN_STORE_PICKUP) {
        const location =
          shippingGroups[shippingGroupId].items.length > 0 &&
          shippingGroups[shippingGroupId].store &&
          shippingGroups[shippingGroupId].store.locationId
            ? shippingGroups[shippingGroupId].store.locationId
            : '';

        if (location) {
          locationIds.push(location);
        }

        for (const index in Object.values(shippingGroups[shippingGroupId].items)) {
          const item = shippingGroups[shippingGroupId].items[index];
          if (item && item.commerceId) {
            const productDetails = `${commerceItems[item.commerceId].productId}:${
              commerceItems[item.commerceId].catRefId
            }`;
            locationBasedProducts.add(productDetails);
          }
        }
      }
    }

    for (const commerceId in commerceItems) {
      const productDetails = `${commerceItems[commerceId].productId}:${commerceItems[commerceId].catRefId}`;
      products.push(productDetails);
    }
    // default location inventory for all products.
    action('getStockStatus', {
      products,
      actualStockStatus: true
    });

    // location based on product inventory
    if (locationBasedProducts.size > 0) {
      action('getStockStatus', {
        products: Array.from(locationBasedProducts),
        locationIds: locationIds.toString(),
        actualStockStatus: true
      });
    }
  }
};

/**
 * It invoke getGiftWithPurchaseItemChoicesForCart action with list of product Ids and location from commerceItems provided.
 * @param { action }  take store action
 * @param { giftItem }  take the giftItem
 * @function { onSuccess }  take the success callback function
 */

export const getGWPProductWithVariants = (action, {giftItem}, onSuccess = noop) => {
  action('getGiftWithPurchaseItemChoicesForCart', {
    giftWithPurchaseDetail: giftItem.giftWithPurchaseDetail,
    giftWithPurchaseType: giftItem.giftWithPurchaseType
  })
    .then(response => {
      if (response.ok) {
        const products = [];
        products.push(giftItem.giftWithPurchaseDetail);
        action('getStockStatus', {
          products,
          expandStockDetails: true
        });
        onSuccess(giftItem);
      } else {
        onFailure(action, {response});
      }
    })
    .catch(error => {
      onFailure(action, {error});
    });
};

/**
 * Constructs and returns the payload for Switching the Delivery Option for current line item.
 * @param {*} relationships - Relationships object.
 * @param {*} shippingGroupId - Current Shipping Group Id.
 * @param {*} commerceItemFound - Object of commerce Item found from existing cart.
 * @param {*} shippingGroupFound - Object of shipping Group found from existing cart.
 * @param {*} existingRelationShip - Object of existing Relationship.
 * @param {*} currentRelationShip - Object of currently Selected Relationship.
 */
export const getPayloadForSwitchingDeliveryOption = ({
  relationships,
  currentShippingGroupId,
  targetShippingGroupId,
  existingRelationShip,
  currentRelationShip
}) => {
  let newRelationshipItemQuantity = 0;

  newRelationshipItemQuantity =
    currentRelationShip.quantity + (existingRelationShip ? existingRelationShip.quantity : 0);

  const newRelationship = {
    quantity: newRelationshipItemQuantity,
    commerceItemId: currentRelationShip.commerceId,
    shippingGroupId: targetShippingGroupId
  };
  currentRelationShip = {
    quantity: 0,
    commerceItemId: currentRelationShip.commerceId,
    shippingGroupId: currentShippingGroupId
  };
  relationships.push(currentRelationShip);
  relationships.push(newRelationship);

  return {relationships};
};

/**
 * Sets the deliveryMethodChanged boolean value
 * @param {*} setSelections - Setter method of selections object from container context
 * @param {*} value - The boolean value to be set.
 */
export const setDeliveryMethodChanged = (setSelections, value) => {
  setSelections(prevState => {
    return {
      ...prevState,
      isDeliveryMethodChanged: value
    };
  });
};

/**
 * Sets the quantityValidated boolean value
 * @param {*} setSelections - Setter method of selections object from container context
 * @param {*} value - The boolean value to be set.
 */
export const setQuantityValidated = (setSelections, value) => {
  setSelections(prevState => {
    return {
      ...prevState,
      isQuantityValidated: value
    };
  });
};

/**
 * Removes the current line item from Invalid Cart Line Items Array.
 */
export const removeCurrentItemFromInvalidItems = ({
  shippingGroupId,
  commerceId,
  setInvalidItems = noop,
  setInvalidItemsOnQuantityChange = noop
}) => {
  //Update the invalid item list by filtering the current valid line item.
  const itemRef = `${shippingGroupId}${commerceId}`;
  setInvalidItems(prevState => {
    let itemRefArrayNewState = prevState && prevState.length > 0 ? [...prevState] : [];
    //Filter Current Item from existing Invalid Item list
    itemRefArrayNewState = itemRefArrayNewState.filter(value => {
      return value !== itemRef;
    });

    return [...itemRefArrayNewState];
  });
  setInvalidItemsOnQuantityChange(prevInvalidItemsOnQuantityChangeState => {
    const prevInvalidQuantityItemsNewState =
      prevInvalidItemsOnQuantityChangeState && prevInvalidItemsOnQuantityChangeState.invalidItemsQtyAndErrorMsg
        ? {...prevInvalidItemsOnQuantityChangeState.invalidItemsQtyAndErrorMsg}
        : {};

    delete prevInvalidQuantityItemsNewState[itemRef];

    return {
      ...prevInvalidItemsOnQuantityChangeState,
      invalidItemsQtyAndErrorMsg: {...prevInvalidQuantityItemsNewState}
    };
  });
};

/**
 * Removes all invalid items based on  the current line item from Invalid Cart Line Items Array.
 */
export const removeInvalidItemsByCommerceId = ({
  invalidItemKeys,
  commerceId,
  setInvalidItems = noop,
  setInvalidItemsOnQuantityChange = noop
}) => {
  invalidItemKeys.forEach(function (invalidItemKey) {
    const shippingGroupIdOfInvalidItem = invalidItemKey.replace(commerceId, '');
    //Update the invalid item list by filtering the current valid line item.
    const itemRef = `${shippingGroupIdOfInvalidItem}${commerceId}`;
    setInvalidItems(prevState => {
      let itemRefArrayNewState = prevState && prevState.length > 0 ? [...prevState] : [];
      itemRefArrayNewState = itemRefArrayNewState.filter(value => {
        return value !== itemRef;
      });

      return [...itemRefArrayNewState];
    });
    setInvalidItemsOnQuantityChange(prevInvalidItemsOnQuantityChangeState => {
      const prevInvalidQuantityItemsNewState =
        prevInvalidItemsOnQuantityChangeState && prevInvalidItemsOnQuantityChangeState.invalidItemsQtyAndErrorMsg
          ? {...prevInvalidItemsOnQuantityChangeState.invalidItemsQtyAndErrorMsg}
          : {};

      delete prevInvalidQuantityItemsNewState[itemRef];

      return {
        ...prevInvalidItemsOnQuantityChangeState,
        invalidItemsQtyAndErrorMsg: {...prevInvalidQuantityItemsNewState}
      };
    });
  });
};

/**
 * get all the shipping GroupIds for a commerce item
 * @param {*} currentOrder - Current Order object which contains all the latest Shipping Groups.
 */
export const getShippingGroupIdsOfCommerceItem = (currentOrder = {}) => {
  const shippingGroupIdsOfCommerceItem = {};
  for (const shippingGroupId in currentOrder.shippingGroups) {
    const shippingGroup = currentOrder.shippingGroups[shippingGroupId];
    for (let index = 0; index < shippingGroup.items.length; index++) {
      const item = shippingGroup.items[index];
      if (!shippingGroupIdsOfCommerceItem[item.commerceId]) {
        shippingGroupIdsOfCommerceItem[item.commerceId] = [shippingGroupId];
      } else {
        shippingGroupIdsOfCommerceItem[item.commerceId].push(shippingGroupId);
      }
    }

    return shippingGroupIdsOfCommerceItem;
  }
};

/**
 * Updates/Corrects the invalid line Items quantity based on the current commerce item.
 * @param {*} relationships - Current Commerce Item based Relationships object.
 * @param {*} setInvalidItems - Setter method for Invalid Items.
 * @param {*} commerceId - Commerce Id of the current line item.
 * @param {*} shippingGroupId - Shipping GroupId Id of the current line item.
 * @param {*} setSelections - Setter method of Selections Object.
 * @param {*} currentOrder - Current Order object which contains latest Shipping Groups.
 * @param {*} totalQtyAvailable - Total commerce item quantity available for update.
 * @param {*} setErrorMessage - Setter method of Error Message Object.
 * @param {*} setInvalidItemsOnQuantityChange - Setter method for Object containing Invalid Items Based on Quantity Change.
 */
export const updateInvalidCommerceItemsQty = async ({
  relationships = [],
  setInvalidItems = noop,
  commerceId,
  shippingGroupId,
  setSelections,
  currentOrder,
  totalQtyAvailable = 0,
  setErrorMessage = noop,
  setInvalidItemsOnQuantityChange = noop,
  action,
  onNotOk
}) => {
  let invalidItemKeys = [];
  const {shippingGroups = {}} = currentOrder;
  // Boolean flag to indicate whether the total quantity of the same Commerce Item available at different Home Delivery SGs is valid or not.
  let totalQty = relationships.length === 1 ? relationships[0].quantity : 0;
  setInvalidItemsOnQuantityChange(prevState => {
    //const itemRef = shippingGroupId + commerceItemId;
    // First Get All the keys containing the Commerce Item Id
    invalidItemKeys = Object.keys(prevState.invalidItemsQtyAndErrorMsg).filter(function (propertyName) {
      return propertyName.indexOf(commerceId) !== -1;
    });
    if (invalidItemKeys.length > 0) {
      const prevInvalidQuantityItemsNewState =
        prevState && prevState.invalidItemsQtyAndErrorMsg ? {...prevState.invalidItemsQtyAndErrorMsg} : {};

      invalidItemKeys.forEach(function (invalidItemKey) {
        totalQty = totalQty + prevInvalidQuantityItemsNewState[invalidItemKey].quantity;
      });

      //Before updating the quantity at each invalid item, first check whether quantity of the invalid item available at different SGs is within limit or not.
      if (totalQty <= totalQtyAvailable) {
        invalidItemKeys.forEach(function (invalidItemKey) {
          const shippingGroupIdOfInvalidItem = invalidItemKey.replace(commerceId, '');
          //construct and add newRelationship only if the SG type is Home Delivery
          if (shippingGroups && shippingGroups[shippingGroupIdOfInvalidItem].type === SHIPPING_GROUP_HARDGOOD) {
            const newRelationship = {
              quantity: prevInvalidQuantityItemsNewState[invalidItemKey].quantity,
              commerceItemId: commerceId,
              shippingGroupId: shippingGroupIdOfInvalidItem,
              updateItemQuantity: true
            };
            relationships.push(newRelationship);
          }
        });

        // Now Add quantity of the same Commerce Item available at different valid Home Delivery SGs,
        // Except the current line quantity as it already present in relationships object.
        const shippingGroupIdsOfCommerceItem = getShippingGroupIdsOfCommerceItem(currentOrder);
        const shippingGroupIdsOfCurrentItem = shippingGroupIdsOfCommerceItem[commerceId];

        for (let index = 0; shippingGroupIdsOfCurrentItem && index < shippingGroupIdsOfCurrentItem.length; index++) {
          const shippingGroupIdOfItem = shippingGroupIdsOfCurrentItem[index];
          const invalidItemKey = `${shippingGroupIdOfItem}${commerceId}`;
          if (
            shippingGroups &&
            shippingGroups[shippingGroupIdOfItem].type === SHIPPING_GROUP_HARDGOOD &&
            invalidItemKeys.indexOf(invalidItemKey) === -1 &&
            shippingGroupId !== shippingGroupIdOfItem
          ) {
            // Get the commerce item quantity from the respective SG.
            const commerceItemFromSG = shippingGroups[shippingGroupIdOfItem].items.find(item => {
              return item.commerceId === commerceId;
            });

            if (commerceItemFromSG) {
              totalQty = totalQty + commerceItemFromSG.quantity;
              const newRelationship = {
                quantity: commerceItemFromSG.quantity,
                commerceItemId: commerceId,
                shippingGroupId: shippingGroupIdOfItem,
                updateItemQuantity: true
              };
              relationships.push(newRelationship);
            }
          }
        }
      }
    }

    return {...prevState};
  });
  const payload = {relationships};
  // Now invoke action to update Qty for each Invalid Item of same commerce Item type.
  if (shippingGroups && totalQty <= totalQtyAvailable) {
    const response = await action('relateShippingGroupsToCartItems', payload);
    if (!response.ok) {
      onNotOk(response);
    } else {
      setSelections(prevState => {
        return {
          ...prevState,
          isPickupInStoreOptionSelected: false,
          selectedStore: {}
        };
      });
      removeInvalidItemsByCommerceId({
        invalidItemKeys,
        commerceId,
        setInvalidItems,
        setInvalidItemsOnQuantityChange
      });
      setErrorMessage('');
    }
  }
};

/**
 * Returns all the product names which are having inventory status as Out of Stock.
 * @param {*} currentOrder - Current Order object.
 * @param {*} skuInventory - Inventory Details of the Sku.
 */
export const getOutOfStockProductNames = ({currentOrder, skuInventory}) => {
  const {shippingGroups, commerceItems} = currentOrder;
  const productNames = [];

  for (const commerceId in commerceItems) {
    const commerceItem = commerceItems[commerceId];
    const shippingGroupIdsOfCommerceItem = getShippingGroupIdsOfCommerceItem(currentOrder);
    const shippingGroupIds = shippingGroupIdsOfCommerceItem[commerceId];
    for (let j = 0; shippingGroupIds && j < shippingGroupIds.length; j++) {
      const shippingGroupId = shippingGroupIds[j];
      const location =
        shippingGroups[shippingGroupId] &&
        shippingGroups[shippingGroupId].store &&
        shippingGroups[shippingGroupId].store.locationId
          ? shippingGroups[shippingGroupId].store.locationId
          : 'default';
      const inventory = skuInventory[commerceItem.catRefId] ? skuInventory[commerceItem.catRefId][location] : {};
      if (inventory && inventory.stockStatus === OUT_OF_STOCK) {
        productNames.push(commerceItem.displayName);
        break;
      }
    }
  }

  return productNames;
};

/**
 * Builds pdp url for commerce item
 * For shared cart, adds production url to the commerce item route
 * @param {*} object
 * @returns
 */
export const buildPdpUrl = ({commerceItem, cartItemSite, currentSiteId}) => {
  let pdpUrl = commerceItem.route;

  if (pdpUrl.startsWith('/')) {
    pdpUrl = pdpUrl.slice(1);
  }
  if (!isEmptyObject(cartItemSite) && currentSiteId !== cartItemSite.id) {
    let pdpSiteBasedUrl = `${cartItemSite.productionURL}/${pdpUrl}`;
    if (!pdpSiteBasedUrl.match(/^http?:\/\//i) && !pdpSiteBasedUrl.match(/^https?:\/\//i)) {
      pdpSiteBasedUrl = `//${pdpSiteBasedUrl}`;
    }
    pdpUrl = pdpSiteBasedUrl;
  }
  if (commerceItem && commerceItem.variant && commerceItem.variant.length > 0) {
    const queryString = `?variantName=${commerceItem.variant[0].optionName}&variantValue=${commerceItem.variant[0].optionValue}`;
    pdpUrl = pdpUrl + queryString;
  }

  return pdpUrl;
};
