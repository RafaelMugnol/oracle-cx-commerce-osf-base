/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import {useEffect, useContext, useRef, useState} from 'react';
import {CartContext, StoreContext, CartItemContext} from '@oracle-cx-commerce/react-ui/contexts';
import {isEmptyObject, t, noop} from '@oracle-cx-commerce/utils/generic';
import {useSelector} from '@oracle-cx-commerce/react-components/provider';
import {getSkuInventory, getSite, getCurrentSiteId} from '@oracle-cx-commerce/commerce-utils/selector';
import {
  getOrderStockStatus,
  priceOrderTotal,
  getProductDetails,
  buildPdpUrl,
  setInvalidItemsQtyAndErrorMessage
} from '@oracle-cx-commerce/react-components/utils/cart';
import {SHIPPING_GROUP_HARDGOOD} from '@oracle-cx-commerce/commerce-utils/constants/shipping';
import {IN_STOCK, PREORDERABLE, BACKORDERABLE, OUT_OF_STOCK} from '@oracle-cx-commerce/commerce-utils/constants/cart';
import {ORDER_STATE_QUOTED} from '@oracle-cx-commerce/commerce-utils/constants';

/**
 * Reprices the current incomplete order on page load.
 */
export const useCartInitializer = (currentOrder, isGetCartInProgress) => {
  //context
  const {action} = useContext(StoreContext);
  const count = useRef(0);

  const {commerceItems = {}, state} = currentOrder;

  useEffect(() => {
    if (isGetCartInProgress !== 1 && !isEmptyObject(commerceItems)) {
      if (count.current === 0) {
        count.current++;
        // Reprice should be executed one time only.
        if (state !== ORDER_STATE_QUOTED) {
          priceOrderTotal(action);
        }
        getOrderStockStatus(action, {currentOrder});
        getProductDetails(action, {commerceItems});
      }
    }
  }, [action, currentOrder, commerceItems, isGetCartInProgress, state]);
};

/**
 * Sets the proper error message for the cart item based on invalid quantity and clears out the error message
 * if invalidItemsQtyAndErrorMsg object doesn't contain any entries based on current commerce item.
 */
export const useCartItemErrorMessage = ({
  setErrorMessage = noop,
  invalidItemsOnQuantityChange,
  shippingGroups,
  shippingGroupId,
  shippingGroupCommerceItem,
  skuInventory,
  itemLocation,
  quantity,
  messageInsufficientStock,
  messageInsufficientStockAtStore,
  messagePartialPreOrder,
  messagePartialBackOrder,
  messageItemNoLongerAvailable
}) => {
  useEffect(() => {
    if (invalidItemsOnQuantityChange && invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg) {
      if (
        (Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).length !== 0 &&
          Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).filter(function (invalidItemKey) {
            return (
              invalidItemKey.indexOf(shippingGroupCommerceItem.commerceId) > -1 &&
              shippingGroups[shippingGroupId].type ===
                shippingGroups[invalidItemKey.replace(shippingGroupCommerceItem.commerceId, '')].type
            );
          }).length === 0) ||
        Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).length === 0
      ) {
        if (skuInventory[itemLocation]) {
          const {
            inStockQuantity,
            orderableQuantity,
            productId,
            catRefId,
            stockStatus,
            backOrderableQuantity,
            preOrderableQuantity
          } = skuInventory[itemLocation];
          if (productId === shippingGroupCommerceItem.productId && catRefId === shippingGroupCommerceItem.catRefId) {
            if (stockStatus === IN_STOCK || stockStatus === PREORDERABLE || stockStatus === BACKORDERABLE) {
              if (quantity <= orderableQuantity) {
                if (inStockQuantity > 0 && quantity < inStockQuantity) {
                  setErrorMessage('');
                } else if (inStockQuantity > 0 && quantity > inStockQuantity) {
                  if (backOrderableQuantity > 0) {
                    setErrorMessage(t(messagePartialBackOrder, {MAXQUANTITY: inStockQuantity}));
                  } else if (preOrderableQuantity > 0) {
                    setErrorMessage(t(messagePartialPreOrder, {MAXQUANTITY: inStockQuantity}));
                  }
                }
              } else if (itemLocation === 'default') {
                setErrorMessage(t(messageInsufficientStock, {MAXQUANTITY: inStockQuantity}));
              } else {
                setErrorMessage(t(messageInsufficientStockAtStore, {MAXQUANTITY: inStockQuantity}));
              }
            } else if (stockStatus === OUT_OF_STOCK) {
              setErrorMessage(t(messageItemNoLongerAvailable));
            }
          }
        }
      } else if (
        (Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).length !== 0 &&
          invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg[
            `${shippingGroupId}${shippingGroupCommerceItem.commerceId}`
          ]) ||
        (shippingGroups[shippingGroupId].type === SHIPPING_GROUP_HARDGOOD &&
          Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).length !== 0 &&
          Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).some(function (invalidItemKey) {
            return (
              invalidItemKey.indexOf(shippingGroupCommerceItem.commerceId) > -1 &&
              shippingGroups[shippingGroupId].type ===
                shippingGroups[invalidItemKey.replace(shippingGroupCommerceItem.commerceId, '')].type
            );
          }))
      ) {
        setErrorMessage(
          invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg[
            Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).find(function (invalidItemKey) {
              return (
                invalidItemKey.indexOf(shippingGroupCommerceItem.commerceId) > -1 &&
                shippingGroups[shippingGroupId].type ===
                  shippingGroups[invalidItemKey.replace(shippingGroupCommerceItem.commerceId, '')].type
              );
            })
          ].errorMsg
        );
      }
    }
  }, [
    invalidItemsOnQuantityChange,
    invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg,
    itemLocation,
    messageInsufficientStock,
    messageInsufficientStockAtStore,
    messageItemNoLongerAvailable,
    messagePartialBackOrder,
    messagePartialPreOrder,
    quantity,
    setErrorMessage,
    shippingGroupCommerceItem.catRefId,
    shippingGroupCommerceItem.commerceId,
    shippingGroupCommerceItem.productId,
    shippingGroupId,
    shippingGroups,
    skuInventory
  ]);
};

/**
 * Sets the cart status to invalid if any invalid presents in the cart and
 * Returns the setter method for invalid items.
 */
export const useCartState = () => {
  // setter method of cartStatus state variable of cart container
  const {setCartStatus} = useContext(CartContext);
  // state variable to hold the list of invalid items in the cart
  const [invalidItems, setInvalidItems] = useState([]);

  // state variable to hold the quantity and error message details of invalid items
  // based on the quantity change in the cart
  const [invalidItemsOnQuantityChange, setInvalidItemsOnQuantityChange] = useState({
    invalidItemsQtyAndErrorMsg: {}
  });

  // sets isCartInValid as false if cart has any invalid items else it is set to true
  useEffect(() => {
    if (invalidItems && invalidItems.length > 0) {
      setCartStatus(prevState => {
        return {...prevState, isCartInValid: true};
      });
    } else {
      setCartStatus(prevState => {
        return {...prevState, isCartInValid: false};
      });
    }
  }, [invalidItems, setCartStatus]);

  return {setInvalidItems, invalidItemsOnQuantityChange, setInvalidItemsOnQuantityChange};
};

/**
 * It returns the cart item related data.
 * Also returns cartItemDetails with any invalid items in the cart and corresponding error message.
 * @param {*} commerceItem - Current commerce item in the cart
 * @param {*} shippingGroupCommerceItem - commerce item from the current shipping group
 * @param {*} shippingGroups - Shipping Groups Object array of the current order
 * @param {*} shippingGroupId - Current shipping group ID.
 * @param {*} showItemPrice - Boolean flag to indicate whether to display individual item price of same sku in case of GWP.
 * @param {*} pdpUrlNotRequired - Boolean flag to indicate whether to PDP url is required or not.
 * @param {*} setInvalidItems - Setter method for invalid items of the cart.
 * @param {*} messageInsufficientStock - Message specifying insufficient stock.
 * @param {*} shippingGroupType - Specifies whether shipping group type is 'hardgood' or 'instorepickup'.
 * @param {*} selections - Selections object from the container context.
 * @returns Object {
 *  string : pdpUrl : product page url constructed with variant selected
 *  boolean : isItemInValid : true if item is valid else false
 *  boolean : isItemOutOfStock : true if item is out of stock else false
 *  string : itemLocation : returns location based on shipping group default value is "default"
 *  Object : skuInventory : returns inventory object of the selected sku and location
 * }
 */
export const useCartItemState = ({
  commerceItem,
  shippingGroupCommerceItem,
  shippingGroups,
  shippingGroupId,
  showItemPrice,
  pdpUrlNotRequired = false,
  setInvalidItems = noop,
  setInvalidItemsOnQuantityChange = noop,
  messageInsufficientStock,
  messageInsufficientStockAtStore,
  shippingGroupType = null,
  selections = {},
  triggerRemoveItem
}) => {
  const [errorMessage, setErrorMessage] = useState('');
  const [quantity, setQuantity] = useState(commerceItem.quantity);

  const {siteId} = commerceItem;
  const {getState} = useContext(StoreContext);
  const cartItemSite = getSite(getState(), {siteId});
  const currentSiteId = getCurrentSiteId(getState());

  /** Container Context Data */
  const {selectedStore = {}, isPickupInStoreOptionSelected = false} = selections;
  let isItemInValid,
    pdpUrl = '',
    itemLocation = 'default',
    isItemOutOfStock = false;

  const skuInventory = useSelector(getSkuInventory, {skuId: commerceItem.catRefId});
  useEffect(() => {
    if (!isEmptyObject(commerceItem) && !isEmptyObject(skuInventory)) {
      let errorMsg = '';
      if (isItemOutOfStock) {
        if (itemLocation === 'default') {
          errorMsg = t(messageInsufficientStock, {MAXQUANTITY: skuInventory[itemLocation].orderableQuantity});
          setErrorMessage(errorMsg);
          setQuantity(commerceItem.quantity);
        } else {
          errorMsg = messageInsufficientStockAtStore;
          setErrorMessage(errorMsg);
          setQuantity(commerceItem.quantity);
        }
        setInvalidItemsQtyAndErrorMessage({
          setInvalidItems,
          setInvalidItemsOnQuantityChange,
          shippingGroupId,
          commerceId: commerceItem.id,
          quantity: commerceItem.quantity,
          errorMsg
        });
      }
      if (isPickupInStoreOptionSelected && !selectedStore.locationId) {
        setInvalidItemsQtyAndErrorMessage({
          setInvalidItems,
          setInvalidItemsOnQuantityChange,
          shippingGroupId,
          commerceId: commerceItem.id,
          quantity: 0
        });
      }
    }
  }, [
    commerceItem,
    shippingGroupId,
    skuInventory,
    itemLocation,
    setErrorMessage,
    isItemOutOfStock,
    isPickupInStoreOptionSelected,
    selectedStore.locationId,
    setInvalidItems,
    messageInsufficientStock,
    messageInsufficientStockAtStore,
    setInvalidItemsOnQuantityChange,
    shippingGroups
  ]);

  if (!pdpUrlNotRequired) {
    if (commerceItem.route) {
      pdpUrl = buildPdpUrl({commerceItem, cartItemSite, currentSiteId});
    }
  }

  if (!isEmptyObject(commerceItem) && !isEmptyObject(skuInventory) && shippingGroupId) {
    itemLocation =
      shippingGroups[shippingGroupId] &&
      shippingGroups[shippingGroupId].items.length > 0 &&
      shippingGroups[shippingGroupId].store &&
      shippingGroups[shippingGroupId].store.locationId
        ? shippingGroups[shippingGroupId].store.locationId
        : 'default';
    if (
      !commerceItem.isItemValid ||
      (skuInventory[itemLocation] && skuInventory[itemLocation].stockStatus === 'OUT_OF_STOCK')
    ) {
      isItemInValid = true;
    }
    if (
      skuInventory[itemLocation] &&
      shippingGroupCommerceItem.quantity > skuInventory[itemLocation].orderableQuantity
    ) {
      isItemOutOfStock = true;
    }
  }

  // Cart context provider data set
  const cartItemDetails = {
    shippingGroupCommerceItem,
    commerceItem,
    shippingGroupId,
    errorMessage,
    setErrorMessage,
    showItemPrice,
    skuInventory,
    setInvalidItems,
    itemLocation,
    pdpUrl,
    shippingGroupType,
    triggerRemoveItem,
    quantity,
    setQuantity
  };

  return {cartItemDetails, pdpUrl, isItemInValid, isItemOutOfStock, itemLocation, skuInventory};
};

/**
 * It returns the site related data for a cart item.
 */
export const useGetCartItemSiteInfo = () => {
  const {commerceItem = {}} = useContext(CartItemContext);
  const {getState} = useContext(StoreContext);

  const {siteId} = commerceItem;
  const site = getSite(getState(), {siteId});
  let favicon, siteName;

  if (!isEmptyObject(site)) {
    favicon = site.favicon;
    siteName = site.name;
  }

  return {
    siteName,
    favicon
  };
};
