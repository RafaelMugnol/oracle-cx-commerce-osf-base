/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {
  CYBERSOURCE_SOP,
  ORDER_STATE_INCOMPLETE,
  ORDER_STATE_PENDING_PAYMENT,
  ORDER_STATE_QUOTED,
  ORDER_STATE_SUBMITTED,
  PAGE_CHECKOUT_ORDER_CONFIRMATION_LINK,
  PAGE_CHECKOUT_PAYER_AUTHENTICATION_LINK,
  PAGE_WEB_CHECKOUT_RESPONSE_LINK,
  PAYER_AUTH_REQUIRED,
  PAYMENT_METHOD_CREDIT_CARD,
  PAYMENT_METHOD_CUSTOM_CURRENCY,
  PAYMENT_METHOD_ONLINE_PAYMENT_GROUP,
  PAYMENT_STATE_AUTHORIZED,
  PAYMENT_STATE_AUTHORIZE_FAILED,
  PAYMENT_STATE_INITIAL,
  PAYMENT_STATE_PAYMENT_DEFERRED,
  PAYMENT_STATE_PAYMENT_REQUEST_ACCEPTED,
  PAYMENT_STATE_PENDING_AUTHORIZATION,
  PAYMENT_STATE_SETTLED,
  PAYMENT_TYPE_GIFTCARD,
  PAYMENT_TYPE_STORECREDIT,
  SHIPPING_GROUP_IN_STORE_PICKUP
} from '@oracle-cx-commerce/commerce-utils/constants';
import {
  getCurrentOrder,
  getCurrentOrderId,
  getCurrentOrderScheduleInfo,
  getPaymentConfigurations,
  getSessionContext
} from '@oracle-cx-commerce/commerce-utils/selector';
/* eslint max-lines: ['error', {max: 1000, skipBlankLines: true, skipComments: true}] */
import {isEmptyObject, isObject} from '@oracle-cx-commerce/utils/generic';

/**
 * Get card type based on iin pattern.
 * @param {String} cardNumber The card number
 * @param {Object} cardTypes The card types
 */
export const getCardType = (cardNumber, cardTypes = {}) => {
  if (!cardNumber || isEmptyObject(cardTypes)) {
    return {};
  }
  let cardType = {};
  for (const [cardTypeId, {iin}] of Object.entries(cardTypes)) {
    const iinPattern = new RegExp(`^(${iin})`);
    if (cardNumber.match(iinPattern)) {
      cardType = cardTypes[cardTypeId];
      break;
    }
  }

  return cardType;
};

/**
 * Formats the card number based on the card type
 * @param {String} cardNumber The card number
 * @param {String} cardType The card type
 */
export const formatCardNumber = (cardNumber, cardType) => {
  if (!cardNumber) {
    return cardNumber;
  }

  const blocks = [];
  blocks[0] = cardNumber.substring(0, 4);
  if (blocks[0].length === 4 && cardNumber.length > blocks[0].length) {
    blocks[0] = `${blocks[0]} `;
  }
  if (cardType === 'amex' || cardType === 'diners') {
    blocks[1] = cardNumber.substring(4, 10);
    if (blocks[1].length === 6 && cardNumber.length > blocks[1].length + blocks[0].length - 1) {
      blocks[1] = `${blocks[1]} `;
    }
    blocks[2] = cardNumber.substring(10, 15);
  } else {
    blocks[1] = cardNumber.substring(4, 8);
    if (blocks[1].length === 4 && cardNumber.length > blocks[1].length + blocks[0].length - 1) {
      blocks[1] = `${blocks[1]} `;
    }
    blocks[2] = cardNumber.substring(8, 12);
    if (blocks[2].length === 4 && cardNumber.length > blocks[2].length + blocks[1].length + blocks[0].length - 2) {
      blocks[2] = `${blocks[2]} `;
    }
    blocks[3] = cardNumber.substring(12, cardNumber.length > 16 ? cardNumber.length : 16);
  }

  const formattedCardNumber = blocks.join('');

  //replace 'x' present in masked card number with '*'

  return formattedCardNumber.replace(/x/g, '*');
};

/**
 * Validates the card number contains only numeric characters and matches length of the type of the card.
 * @param {String} cardNumber String the card number
 * @param {Object} cardTypeLength object the allowed length for the cardType
 * @param {boolean} includeLengthRange InRange used to determine whether the card number length has to be validated to fall in range of the
 * cardType length or should not be equal to the length
 * @returns {boolean} returns true if card number is valid else returns false
 */
export const isCardNumberNumericAndMatchesLength = (cardNumber, cardTypeLength, includeLengthRange = false) => {
  if (!cardNumber || (!cardTypeLength && !includeLengthRange)) {
    return false;
  }
  let regex = /^[0-9]{1,16}$/;
  if (cardTypeLength) {
    const cardLengthArray = cardTypeLength.split('|');
    let lengthPatternStr = '';
    cardLengthArray.forEach((length, index) => {
      if (index !== 0) {
        lengthPatternStr += '|';
      }
      const lengthPattern = includeLengthRange ? `{1,${length}}` : `{${length}}`;
      lengthPatternStr += `^[0-9]${lengthPattern}$`;
    });
    regex = new RegExp(lengthPatternStr);
  }

  return cardNumber.match(regex) ? true : false;
};

/**
 * Checks the card number against the LUHN algorithm
 * @param {String} cardNumber The card number
 * @returns {boolean} returns true if card number is valid else returns false
 */
const luhnMod10 = cardNumber => {
  if (!cardNumber) return false;
  let total = 0;
  const {length} = cardNumber;

  for (let index = 1; index <= length; index++) {
    let digit = parseInt(cardNumber[length - index], 10);

    if (index % 2 === 0) {
      digit *= 2;
      if (digit > 9) {
        // as digit max is 18
        // digit%10 + 1 == -9
        digit -= 9;
      }
    }
    total += digit;
  }

  return total % 10 === 0;
};

/**
 * Validates the card number
 * @param {String} cardNumber The card number
 * @param {Number} cardLength The maximum allowed length for the card number
 * @param {Object} errorMessages The error messages object containing messages to be displayed for invalid and required
 * @returns {String} The validation message
 */
export const validateCardNumber = (
  cardNumber,
  cardLength,
  {messageCardNumberRequired = '', messageCardNumberInvalid = ''}
) => {
  let validationMessage = '';
  if (!cardNumber) {
    validationMessage = messageCardNumberRequired;
  } else if (!cardLength || !isCardNumberNumericAndMatchesLength(cardNumber, cardLength) || !luhnMod10(cardNumber)) {
    validationMessage = messageCardNumberInvalid;
  }

  return validationMessage;
};

/**
 * Validates the card cvv number
 * @param {String} cvv The card cvv number
 * @param {Number} cardCVVLength The allowed length for card cvv
 * @param {Object} errorMessages The error messages object containing messages to be displayed for invalid and required
 * @returns {String} The validation message
 */
export const validateCVV = (cvv, cardCVVLength, {messageCardCVVRequired = '', messageCardCVVInvalid = ''}) => {
  let validationMessage = '';
  if (!cvv) {
    validationMessage = messageCardCVVRequired;
  } else {
    const requiredLength = cardCVVLength ? cardCVVLength : 3;
    const cvvPattern = new RegExp(`^[0-9]{${requiredLength}}$`);
    if (!cvv.match(cvvPattern)) {
      // Failed pattern match
      validationMessage = messageCardCVVInvalid;
    }
  }

  return validationMessage;
};

/**
 * Validates the expiry month
 * @param {String} expiryMonth The expiry month
 * @param {String} expiryYear The expiry year
 * @param {Object} errorMessages The error messages object containing messages to be displayed for invalid and required
 * @returns {String} The validation message
 */
export const validateExpiryMonth = (
  expiryMonth,
  expiryYear,
  {messageExpiryDateRequired = '', messageExpiryDateInvalid = ''}
) => {
  const currentDate = new Date();
  const currentYear = currentDate.getUTCFullYear().toString().substr(-2);
  let currentMonth = currentDate.getUTCMonth();
  let validationMessage = '';
  if (!expiryMonth) {
    validationMessage = messageExpiryDateRequired;
  } else if (
    !expiryMonth.match(/^(0[1-9]|1[012])$/) ||
    (expiryYear && parseInt(expiryYear, 10) === parseInt(currentYear, 10) && parseInt(expiryMonth, 10) < ++currentMonth)
  ) {
    validationMessage = messageExpiryDateInvalid;
  }

  return validationMessage;
};

/**
 * Validates the expiry year
 * @param {String} expiryYear The expiry year
 * @param {String} expiryMonth The expiry month
 * @param {Object} errorMessages The error messages object containing messages to be displayed for invalid and required
 * @returns {String} The validation message
 */
export const validateExpiryYear = (expiryYear, {messageExpiryDateRequired = '', messageExpiryDateInvalid = ''}) => {
  const currentYear = new Date().getUTCFullYear().toString().substr(-2);
  let validationMessage = '';
  if (!expiryYear) {
    validationMessage = messageExpiryDateRequired;
  } else if (!expiryYear.match(/^\d{2}$/) || parseInt(expiryYear, 10) < parseInt(currentYear, 10)) {
    validationMessage = messageExpiryDateInvalid;
  }

  return validationMessage;
};

/**
 * Validates required field
 * @param {String} fieldValue The field value
 * @param {String} requiredMessage The message to be displayed for required error
 * @returns {String} The validation message
 */
export const validateRequiredField = (fieldValue, requiredMessage) => {
  let validationMessage = '';
  if (!fieldValue) {
    validationMessage = requiredMessage;
  }

  return validationMessage;
};

/**
 * Function used during sorting of saved cards for comparison.
 * @param {Object} card1 Saved card1
 * @param {Object} card2 Saved card2
 */
export const compareCards = (card1, card2) => {
  if (card1.isDefault) {
    return -1;
  }
  if (card2.isDefault) {
    return 1;
  }

  if (parseInt(card1.expiryYear, 10) > parseInt(card2.expiryYear, 10)) {
    return -1;
  }
  if (parseInt(card1.expiryYear, 10) < parseInt(card2.expiryYear, 10)) {
    return 1;
  }
  //if both cards have the same expiry year
  if (parseInt(card1.expiryMonth, 10) > parseInt(card2.expiryMonth, 10)) {
    return -1;
  }

  return 1;
};

/**
 * Determines if a payment group is paid.
 * @param paymentGroup the payment group
 * @returns returns true if payment group is paid or false
 */
export const isPaymentGroupPaid = paymentGroup => {
  let isPaymentGroupPaid = false;
  if (
    paymentGroup &&
    (paymentGroup.paymentState === PAYMENT_STATE_AUTHORIZED ||
      paymentGroup.paymentState === PAYMENT_STATE_SETTLED ||
      paymentGroup.paymentState === PAYMENT_STATE_PAYMENT_DEFERRED ||
      paymentGroup.paymentState === PAYMENT_STATE_PAYMENT_REQUEST_ACCEPTED)
  ) {
    isPaymentGroupPaid = true;
  }

  return isPaymentGroupPaid;
};

/**
 * Returns amount remaining exclusive (not of type physicalGiftCard,
 * loyaltyPoints or storeCredit) payment group
 * @param {Object} order The order
 * @returns {Object} the amount remaining payment group if exists otherwise undefined
 */
export const getAmountRemainingPaymentGroup = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return undefined;
  }

  const {paymentGroups = {}} = order;
  // find an amount remaining payment group which is not of types gift card, loyaltyPoints and storeCredit.
  // if amount remaining payment group is of any of these types then other payments cannot be applied
  const amountRemainingPaymentGroup = Object.values(paymentGroups).find(paymentGroup => {
    return (
      paymentGroup.isAmountRemaining &&
      !isPaymentGroupPaid(paymentGroup) &&
      paymentGroup.paymentMethod !== PAYMENT_TYPE_GIFTCARD &&
      paymentGroup.paymentMethod !== PAYMENT_METHOD_CUSTOM_CURRENCY &&
      paymentGroup.paymentMethod !== PAYMENT_TYPE_STORECREDIT &&
      paymentGroup.amount !== 0
    );
  });

  return amountRemainingPaymentGroup;
};

/**
 * Determines, if the any of the payment group has state AUTHORIZE_FAILED.
 * @param {Object} paymentGroups The payment groups
 * @returns {boolean} true if any payment group is in AUTHORIZE_FAILED state.
 */
const isPaymentGroupAuthorizationFailed = paymentGroups => {
  const isPaymentGroupAuthorizationFailed = Object.values(paymentGroups).some(paymentGroup => {
    return paymentGroup.paymentState === PAYMENT_STATE_AUTHORIZE_FAILED;
  });

  return isPaymentGroupAuthorizationFailed;
};

/**
 * Determines, if the payment should be disabled based on the current order.
 * @param {Object} order The current order
 * @returns {boolean} true if payment should be disabled otherwise false.
 */
export const isPaymentDisabled = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return true;
  }
  const {paymentGroups = {}, numberOfItems = 0, priceInfo: {total = 0} = {}} = order;

  // Disable the  payment if there are no items on the cart
  // or the order total is zero
  // or there are payment groups but there is no amount remaining payment group
  const isPaymentDisabled =
    numberOfItems === 0 ||
    total === 0 ||
    (Object.keys(paymentGroups).length > 0 &&
      !getAmountRemainingPaymentGroup(order) &&
      !isPaymentGroupAuthorizationFailed(paymentGroups) &&
      order.state !== ORDER_STATE_PENDING_PAYMENT &&
      order.state !== ORDER_STATE_QUOTED);

  return isPaymentDisabled;
};

/**
 * Validates the masked card number falls within the  length of the type of the card.
 * @param {String} cardNumber String the card number
 * @param {Object} cardTypeLength object the allowed length for the cardType
 */
export const isMaskedCardNumberMatchesLength = (cardNumber, cardTypeLength) => {
  if (!cardNumber) {
    return false;
  }
  // default regex allow up-to 16 characters
  let regex = /^[0-9*]{1,16}$/;
  if (cardTypeLength) {
    const cardLengthArray = cardTypeLength.split('|');
    let lengthPatternStr = '';
    cardLengthArray.forEach((length, index) => {
      if (index !== 0) {
        lengthPatternStr += '|';
      }
      lengthPatternStr += `^[0-9*]{1,${length}}$`;
    });
    regex = new RegExp(lengthPatternStr);
  }

  return cardNumber.match(regex) ? true : false;
};

/**
 * Determines, if the order is a zero value order.
 * @param {Object} order The order
 * @returns {boolean} true if the order is a zero value order
 */
export const isZeroValueOrder = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return false;
  }

  const {numberOfItems = 0, priceInfo: {total} = {}} = order;
  if (numberOfItems > 0 && total === 0) {
    return true;
  }

  return false;
};

/**
 * Determine if the entered payment information is complete for the order
 * @param {Object} order The order
 * @returns {boolean} true if the payment details are complete for the order
 */
export const isPaymentDetailsComplete = order => {
  if (!isObject(order) || isEmptyObject(order)) {
    return false;
  }

  const {paymentGroups = {}} = order;
  // If the response has applied payment groups and none of them is default or it is a zero value order,
  // payment is complete
  const isDefaultPaymentGroupExist = Object.values(paymentGroups).some(
    paymentGroup => paymentGroup.default_initial === 'true'
  );
  if ((isZeroValueOrder(order) || Object.keys(paymentGroups).length > 0) && !isDefaultPaymentGroupExist) {
    return true;
  }

  return false;
};

/**
 * Determines whether given payment type is configured or not
 * @param {Object} state the application state
 * @param {String} type the payment type
 * @returns {boolean} true if given payment type is configured otherwise false
 */
export const isPaymentTypeEnabled = (state, type) => {
  if (!state) {
    return false;
  }
  const {paymentMethods = []} = getPaymentConfigurations(state);

  return paymentMethods.includes(type);
};

/**
 * Determine whether all items of the order have set for single store pickup and order
 * qualify to pay in store payment type
 * @param {Object} order the order
 * @returns {boolean} true if all items of the order have set for single store pickup otherwise false
 */
export const isInStorePaymentApplicable = order => {
  if (!order) return false;

  const {shippingGroups = {}} = order;

  if (isEmptyObject(shippingGroups)) return false;
  //In case of single shipping store, all items should have same shipping store location
  const {store = {}} = Object.values(shippingGroups)[0];

  return Object.values(shippingGroups).every(
    sGroup => sGroup.type === SHIPPING_GROUP_IN_STORE_PICKUP && sGroup.store.locationId === store.locationId
  );
};

/**
 * Returns non default payments (means payment groups) which are also not expired and not zero amount,
 * of specified payment types applied to the order.
 * If no payment types are specified then it returns all the payment
 * which are not default payment, not expired and not zero amount
 * @param {Object} order the order
 * @param {Array} paymentTypes the payment types
 * @returns returns an array of applied payment (payment groups)
 */
export const getPaymentGroupsByTypes = (order, types) => {
  if (!order) {
    return [];
  }
  const {paymentGroups = {}} = order;
  const validPaymentGroups = Array.isArray(types)
    ? Object.values(paymentGroups).filter(paymentGroup => {
        return (
          types.includes(paymentGroup.paymentMethod) &&
          !paymentGroup.paymentExpired &&
          paymentGroup.amount !== 0 &&
          !paymentGroup.default_initial
        );
      })
    : Object.values(paymentGroups).filter(paymentGroup => {
        return !paymentGroup.paymentExpired && paymentGroup.amount !== 0 && !paymentGroup.default_initial;
      });

  return validPaymentGroups;
};

/**
 * It is an async method which deletes all specified types of payments (which are in INITIAL state
 * and not the default payment) from order and returns response.
 * @param {Object} store the store object
 * @param {Array} paymentTypes the types of payments (payment groups) which need to be deleted,
 * it must be passed as an array to this method, if this param is not passed then this method
 * will deletes all payments (which are in INITIAL state and not the default payment)
 * @returns the response object
 */
export const deleteAppliedPaymentsByTypes = async (store, paymentTypes) => {
  console.assert(!paymentTypes || Array.isArray(paymentTypes), 'Invalid payment types method argument');

  let actionResponse = {ok: true};
  const {paymentGroups = {}} = getCurrentOrder(store.getState());
  const paymentsToBeDeleted = Array.isArray(paymentTypes)
    ? Object.values(paymentGroups).filter(
        pGroup =>
          (paymentTypes.includes(pGroup.type) || paymentTypes.includes(pGroup.paymentMethod)) &&
          !pGroup.default_initial &&
          pGroup.paymentState === PAYMENT_STATE_INITIAL
      )
    : Object.values(paymentGroups).filter(
        pGroup => !pGroup.default_initial && pGroup.paymentState === PAYMENT_STATE_INITIAL
      );

  for (const payment of paymentsToBeDeleted) {
    const response = await store.action('deleteAppliedPayment', {paymentGroupId: payment.paymentGroupId});
    if (!response.ok) {
      actionResponse = response;
      break;
    }
  }

  return actionResponse;
};

/**
 * It is an async method which deletes applied payments (payment groups) from the order whose payment group ids (as an array)
 * are passed as method param, and returns response object
 * @param {Object} action the store action
 * @param {Array} paymentGroupIds the payment group ids of payments (payment groups) which need to be deleted
 * @returns the response object
 */
export const deleteAppliedPaymentsByIds = async (action, paymentGroupIds) => {
  console.assert(
    Array.isArray(paymentGroupIds) && paymentGroupIds.length > 0,
    'Please provide a non-empty array of payment group ids as method argument'
  );

  let actionResponse = {ok: true};
  for (const id of paymentGroupIds) {
    const response = await action('deleteAppliedPayment', {paymentGroupId: id});
    if (!response.ok) {
      actionResponse = response;
      break;
    }
  }

  return actionResponse;
};

/**
 * Returns the payment group which need ui intervention for authorization from bank
 * This payment group should be in initial state and it's uiIntervention prop should be set either payerAuthRequired or sop
 * @param paymentGroups the payment groups
 * @returns the payer auth payment group if exists otherwise undefined
 */
export const getPayerAuthPaymentGroup = paymentGroups => {
  const payerPaymentGroup = Object.values(paymentGroups || {}).find(
    pGroup =>
      pGroup.paymentState === PAYMENT_STATE_INITIAL &&
      (pGroup.uiIntervention === PAYER_AUTH_REQUIRED || pGroup.uiIntervention === CYBERSOURCE_SOP)
  );

  return payerPaymentGroup;
};

/**
 * Get payment setting from payment configuration for given payment type.
 * @param {Object} state the application state
 * @param {String} type the payment type
 * @returns {Object} payment setting object for give payment type.
 */
export const isPaymentEnabledForApproval = (state, type) => {
  const {settings = []} = getPaymentConfigurations(state);

  const paymentMethod = settings.find(setting => {
    return setting.paymentMethods === type;
  });
  if (paymentMethod && paymentMethod.enabledForApproval) {
    return true;
  }

  return false;
};

/**
 * Check if pay after approval is selected by user.
 * @param {Object} state the application state
 * @returns {boolean} true if pay after approval selected otherwise false
 */
export const isPayLaterSelected = state => {
  const {componentData} = getSessionContext(state);
  const orderId = getCurrentOrderId(state);
  if (componentData && componentData.orders && componentData.orders[orderId]) {
    return componentData.orders[orderId].isPayAfterApprovalSelected;
  }

  return false;
};

/**
 * Check if order requires approval.
 * @param {Object} state the application state
 * @returns {boolean} true if order requires approval otherwise false.
 */
export const isApprovalRequired = state => {
  const {componentData} = getSessionContext(state);
  const orderId = getCurrentOrderId(state);
  if (componentData && componentData.orders && componentData.orders[orderId]) {
    return componentData.orders[orderId].isApprovalRequired;
  }

  return false;
};

/**
 * Determine if the passed in country is a valid billing country
 * @param {String} country The country to be validated
 * @param {Object} billingCountries The list of billing countries
 * @returns {boolean} true if the passed in country is a valid billing country.
 */
export const isCountryValidBillingCountry = (country, billingCountries) => {
  if (!billingCountries || isEmptyObject(billingCountries)) {
    return false;
  }

  const billingCountriesValues = Object.keys(billingCountries);

  return billingCountriesValues.includes(country) ? true : false;
};

/**
 * Calculate total authorized amount at order level.
 * @param {Object} order The current order
 * @returns {String} total authorized amount.
 */
export const getAuthorizedAmount = order => {
  let authorizedAmount = 0.0;

  if (!isEmptyObject(order)) {
    const {paymentGroups = {}} = order;
    Object.values(paymentGroups).forEach(paymentGroup => {
      if (isPaymentGroupPaid(paymentGroup)) {
        authorizedAmount = authorizedAmount + paymentGroup.amount;
      }
    });
  }

  return authorizedAmount;
};

/**
 * Calculate total amount remaining for order.
 * @param {Object} order The current order
 * @returns {String} amount remaining.
 */
export const getAmountRemaining = order => {
  let amountRemaining = 0.0;
  if (!isEmptyObject(order) && order.priceInfo) {
    amountRemaining = order.priceInfo.total - getAuthorizedAmount(order);
    amountRemaining = amountRemaining < 0.0 ? 0.0 : amountRemaining;
  }

  return amountRemaining;
};

/**
 * Notifies error messages for failed payment groups
 * @@function {action} action callback function
 * @param {array} failedPaymentGroups failed payment groups
 * @param {object} messages default messages
 */
export const notifyPaymentFailure = (action, failedPaymentGroups, messages) => {
  const messagesArray = [];
  failedPaymentGroups.every(pGroup => pGroup.message && messagesArray.push(pGroup.message));
  messagesArray.length === 0 && messagesArray.push(messages.alertOrderNotPlacedPaymentDeclined);
  messagesArray.every(message => action('notify', {level: 'error', message}));
};

/**
 * Returns the web checkout redirection URL for payerAuth payment group
 * @param {orderId} orderId The orderId
 * @param {payerAuthPaymentGroup} payerAuthPaymentGroup The payer authentication payment group
 * @returns {String} The web checkout redirection URL.
 */
export const getWebCheckoutURL = (orderId, payerAuthPaymentGroup) => {
  // Return web checkout response page URL
  // ideally we should return the 3rd party payment provider page url (inspecting the payerAuthPaymentGroup customPaymentProperties for redirect url)
  // and from the payment provider page on success of payment navigate to web checkout response to authorize the payment
  // Returning web checkout response page url,passing in dummy custom properties here directly for testing
  // To be overridden by the implementer
  let url = '';
  if (payerAuthPaymentGroup) {
    url = `${PAGE_WEB_CHECKOUT_RESPONSE_LINK}/${orderId}?paymentId=PAYID-LUFFHFA923465405H3234916&payerId=X9C9GB43WQ398&token=EC-1DS593928C162981G`;
  }

  return url;
};

/**
 * Handles paymentGroups in the order if any uiIntervention as payerAuthRequired
 * If credit card payment group, redirects to checkout payer authentication page
 * else if online payment group redirects to web-checkout-response page
 * @param  @function { goToPage }  goToPage callback function
 * @param {object} order Object containing order details
 */
export const handlePayerAuthPaymentGroup = (goToPage, order) => {
  const {state, id, paymentGroups = {}} = order;
  const payerAuthPaymentGroup = getPayerAuthPaymentGroup(paymentGroups);
  if (!payerAuthPaymentGroup) {
    return;
  }
  if (payerAuthPaymentGroup.paymentMethod === PAYMENT_METHOD_CREDIT_CARD) {
    //navigate to checkout payer authentication page
    //if order is current order then need not to pass order id otherwise pass order id in path param
    const url =
      state === ORDER_STATE_INCOMPLETE
        ? PAGE_CHECKOUT_PAYER_AUTHENTICATION_LINK
        : `${PAGE_CHECKOUT_PAYER_AUTHENTICATION_LINK}/${id}`;
    goToPage(url);
  } else if (payerAuthPaymentGroup && payerAuthPaymentGroup.paymentMethod === PAYMENT_METHOD_ONLINE_PAYMENT_GROUP) {
    // navigate to web checkout page
    const webCheckoutURL = getWebCheckoutURL(id, payerAuthPaymentGroup);
    if (webCheckoutURL) {
      goToPage(webCheckoutURL);
    }
  }
};

/**
 * Success handler for add payment.
 */
export const handleAddPaymentSuccess = (orderId, goToPage, response = {}, action, messages) => {
  const {delta: {orderRepository: {orders} = {}} = {}} = response;
  if (orders) {
    const order = orders[orderId] || {};
    const {state, paymentGroups = {}} = order;
    const failedPaymentGroups = Object.values(paymentGroups).filter(
      payment => payment.paymentState === PAYMENT_STATE_AUTHORIZE_FAILED
    );
    action('notifyClearAll');
    if (state === ORDER_STATE_SUBMITTED || (getAmountRemaining(order) <= 0 && failedPaymentGroups.length === 0)) {
      const url = `${PAGE_CHECKOUT_ORDER_CONFIRMATION_LINK}/${order.uuid}`;
      goToPage(url);
    } else {
      const payerAuthPaymentGroup = getPayerAuthPaymentGroup(paymentGroups);
      if (payerAuthPaymentGroup) {
        handlePayerAuthPaymentGroup(goToPage, order);
      } else if (failedPaymentGroups.length > 0) {
        notifyPaymentFailure(action, failedPaymentGroups, messages);
      }
    }
  }
};

/**
 * Failure handler for add payment.
 */
export const handleAddPaymentFailure = (action, goToPage, response = {}) => {
  action('notifyClearAll');
  const {error = {}} = response;
  const {message} = error;
  //Display Error Message
  action('notify', {level: 'error', message});
};
/**
 * Determine whether user corresponding to given profile id is eligible to complete payment for the order.
 * @param {object} order the order
 * @param {string} profileId the profile id
 */
export const isEligibleToCompletePayment = (order, profileId) => {
  //if either order or profile id is not passed then return false
  if (!order || !profileId) {
    return false;
  }
  //identify pending authorization payment group existence first for payU case

  let returnValue = false;
  const {paymentGroups = {}, priceInfo, state, orderProfileId} = order;
  const hasPendingAuthPaymentGroup = Object.values(paymentGroups).some(
    payment => payment.paymentState === PAYMENT_STATE_PENDING_AUTHORIZATION
  );

  // If order is pending payment and belongs to current user and does not
  //have pending authorization Payment Group then allow him to make payments
  if (
    state === ORDER_STATE_PENDING_PAYMENT &&
    orderProfileId === profileId &&
    !hasPendingAuthPaymentGroup &&
    priceInfo &&
    priceInfo.total > 0
  ) {
    returnValue = true;
  }

  return returnValue;
};

/**
 * Get payment setting from scheduled orders payment configuration for given payment type.
 * @param {Object} state the application state
 * @param {String} type the payment type
 * @returns {Object} payment setting object for give payment type.
 */
export const getPaymentEnabledForScheduledOrder = (state, type) => {
  const scheduleInfo = getCurrentOrderScheduleInfo(state);
  const schedulePaymentInfo = {
    isCurrentOrderScheduled: false,
    enabledForScheduledOrder: false,
    enabledForApproval: false
  };

  if (!isEmptyObject(scheduleInfo) && scheduleInfo.schedule) {
    schedulePaymentInfo.isCurrentOrderScheduled = true;
    const {settings = []} = getPaymentConfigurations(state);

    const paymentMethod = settings.find(setting => {
      return setting.paymentMethods === type;
    });
    if (paymentMethod && paymentMethod.enabledForScheduledOrder) {
      schedulePaymentInfo.enabledForScheduledOrder = paymentMethod.enabledForScheduledOrder;
      if (paymentMethod.enabledForApproval) schedulePaymentInfo.enabledForApproval = paymentMethod.enabledForApproval;
    }
  }

  return schedulePaymentInfo;
};

/**
 * Method to verify the enabled payments
 * @param {boolean} isApprovalRequired the flag for approval
 * @param {boolean} isApprovalEnabled the flag for organization level approval
 * @param {boolean} isPaymentMethodEnabledForApproval the flag for payment approval
 * @param {object} scheduledOrderPaymentInfo the schedule payment info
 * @returns {boolean} Tells whether payment type is enabled or not
 */
export const validatePaymentsEnabled = (
  isApprovalRequired = false,
  isApprovalEnabled = false,
  isPaymentMethodEnabledForApproval = false,
  scheduledOrderPaymentInfo = {}
) => {
  if (scheduledOrderPaymentInfo.isCurrentOrderScheduled) {
    if (!isApprovalRequired) return scheduledOrderPaymentInfo.enabledForScheduledOrder;

    return isApprovalEnabled && scheduledOrderPaymentInfo.enabledForApproval;
  }

  return (isApprovalEnabled && isPaymentMethodEnabledForApproval) || !isApprovalRequired;
};
