/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

/**
 * @jest-environment node
 */

const path = require('path');
const {mockConsole} = require('@oracle-cx-commerce/test/utils/console');
const {filePatternSearcher, listFiles} = require('@oracle-cx-commerce/tools-util/files');

describe.skip("'listFiles' tests", () => {
  // TODO: Run the test on a temporary directory with a predefined file hierarchy instead of the work-space's files.
  const workspaceFiles = ['config', 'package.json', 'packages', 'qa', 'README.md', 'scripts', 'yarn.lock'];
  const toolsDirectory = 'packages/tools';
  const toolsDirectoryPath = path.resolve(toolsDirectory);
  const toolsDirectoryFiles = [
    'cli',
    'cli-init',
    'cli-shared',
    'deployment-controller',
    'dev',
    'http-client',
    'i18n',
    'logger',
    'test'
  ];
  const ignoreFiles = [
    '.DS_Store',
    '.git',
    '.dockerignore',
    '.editorconfig',
    '.env',
    '.eslintignore',
    '.eslintrc.js',
    '.gitignore',
    '.npmrc',
    '.occ',
    '.prettierignore',
    '.prettierrc.js',
    '.stylelintignore',
    '.stylelintrc',
    '.yarncache',
    '.yarnrc',
    'babel.config.js',
    'CHANGELOG.md',
    'cliTests.Dockerfile',
    'commitlint.config.js',
    'config',
    'dev.yml',
    'docker-compose.yml',
    'dockerBuildRunAndWatch',
    'dockerBuildTestAndWatch',
    'Dockerfile',
    'dockerOMCSRun',
    'dockerProductionRun',
    'extensions',
    'info.log',
    'jest.config.api.js',
    'jest.config.js',
    'jest.config.perf.js',
    'jest.config.perf.lighthouse.js',
    'jest.config.perf.wpt.js',
    'node_modules',
    'omcs.yml',
    'OSF.postman_collection.json',
    'package.json',
    'packages',
    'perf.yml',
    'perfTests.Dockerfile',
    'proxy.yml',
    'qa',
    'README.md',
    'scripts',
    'test-results',
    'test.yml',
    'tsconfig.json',
    'yarn.lock'
  ].filter(ignoreFile => !workspaceFiles.includes(ignoreFile));

  test('No arguments', async () => {
    // Listing files on workspace root folder
    const files = await listFiles();
    expect(files).toEqual(expect.arrayContaining(workspaceFiles));
  });

  test("This directory ('.')", async () => {
    const files = await listFiles({directory: '.'});
    expect(files).toEqual(expect.arrayContaining(workspaceFiles));
  });

  test('A relative folder', async () => {
    const files = await listFiles({directory: toolsDirectory});
    expect(files).toEqual(expect.arrayContaining(toolsDirectoryFiles.map(file => path.join(toolsDirectory, file))));
  });

  test('An absolute folder', async () => {
    const files = await listFiles({directory: toolsDirectoryPath});
    expect(files).toEqual(expect.arrayContaining(toolsDirectoryFiles.map(file => path.join(toolsDirectoryPath, file))));
  });

  test('An invalid directory name', async () => {
    await mockConsole(['error'], async () => {
      const files = await listFiles({directory: 'invalid-name'});
      expect(files.length).toBe(0);
      expect(files.errors.length).toBe(1);
      expect(console.error).toHaveBeenCalled();
      expect(console.error.mock.calls[0][0]).toBe("Error: ENOENT: no such file or directory, scandir 'invalid-name'");
    });
  });

  test('An invalid directory name recursively', async () => {
    await mockConsole(['error'], async () => {
      const files = await listFiles({directory: 'invalid-name', recursive: true});
      expect(files.length).toBe(0);
      expect(files.errors.length).toBe(1);
      expect(console.error).toHaveBeenCalled();
      expect(console.error.mock.calls[0][0]).toBe("Error: ENOENT: no such file or directory, scandir 'invalid-name'");
    });
  });

  test('Current directory recursive', async () => {
    const files = await listFiles({recursive: true});
    expect(files).toEqual(expect.arrayContaining(workspaceFiles));
    expect(files).toEqual(expect.arrayContaining(ignoreFiles.slice(1)));
  });

  test('Current directory recursive but ignore files', async () => {
    const files = await listFiles({recursive: true, ignore: ignoreFiles});
    expect(files).toEqual(expect.arrayContaining(workspaceFiles));
  });
});

describe.skip("'filePatternSearcher' tests", () => {
  test('No arguments', async () => {
    await expect(filePatternSearcher()).rejects.toThrow(
      "Type of first argument ('undefined') is not 'string' or 'RegExp'"
    );
  });

  test('Invalid pattern', async () => {
    await expect(filePatternSearcher({})).rejects.toThrow(
      "Type of first argument ('object') is not 'string' or 'RegExp'"
    );

    await expect(filePatternSearcher([])).rejects.toThrow(
      "Type of first argument ('object') is not 'string' or 'RegExp'"
    );

    await expect(filePatternSearcher('')).rejects.toThrow("Type of second argument ('undefined') is not 'string'");
  });

  test('Invalid file', async () => {
    await expect(filePatternSearcher('')).rejects.toThrow("Type of second argument ('undefined') is not 'string'");

    await expect(filePatternSearcher('', {})).rejects.toThrow("Type of second argument ('object') is not 'string'");

    await mockConsole(['error'], async () => {
      const matches = await filePatternSearcher('abc', '.');
      expect(matches.length).toBe(0);
      expect(console.error).toHaveBeenCalled();
      expect(console.error.mock.calls[0][0]).toMatch('EISDIR: illegal operation on a directory, read');
    });

    await mockConsole(['error'], async () => {
      const matches = await filePatternSearcher('abc', 'nonsense.txt');
      expect(matches.length).toBe(0);
      expect(console.error).toHaveBeenCalled();
      expect(console.error.mock.calls[0][0]).toMatch(
        new RegExp("ENOENT: no such file or directory, open '[^']+nonsense.txt'")
      );
    });
  });
});
