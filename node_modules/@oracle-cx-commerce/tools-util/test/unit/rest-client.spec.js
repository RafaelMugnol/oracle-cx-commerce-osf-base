/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */

const {mockFetchResponse, clearMockResponses, Response, responseOptions: mock} = require('node-fetch');
const {mockConsole} = require('@oracle-cx-commerce/test/utils/console');

function flushPromises() {
  return new Promise(resolve => setImmediate(resolve));
}

afterEach(() => {
  clearMockResponses();
});

describe('Authentication-related tests.', () => {
  test('Constructor fails when passing invalid option', async () => {
    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';

    expect(() => new Client(baseURL, appKey, {retries: -1})).toThrowError(/Invalid value 'options.retries/);
    expect(() => new Client(baseURL, appKey, {retries: 'car'})).toThrowError(/Invalid value 'options.retries/);
  });

  test("Constructor's default options", async () => {
    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';

    expect(new Client(baseURL, appKey)).toHaveProperty('retries', 3);
    expect(new Client(baseURL, appKey, {retries: 2})).toHaveProperty('retries', 2);
  });

  test("A console message notifies a successful 'login'", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 0});

    await mockConsole(['debug'], async () => {
      try {
        await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }

      expect(console.debug.mock.calls[0][0]).toMatch('Got an Admin authorization token');
    });
  });

  test("Successful 'login' when using an application key and gets an access token", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 0});

    let response;
    await mockConsole(['debug'], async () => {
      try {
        response = await client.login();
        // response = await client.logout();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }
    });

    expect(response).toBeDefined();
    expect(response.ok).toBe(true);
    expect(response.status).toBe(200);
    expect(client.accessToken).toBe('valid.access.token.from.login.0');
  });

  test("'login's response and client's first `accessToken` are the same", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 0});

    let response;
    await mockConsole(['debug'], async () => {
      try {
        response = await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }
    });

    expect(response).toBeDefined();
    expect(response.ok).toBe(true);
    expect(response.status).toBe(200);
    const loginPayload = await response.json();
    const loginAccessToken = loginPayload['access_token'];
    expect(loginAccessToken).toBe('valid.access.token.from.login.0');
    expect(client.accessToken).toBe('valid.access.token.from.login.0');
  });

  test("A console message indicates 'login' failed because of an invalid application key", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"errorCode":"60004","message":"Invalid OAuth token format.","status":"400"}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[400].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'an-invalid-key';
    const client = new Client(baseURL, appKey, {retries: 0});

    await mockConsole(['error', 'debug'], async () => {
      try {
        await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }

      expect(console.debug.mock.calls[0][0]).toMatch('Response: 400 Bad Request');
      expect(console.error.mock.calls[0][0]).toMatch('Error logging in the Admin server');
      expect(console.debug.mock.calls[1][0]).toMatch(
        '{"errorCode":"60004","message":"Invalid OAuth token format.","status":"400"}'
      );
    });
  });

  test("'login's response indicates an error occurred when using an invalid application key", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"errorCode":"60004","message":"Invalid OAuth token format.","status":"400"}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[400].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'an-invalid-key"([{%&^@#!~_+-;:?';
    const client = new Client(baseURL, appKey, {retries: 0});

    let response;
    await mockConsole(['error', 'debug'], async () => {
      try {
        response = await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }
    });

    expect(response).toBeDefined();
    expect(response.ok).toBe(false);
    expect(response.status).toBe(400);
    expect(client.accessToken).toBeFalsy();
  });

  test("Console indicates 'login' error when application key is missing", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"error":"invalid_request"}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[401].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = '';
    const client = new Client(baseURL, appKey, {retries: 0});

    await mockConsole(['error', 'debug'], async () => {
      try {
        await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }

      expect(console.debug.mock.calls[0][0]).toMatch('Response: 401 Unauthorized');
      expect(console.error.mock.calls[0][0]).toMatch('Error logging in the Admin server');
      expect(console.debug.mock.calls[1][0]).toMatch('{"error":"invalid_request"}');
    });
  });

  test("Gets 'Unauthorized' response when application key is missing", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"error":"invalid_request"}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[401].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = '';
    const client = new Client(baseURL, appKey, {retries: 0});

    let response;
    await mockConsole(['error', 'debug'], async () => {
      try {
        response = await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }
    });

    expect(response).toBeDefined();
    expect(response.ok).toBe(false);
    expect(response.status).toBe(401);
    // Body should be in unused state
    await expect(response.json()).toBeDefined();
    expect(client.accessToken).toBeFalsy();
  });

  test("Console message indicates first 'login' failed and then a success after retrying", async () => {
    // First, simulate an network error.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      async () => {
        const {FetchError} = jest.requireActual('node-fetch');
        const systemError = new Error('A fictitious system error, do not panic!');
        systemError.code = 'ECONNREFUSED';
        systemError.syscall = 'connect';
        const error = new FetchError(
          'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
          'system',
          systemError
        );
        throw error;
      },
      {method: 'POST', body: 'grant_type=client_credentials'}
    );
    // Then, send a successful response.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 1});

    await mockConsole(['error', 'debug'], async () => {
      try {
        await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }

      expect(console.error.mock.calls[0][0]).toMatch('fetch');
      expect(console.error.mock.calls[0][0]).toMatch('/ccadmin/v1/login');
      expect(console.error.mock.calls[1][0]).toMatch('Admin login failed');
      expect(console.debug.mock.calls[0][0]).toMatch('Retrying Admin login');
      expect(console.debug.mock.calls[1][0]).toMatch('Got an Admin authorization token');
    });
  });

  test("Successful 'login' after getting an error and retrying", async () => {
    // First, simulate an network error.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      async () => {
        const {FetchError} = jest.requireActual('node-fetch');
        const systemError = new Error('A fictitious system error, do not panic!');
        systemError.code = 'ECONNREFUSED';
        systemError.syscall = 'connect';
        const error = new FetchError(
          'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
          'system',
          systemError
        );
        throw error;
      },
      {method: 'POST', body: 'grant_type=client_credentials'}
    );
    // Then, send a successful response.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 1});

    let response;
    await mockConsole(['error', 'debug'], async () => {
      try {
        response = await client.login();
      } catch (reason) {
        expect(reason).toBeUndefined();
      }
    });

    expect(response).toBeDefined();
    expect(response.ok).toBe(true);
    expect(response.status).toBe(200);
    expect(client.accessToken).toBe('valid.access.token.from.login.0');
  });

  test("Console message indicates 'login' failed even after retrying", async () => {
    // First and second requests get an network error.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      async () => {
        const {FetchError} = jest.requireActual('node-fetch');
        const systemError = new Error('A fictitious system error, do not panic!');
        systemError.code = 'ECONNREFUSED';
        systemError.syscall = 'connect';
        const error = new FetchError(
          'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
          'system',
          systemError
        );
        throw error;
      },
      {method: 'POST', body: 'grant_type=client_credentials'}
    );
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      async () => {
        const {FetchError} = jest.requireActual('node-fetch');
        const systemError = new Error('A fictitious system error, do not panic!');
        systemError.code = 'ECONNREFUSED';
        systemError.syscall = 'connect';
        const error = new FetchError(
          'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
          'system',
          systemError
        );
        throw error;
      },
      {method: 'POST', body: 'grant_type=client_credentials'}
    );
    // A successful response that never gets returned because there are no more retries left.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 1});

    await mockConsole(['error', 'debug'], async () => {
      try {
        await client.login();
      } catch (reason) {
        expect(reason).toBeDefined();
      }

      expect(console.error.mock.calls[0][0]).toMatch('fetch');
      expect(console.error.mock.calls[0][0]).toMatch('/ccadmin/v1/login');

      expect(console.error.mock.calls[1][0]).toMatch('Admin login failed');

      expect(console.debug.mock.calls[0][0]).toMatch('Retrying Admin login');

      expect(console.error.mock.calls[2][0]).toMatch('fetch');
      expect(console.error.mock.calls[2][0]).toMatch('/ccadmin/v1/login');

      expect(console.error.mock.calls[3][0]).toMatch(/Admin login failed; reason: request to .+ failed/);
    });
  });

  test("Exhausts all 'login' retries before returning an error response", async () => {
    // First and second requests get an network error.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      async () => {
        const {FetchError} = jest.requireActual('node-fetch');
        const systemError = new Error('A fictitious system error, do not panic!');
        systemError.code = 'ECONNREFUSED';
        systemError.syscall = 'connect';
        const error = new FetchError(
          'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
          'system',
          systemError
        );
        throw error;
      },
      {method: 'POST', body: 'grant_type=client_credentials'}
    );
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      async () => {
        const {FetchError} = jest.requireActual('node-fetch');
        const systemError = new Error('A fictitious system error, do not panic!');
        systemError.code = 'ECONNREFUSED';
        systemError.syscall = 'connect';
        const error = new FetchError(
          'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
          'system',
          systemError
        );
        throw error;
      },
      {method: 'POST', body: 'grant_type=client_credentials'}
    );
    // A successful response that never gets returned because there are no more retries left.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 1});

    let response;
    await mockConsole(['error', 'debug'], async () => {
      try {
        response = await client.login();
      } catch (reason) {
        expect(reason).toBeDefined();
        expect(reason.message).toMatch(/request to .+ failed/);
      }
    });

    expect(response).toBeUndefined();
    expect(client.accessToken).toBeFalsy();
  });

  test("Simulate 'login' gets a 'not resolvable' error response because of a misconfigured proxy", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n<html>\n<!-- FileName: index.html\n     Language: [en]\n-->\n<!--Head-->\n<head>\n  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">\n  <meta http-equiv="X-UA-Compatible" content="IE=7" />\n  <title>McAfee Web Gateway - Notification</title>\n  <script src="/mwg-internal/de5fs23hu73ds/files/javascript/sw.js" type="text/javascript" ></script>\n  <link rel="stylesheet" href="/mwg-internal/de5fs23hu73ds/files/default/stylesheet.css" />\n</head>\n<!--/Head-->\n<!--Body-->\n<body onload="swOnLoad();">\n  <table class='bodyTable'>\n    <tr>\n      <td class='bodyData' background='/mwg-internal/de5fs23hu73ds/files/default/img/bg_body.gif'>\n<!--Logo-->\n<table class='logoTable'>\n  <tr>\n    <td class='logoData'>\n      <a href='http://www.mcafee.com'>\n        <img src='/mwg-internal/de5fs23hu73ds/files/default/img/oralogo-small.gif'></a>\n    </td>\n  </tr>\n</table>\n<!--/Logo-->\n<!--Contents-->\n<!-- FileName: notresolvable.html\n     Language: [en]\n-->\n<!--Title-->\n<table class='titleTable' background='/mwg-internal/de5fs23hu73ds/files/default/img/bg_navbar.jpg'>\n  <tr>\n    <td class='titleData'>\n      Host Not Resolvable\n    </td>\n  </tr>\n</table>\n<!--/Title-->\n\n<!--Content-->\n<table class="contentTable">\n  <tr>\n    <td class="contentData">\n      The Host is not resolvable. Most commonly this is due to mistyping the URL in the browser bar. Please verify the spelling and that the site exists and hit refresh.\n    </td>\n  </tr>\n</table>\n<!--/Content-->\n\n<!--Info-->\n<table class="infoTable">\n  <tr>\n    <td class="infoData">\n      <b>URL: </b><script type="text/javascript">break_line("http://phoenix40180.ad1.fusionappsdphx1.oraclevcn.com:9080/ccadmin/v1/login");</script><br />\n    </td>\n  </tr>\n</table>\n<!--/Info-->\n\n<!--/Contents-->\n<!--Policy-->\n<table class='policyTable'>\n  <tr>\n    <td class='policyHeading'>\n      <hr>\n\n    </td>\n  </tr>\n  <tr>\n    <td class='policyData'>\nIf you believe you have received this page in error, please submit an <a href="https://myhelp.oracle.com/app/answers/answer_view_GA/a_id/94/loc/en_US/g_id/141">Oracle MyHelp \nTicket</a>. If this is an urgent, service impacting issue, please contact the Global Service Desk via telephone: Dial **600\nOr Local in-country numbers can be found at <a href="http://my.oracle.com/site/git/1591/2666/index.html">Global Service Desk - Contact Numbers\n\n</p>\n    </td>\n  </tr>\n</table>\n<!--/Policy-->\n<!--Foot-->\n<table class='footTable'>\n<hr>\n  <tr>\n    <td class='footData'>\n      generated <span id="time">2021-02-18 16:10:40</span> by ash7-proxy-mwg11.us.oracle.com\n    </td>\n  </tr>\n</table>\n<!--/Foot-->\n      </td>\n    </tr>\n  </table>\n</body>\n<!--/Body-->\n<!-- BLOCKBLOCK_ORACLEPROXY_BLOCKBLOCK -->\n</html>\n`,
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[502].html
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 0});

    await mockConsole(['error', 'debug'], async () => {
      try {
        await client.login();
      } catch (reason) {
        expect(reason).toBeDefined();
        expect(reason.code).toBe(502);
        expect(reason.message).toMatch('notresolvable');
      }

      expect(console.debug.mock.calls[0][0]).toMatch('Response: 502 notresolvable');

      expect(console.error.mock.calls[0][0]).toMatch('Error logging in the Admin server');
      expect(console.error.mock.calls[0][0]).toMatch('Host Not Resolvable');
    });
  });

  test("Retry to 'login' after getting a 'not resolvable' error response when using a proxy", async () => {
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n<html>\n<!-- FileName: index.html\n     Language: [en]\n-->\n<!--Head-->\n<head>\n  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">\n  <meta http-equiv="X-UA-Compatible" content="IE=7" />\n  <title>McAfee Web Gateway - Notification</title>\n  <script src="/mwg-internal/de5fs23hu73ds/files/javascript/sw.js" type="text/javascript" ></script>\n  <link rel="stylesheet" href="/mwg-internal/de5fs23hu73ds/files/default/stylesheet.css" />\n</head>\n<!--/Head-->\n<!--Body-->\n<body onload="swOnLoad();">\n  <table class='bodyTable'>\n    <tr>\n      <td class='bodyData' background='/mwg-internal/de5fs23hu73ds/files/default/img/bg_body.gif'>\n<!--Logo-->\n<table class='logoTable'>\n  <tr>\n    <td class='logoData'>\n      <a href='http://www.mcafee.com'>\n        <img src='/mwg-internal/de5fs23hu73ds/files/default/img/oralogo-small.gif'></a>\n    </td>\n  </tr>\n</table>\n<!--/Logo-->\n<!--Contents-->\n<!-- FileName: notresolvable.html\n     Language: [en]\n-->\n<!--Title-->\n<table class='titleTable' background='/mwg-internal/de5fs23hu73ds/files/default/img/bg_navbar.jpg'>\n  <tr>\n    <td class='titleData'>\n      Host Not Resolvable\n    </td>\n  </tr>\n</table>\n<!--/Title-->\n\n<!--Content-->\n<table class="contentTable">\n  <tr>\n    <td class="contentData">\n      The Host is not resolvable. Most commonly this is due to mistyping the URL in the browser bar. Please verify the spelling and that the site exists and hit refresh.\n    </td>\n  </tr>\n</table>\n<!--/Content-->\n\n<!--Info-->\n<table class="infoTable">\n  <tr>\n    <td class="infoData">\n      <b>URL: </b><script type="text/javascript">break_line("http://phoenix40180.ad1.fusionappsdphx1.oraclevcn.com:9080/ccadmin/v1/login");</script><br />\n    </td>\n  </tr>\n</table>\n<!--/Info-->\n\n<!--/Contents-->\n<!--Policy-->\n<table class='policyTable'>\n  <tr>\n    <td class='policyHeading'>\n      <hr>\n\n    </td>\n  </tr>\n  <tr>\n    <td class='policyData'>\nIf you believe you have received this page in error, please submit an <a href="https://myhelp.oracle.com/app/answers/answer_view_GA/a_id/94/loc/en_US/g_id/141">Oracle MyHelp \nTicket</a>. If this is an urgent, service impacting issue, please contact the Global Service Desk via telephone: Dial **600\nOr Local in-country numbers can be found at <a href="http://my.oracle.com/site/git/1591/2666/index.html">Global Service Desk - Contact Numbers\n\n</p>\n    </td>\n  </tr>\n</table>\n<!--/Policy-->\n<!--Foot-->\n<table class='footTable'>\n<hr>\n  <tr>\n    <td class='footData'>\n      generated <span id="time">2021-02-18 16:10:40</span> by ash7-proxy-mwg11.us.oracle.com\n    </td>\n  </tr>\n</table>\n<!--/Foot-->\n      </td>\n    </tr>\n  </table>\n</body>\n<!--/Body-->\n<!-- BLOCKBLOCK_ORACLEPROXY_BLOCKBLOCK -->\n</html>\n`,
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[502].html
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );
    // A successful response that never gets returned because there are no more retries left.
    mockFetchResponse(
      'http://localhost:9080/ccadmin/v1/login',
      new Response(
        '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
        mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
      ),
      {method: 'POST', body: 'grant_type=client_credentials'}
    );

    const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
    const baseURL = 'http://localhost:9080';
    const appKey = 'a-valid-key';
    const client = new Client(baseURL, appKey, {retries: 1});

    await mockConsole(['error', 'debug'], async () => {
      try {
        await client.login();
      } catch (reason) {
        expect(reason).toBeDefined();
        expect(reason.code).toBe(502);
        expect(reason.message).toMatch('notresolvable');
      }

      expect(console.debug.mock.calls[0][0]).toMatch('Response: 502 notresolvable');

      expect(console.error.mock.calls[0][0]).toMatch('Error logging in the Admin server');
      expect(console.error.mock.calls[0][0]).toMatch('Host Not Resolvable');

      expect(console.debug.mock.calls[2][0]).toMatch('Retrying login');

      expect(console.debug.mock.calls[3][0]).toMatch('Got an Admin authorization token');
      expect(console.debug.mock.calls[3][0]).toMatch('valid.acce...om.login.0');
    });
  });

  describe('Keeping the session active', () => {
    beforeEach(() => {
      jest.useFakeTimers();
    });

    afterEach(() => {
      jest.clearAllTimers();
    });

    afterAll(() => {
      jest.useRealTimers();
    });

    test("Console shows 'login' is followed by a 'refresh'", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"access_token":"valid.access.token.from.refresh.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[200].json
        ),
        {method: 'POST', body: '{}'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      await mockConsole(['debug'], async () => {
        try {
          await client.login(true);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(console.debug.mock.calls[0][0]).toMatch('Got an Admin authorization token');
        expect(console.debug.mock.calls[0][0]).toMatch('valid.acce...om.login.0');

        expect(console.debug.mock.calls[1][0]).toMatch('Starting a session in Admin.');

        expect(console.debug.mock.calls[2][0]).toMatch('Refreshed Admin authorization token');
        expect(console.debug.mock.calls[2][0]).toMatch('valid.acce....refresh.0');
      });
    });

    test('Signs in and refreshes authorization token once', async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"access_token":"valid.access.token.from.refresh.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[200].json
        ),
        {method: 'POST', body: '{}'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug'], async () => {
        try {
          response = await client.login(true);

          expect(response).toBeDefined();
          expect(response.ok).toBe(true);
          expect(response.status).toBe(200);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.refresh.0');
      });
    });

    test("Signs in and does not 'refresh' if 'login' argument is 'false'", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug'], async () => {
        try {
          response = await client.login();

          expect(response).toBeDefined();
          expect(response.ok).toBe(true);
          expect(response.status).toBe(200);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        // Fast-forward until all timers have been executed
        jest.runAllTimers();
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.login.0');

        expect(console.debug.mock.calls[0][0]).toMatch('Got an Admin authorization token');
        expect(console.debug.mock.calls[0][0]).toMatch('valid.acce...om.login.0');
      });
    });

    test("Console shows a second 'login' after 'refresh' uses expired token", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"errorCode":"60006000","message":"The user is not authenticated.","status":"401"}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[401].json
        ),
        {method: 'POST', body: '{}'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.1","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      await mockConsole(['error', 'debug', 'debug'], async () => {
        try {
          await client.login(true);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(console.debug.mock.calls[0][0]).toMatch('Got an Admin authorization token');
        expect(console.debug.mock.calls[0][0]).toMatch('valid.acce...om.login.0');

        expect(console.debug.mock.calls[1][0]).toMatch('Starting a session in Admin');

        expect(console.debug.mock.calls[2][0]).toMatch('Response: 401 Unauthorized');

        expect(console.error.mock.calls[0][0]).toMatch('Error refreshing the authorization token from Admin');

        expect(console.debug.mock.calls[3][0]).toMatch('{}');

        expect(console.debug.mock.calls[4][0]).toMatch('Retrying Admin login.');

        expect(console.debug.mock.calls[5][0]).toMatch('Got an Admin authorization token');
        expect(console.debug.mock.calls[5][0]).toMatch('valid.acce...om.login.1');
      });
    });

    test("Signs back in after 'refresh' uses expired token", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"errorCode":"60006000","message":"The user is not authenticated.","status":"401"}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[401].json
        ),
        {method: 'POST', body: '{}'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.1","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug', 'debug', 'error'], async () => {
        try {
          response = await client.login(true);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        expect(response).toBeDefined();
        expect(response.ok).toBe(true);
        expect(response.status).toBe(200);
        expect(client.accessToken).toBe('valid.access.token.from.login.0');

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.login.1');
      });
    });

    test("Signs back in after 'refresh' gets a server error response", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '500 Internal Server Error',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[500].plain
        ),
        {method: 'POST', body: '{}'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.1","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug', 'debug', 'error'], async () => {
        try {
          response = await client.login(true);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        expect(response).toBeDefined();
        expect(response.ok).toBe(true);
        expect(response.status).toBe(200);
        expect(client.accessToken).toBe('valid.access.token.from.login.0');

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.login.1');

        expect(console.debug.mock.calls[0][0]).toMatch('Got an Admin authorization token');

        expect(console.debug.mock.calls[1][0]).toMatch('Starting a session in Admin');

        expect(console.debug.mock.calls[2][0]).toMatch('Response: 500 Internal Server Error');

        expect(console.error.mock.calls[0][0]).toMatch('Error refreshing the authorization token from Admin');

        expect(console.debug.mock.calls[3][0]).toMatch('{}');

        expect(console.debug.mock.calls[4][0]).toMatch('Retrying Admin login.');

        expect(console.debug.mock.calls[5][0]).toMatch('Got an Admin authorization token');
        expect(console.debug.mock.calls[5][0]).toMatch('valid.acce...om.login.1');
      });
    });

    test("Keeps 'refresh'ing after re-'login' due to expired token", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"errorCode":"60006000","message":"The user is not authenticated.","status":"401"}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[401].json
        ),
        {method: 'POST', body: '{}'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.1","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"access_token":"valid.access.token.from.refresh.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[200].json
        ),
        {method: 'POST', body: '{}'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug', 'debug', 'error'], async () => {
        try {
          response = await client.login(true);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        expect(response).toBeDefined();
        expect(response.ok).toBe(true);
        expect(response.status).toBe(200);
        expect(client.accessToken).toBe('valid.access.token.from.login.0');

        // Alternative to `jest.runOnlyPendingTimers()`
        jest.advanceTimersByTime(30000);
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.login.1');

        // Alternative to `jest.runOnlyPendingTimers()`
        jest.advanceTimersByTime(30000);
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.refresh.0');

        expect(console.debug.mock.calls[0][0]).toMatch('Got an Admin authorization token');

        expect(console.debug.mock.calls[1][0]).toMatch('Starting a session in Admin');

        expect(console.debug.mock.calls[2][0]).toMatch('Response: 401 Unauthorized');

        expect(console.error.mock.calls[0][0]).toMatch('Error refreshing the authorization token from Admin');

        expect(console.debug.mock.calls[3][0]).toMatch('{}');

        expect(console.debug.mock.calls[4][0]).toMatch('Retrying Admin login.');

        expect(console.debug.mock.calls[5][0]).toMatch('Got an Admin authorization token');
        expect(console.debug.mock.calls[5][0]).toMatch('valid.acce...om.login.1');

        expect(console.debug.mock.calls[6][0]).toMatch('Refreshed Admin authorization token,');
        expect(console.debug.mock.calls[6][0]).toMatch('valid.acce....refresh.0');
      });
    });

    test("Keeps 'refresh'ing after re-'login' due to 'connection refused'", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        async () => {
          const {FetchError} = jest.requireActual('node-fetch');
          const systemError = new Error('A fictitious system error, do not panic!');
          systemError.code = 'ECONNREFUSED';
          systemError.syscall = 'connect';
          const error = new FetchError(
            'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
            'system',
            systemError
          );
          throw error;
        },
        {method: 'POST', body: '{}'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.1","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"access_token":"valid.access.token.from.refresh.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[200].json
        ),
        {method: 'POST', body: '{}'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug', 'debug', 'error'], async () => {
        try {
          response = await client.login(true);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        expect(response).toBeDefined();
        expect(response.ok).toBe(true);
        expect(response.status).toBe(200);
        expect(client.accessToken).toBe('valid.access.token.from.login.0');

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.login.1');

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(client.accessToken).toBe('valid.access.token.from.refresh.0');
      });
    });

    test("Exhausts all 'login' retries after failed 'refresh'", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        async () => {
          const {FetchError} = jest.requireActual('node-fetch');
          const systemError = new Error('A fictitious system error, do not panic!');
          systemError.code = 'ECONNREFUSED';
          systemError.syscall = 'connect';
          const error = new FetchError(
            'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
            'system',
            systemError
          );
          throw error;
        },
        {method: 'POST', body: '{}'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        async () => {
          const {FetchError} = jest.requireActual('node-fetch');
          const systemError = new Error('A fictitious system error, do not panic!');
          systemError.code = 'ECONNREFUSED';
          systemError.syscall = 'connect';
          const error = new FetchError(
            'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
            'system',
            systemError
          );
          throw error;
        },
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        async () => {
          const {FetchError} = jest.requireActual('node-fetch');
          const systemError = new Error('A fictitious system error, do not panic!');
          systemError.code = 'ECONNREFUSED';
          systemError.syscall = 'connect';
          const error = new FetchError(
            'request to http://localhost:9080/ failed, reason: connect ECONNREFUSED 127.0.0.1:9080',
            'system',
            systemError
          );
          throw error;
        },
        {method: 'POST', body: 'grant_type=client_credentials'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 1});

      let response;
      await mockConsole(['debug', 'debug', 'error'], async () => {
        try {
          response = await client.login(true);
        } catch (reason) {
          expect(reason).toBeUndefined();
        }

        expect(response).toBeDefined();
        expect(response.ok).toBe(true);
        expect(response.status).toBe(200);
        expect(client.accessToken).toBe('valid.access.token.from.login.0');

        // Fast forward and exhaust only currently pending timers
        // (but not any new timers that get created during that process)
        jest.runOnlyPendingTimers();
        await flushPromises();

        expect(console.debug.mock.calls[0][0]).toMatch('Got an Admin authorization token');

        expect(console.error.mock.calls[0][0]).toMatch('fetch');
        expect(console.error.mock.calls[0][0]).toMatch('/ccadmin/v1/refresh');

        expect(console.error.mock.calls[1][0]).toMatch('Error refreshing the authorization token from Admin');

        expect(console.error.mock.calls[2][0].message).toMatch(/request to .+ failed, reason: connect ECONNREFUSED/);

        expect(console.debug.mock.calls[1][0]).toMatch('Starting a session in Admin');

        expect(console.debug.mock.calls[2][0]).toMatch('Retrying Admin login');

        expect(console.error.mock.calls[3][0]).toMatch('fetch');
        expect(console.error.mock.calls[3][0]).toMatch('/ccadmin/v1/login');

        expect(console.error.mock.calls[4][0]).toMatch(
          /Admin login failed; reason: request to .+ failed, reason: connect ECONNREFUSED/
        );

        expect(console.debug.mock.calls[3][0]).toMatch('Retrying Admin login');

        expect(console.error.mock.calls[5][0]).toMatch('fetch');
        expect(console.error.mock.calls[5][0]).toMatch('/ccadmin/v1/login');

        expect(console.error.mock.calls[6][0]).toMatch(
          /Admin login failed; reason: request to .+ failed, reason: connect ECONNREFUSED/
        );

        expect(console.error.mock.calls[7][0]).toMatch('Could not login back to Admin');

        expect(console.error.mock.calls[8][0].message).toMatch(/request to .+ failed, reason: connect ECONNREFUSED/);

        expect(console.debug.mock.calls[4][0]).toMatch('Will retry in the next 30 seconds');
      });
    });
  });

  describe('Responses are pristine (unused body)', () => {
    test("'login'", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug'], async () => {
        try {
          response = await client.login();
        } catch (reason) {
          expect(reason).toBeUndefined();
        }
      });

      expect(response).toBeDefined();
      expect(response.ok).toBe(true);
      expect(response.status).toBe(200);
      await expect(async () => {
        const payload = await response.json();
        expect(payload).toHaveProperty('access_token');
        expect(payload).toHaveProperty('token_type');
        expect(payload).toHaveProperty('expires_in');
      }).not.toThrow();
      expect(client.accessToken).toBe('valid.access.token.from.login.0');
      await expect(async () => {
        await response.json();
      }).rejects.toThrowError(/body used already/);
    });

    test("'refresh'", async () => {
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/login',
        new Response(
          '{"access_token":"valid.access.token.from.login.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/login').responses[200].json
        ),
        {method: 'POST', body: 'grant_type=client_credentials'}
      );
      mockFetchResponse(
        'http://localhost:9080/ccadmin/v1/refresh',
        new Response(
          '{"access_token":"valid.access.token.from.refresh.0","token_type":"bearer","expires_in":300}',
          mock.origin('http://localhost:9080').path('/ccadmin/v1/refresh').responses[200].json
        ),
        {method: 'POST', body: '{}'}
      );

      const {Client} = require('@oracle-cx-commerce/tools-util/rest-client');
      const baseURL = 'http://localhost:9080';
      const appKey = 'a-valid-key';
      const client = new Client(baseURL, appKey, {retries: 0});

      let response;
      await mockConsole(['debug'], async () => {
        try {
          await client.login();
          response = await client.refreshAuthorizationToken();
        } catch (reason) {
          expect(reason).toBeUndefined();
        }
      });

      expect(response).toBeDefined();
      expect(response.ok).toBe(true);
      expect(response.status).toBe(200);
      await expect(async () => {
        const payload = await response.json();
        expect(payload).toHaveProperty('access_token');
        expect(payload).toHaveProperty('token_type');
        expect(payload).toHaveProperty('expires_in');
      }).not.toThrow();
      expect(client.accessToken).toBe('valid.access.token.from.refresh.0');
      await expect(async () => {
        await response.json();
      }).rejects.toThrowError(/body used already/);
    });
  });
});
