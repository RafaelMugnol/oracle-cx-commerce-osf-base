/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const fsp = require('fs').promises;
const path = require('path');
const {PopStackError} = require('@oracle-cx-commerce/tools-util/errors');

/**
 * Splits the content of a directory into a list of files and a list of directories.
 *
 * The directory content is represented as a list of `fs.Dirent` elements,
 * possibly obtained using the `readdir` method from the Node's File System module.
 *
 * @param      {[fs.Dirent]}  list    The content of a directory.
 * @return     {[[string], [string]]} A list of two elements. First element has the files, and the second has the directories.
 */
function splitFilesAndDirectories(list) {
  return [
    list.filter(item => !item.isDirectory()).map(file => file.name),
    list.filter(item => item.isDirectory()).map(file => file.name)
  ];
}

/**
 * List files on the specified directory.
 *
 * @param      {object}   [options={}]  The listing options.
 * @param      {string}   [options.directory='.']    The directory from which list the files
 * @param      {Boolean}  [options.recursive=false]  List files on sub-directories too, in a depth-first way.
 * @param      {[string]} [options.ignore=[]]        Exclude files and directories which name matches an element on this list.
 * @return     {Promise}  List of files.
 */
async function listFiles(options = {}) {
  const baseDirectory = options.directory || '.';
  const recursive = options.recursive || false;
  const ignore = new Set(options.ignore);
  const result = [];
  const directories = [baseDirectory];

  do {
    const directory = directories.pop();

    let content;
    try {
      content = await fsp.readdir(directory, {withFileTypes: true});
    } catch (reason) {
      if (!result.errors) {
        result.errors = [];
      }
      console.error(`Error: ${reason.message}`);
      result.errors.push(reason);
      continue;
    }

    const filteredContent = content.filter(item => !ignore.has(item.name));
    const [fileNames, subdirectoryNames] = splitFilesAndDirectories(filteredContent);
    // Define relative file and sub-directory names.
    const files = fileNames.map(item => path.join(directory, item));
    const subdirectories = subdirectoryNames.map(item => path.join(directory, item)).reverse();

    if (recursive) {
      result.push(directory);
      directories.push(...subdirectories);
    } else {
      result.push(...subdirectories);
    }
    result.push(...files);
  } while (directories.length);

  return result;
}

/**
 * grep-like tool.
 *
 * Returns the lines that match the specified pattern.
 *
 * Usage examples; get from a file the lines that resemble a credit card number:
 *     creditCardLike = filePatternSearcher(/\d{8,19}/, './logFile.txt')
 *     creditCardLike = filePatternSearcher(String.raw`\d{8,19}`, './logFile.txt')
 *     creditCardLike = filePatternSearcher('\\d{8,19}', './logFile.txt')
 *
 * @param      {RegExp|string}   pattern  The pattern to search for.
 * @param      {string}   file   The path to the file that will be inspected.
 * @return     {[string]}        List of lines that matched the pattern.
 */
async function filePatternSearcher(pattern, file /*, options = {}*/) {
  let expression;
  if (typeof pattern === 'string') {
    expression = new RegExp(pattern);
  } else if (pattern instanceof RegExp) {
    expression = pattern;
  } else {
    throw new PopStackError(`Type of first argument ('${typeof pattern}') is not 'string' or 'RegExp'`);
  }
  if (typeof file !== 'string') {
    throw new PopStackError(`Type of second argument ('${typeof file}') is not 'string'`);
  }
  const filePath = path.resolve(file);

  let content;
  try {
    content = await fsp.readFile(filePath, 'utf8');
  } catch (reason) {
    console.error(reason.message);
    content = '';
  }

  const lines = content.split(/\r?\n|\r/);
  const matches = lines.filter(line => expression.test(line));

  return matches;
}

async function filterFilesContaining(pattern, files) {
  const expression = new RegExp(pattern);

  const searchResult = await Promise.all(
    files.map(async file => {
      const matches = await filePatternSearcher(expression, file);

      return [matches.length, file];
    })
  );

  const filesThatMatched = searchResult.filter(([count]) => count).map(([, file]) => file);

  return filesThatMatched;
}

module.exports = {
  filePatternSearcher,
  filterFilesContaining,
  listFiles
};
