/*
 ** Copyright (c) 2022 Oracle and/or its affiliates.
 */

import {all, delay, select, spawn, take} from 'redux-saga/effects';
import {chain, combineReducers, createReducer, endpointSaga, takeLeading} from '@oracle-cx-commerce/store/utils';
import {isAuthenticated, isMultiSite} from '@oracle-cx-commerce/commerce-utils/selector';

/*
 * Reducers
 */
const LOGIN = 'login';
const TOKEN_REFRESH_INTERVAL = 30000;

let task = null;

/*TODO : For Now these variables are in local, as session handling is the one use case that needs timestamp values.
         These variables might be moved to state, when the other use cases are in place. */
let lastRefreshTimeStamp = 0;
let lastNonRefreshTimeStamp = 0;

/*
  Reducers
 */

const loginReducer = (state, {payload: {rememberUserEmail: rememberMeEnabled = false}}) => {
  // if login action was via our form, then it may have used a hidden input for the boolean value
  // this needs converted from a string to a boolean
  if (typeof rememberMeEnabled === 'string') {
    rememberMeEnabled = rememberMeEnabled.toLowerCase() === 'true';
  }
  const {settings = {}} = state;

  return {
    ...state,
    settings: {
      ...settings,
      rememberMeEnabled
    }
  };
};

/*
  Sagas
 */
export function* registerEndpointsInvokedTime() {
  while (true) {
    const action = yield take('endpointComplete');
    /*lastRefreshTimeStamp will be updated only when the action endpoint is equal to the refresh call of cc server or wishlist server.
      This way the refresh call of wishlist will be considered a refresh call and thus we don't require to again trigger a cc refresh.*/
    if (action.endpointId === 'refresh' || action.endpointId === 'ccRefreshUser' || action.endpointId === 'verify') {
      lastRefreshTimeStamp = Date.now();
    } else {
      lastNonRefreshTimeStamp = Date.now();
    }
  }
}

export function* getCurrentProfileSaga(action) {
  const response = yield endpointSaga({...action, endpointId: 'getCurrentProfile'});

  if (response.ok === true) {
    const state = yield select();

    // if multi-site then load the site properties data
    if (isMultiSite(state)) {
      action.payload = {};

      return yield endpointSaga({...action, endpointId: 'listSiteProperties'});
    }
  }

  return response;
}

function* ccKeepSessionAlive() {
  while (true) {
    let authenticated = yield select(isAuthenticated);

    while (authenticated) {
      if (lastNonRefreshTimeStamp > lastRefreshTimeStamp) {
        yield chain({type: 'refresh'});
      } else {
        //yield chain({type: 'verify'});
      }

      yield delay(TOKEN_REFRESH_INTERVAL);

      authenticated = yield select(isAuthenticated);
    }

    yield take('loginComplete');
  }
}

export function* initAuthenticatedSaga(action) {
  if (task === null) {
    task = yield spawn(ccKeepSessionAlive);
  }

  return yield all([getCurrentProfileSaga(action), endpointSaga({...action, endpointId: 'getCart'})]);
}

export function* loginSaga(action) {
  const response = yield endpointSaga(action);

  if (response.ok === true) {
    for (const response of yield initAuthenticatedSaga(action)) {
      if (response.ok === false) {
        return response;
      }
    }
  }

  return response;
}

export default {
  reducer: combineReducers({
    configRepository: createReducer({[LOGIN]: loginReducer})
  }),

  *saga() {
    yield takeLeading('login', loginSaga);
  }
};
