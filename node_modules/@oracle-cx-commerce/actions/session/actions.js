/*
 ** Copyright (c) 2022 Oracle and/or its affiliates.
 */

import {all, put} from 'redux-saga/effects';
import {combineReducers, createReducer, endpointSaga, takeEvery, takeLeading} from '@oracle-cx-commerce/store/utils';

/*
 * Reducers
 */
const UNAUTHORIZED = '401';
const LOGOUT_SUCCESS = 'logoutSuccess';
const CLEAR_USERNAME = 'clearUsername';

/*TODO : For Now these variables are in local, as session handling is the one use case that needs timestamp values.
         These variables might be moved to state, when the other use cases are in place. */

/*
  Reducers
 */
/*
 * Wrap a (primary) reducer in predicate reducer the allows the primary to run ONLY for "occ"
 * (non-external) endpoints.
 */
const bypassExternal = reducer => (state, action) => {
  if (action.isExternalEndpoint === true) {
    // Do nothing if external endpoint
    return state;
  }

  return reducer(state, action);
};

/*
 * Wrap a reducer in another reducer that halts iof the action is an external endpoint
 */
export const clearReducer = bypassExternal(() => ({}));

/*
 * Wrap a reducer in another reducer that halts iof the action is an external endpoint
 */
export const unauthorizedReducer = bypassExternal(({rememberMe = null}) => ({rememberMe}));

/*
 * Wrap a reducer in another reducer that halts iof the action is an external endpoint
 */
export const expireOrderReducer = bypassExternal(state => ({
  ...state,
  giftWithPurchaseMessages: {},
  orders: {},
  shippingMethods: {}
}));

/*
 * Wrap a reducer in another reducer that halts iof the action is an external endpoint
 */
export const expireProfileReducer = bypassExternal((state, {profiles = {}}) => {
  let newState = {
    ...state,
    profiles: {anonymous: profiles.anonymous},
    secondaryAddresses: {},
    savedCards: {}
  };
  if (state.organizations) newState = {...newState, organizations: {}};
  if (state.roles) newState = {...newState, roles: {}};
  if (state.accessRights) newState = {...newState, accessRights: {}};
  if (state.contactRequests) newState = {...newState, contactRequests: {}};
  if (state.contactInfos) newState = {...newState, contactInfos: {}};
  if (state.siteProperties) newState = {...newState, siteProperties: {}};

  return newState;
});

/*
 * Wrap a reducer in another reducer that halts iof the action is an external endpoint
 */
export const expireReturnReducer = bypassExternal(state => ({
  ...state,
  returns: {}
}));

const clearUsernameReducer = state => {
  return {
    ...state,
    rememberMe: {}
  };
};

/*
 * Wrap a reducer in another reducer that halts iof the action is an external endpoint
 */
export const expirePurchaseListReducer = bypassExternal(state => {
  let newState = {...state};
  if (state.purchaseLists) newState = {...newState, purchaseLists: {}};

  return newState;
});

/*
  Sagas
 */

function* logoutSaga(action) {
  const response = yield endpointSaga(action);

  if (response.ok === true) {
    yield put({...action, type: LOGOUT_SUCCESS});
  } else {
    yield put({type: UNAUTHORIZED});
  }

  return response;
}

export default {
  reducer: combineReducers({
    orderRepository: createReducer({
      [UNAUTHORIZED]: expireOrderReducer,
      [LOGOUT_SUCCESS]: expireOrderReducer
    }),
    profileRepository: createReducer({
      [UNAUTHORIZED]: expireProfileReducer,
      [LOGOUT_SUCCESS]: expireProfileReducer
    }),
    purchaseListRepository: createReducer({
      [UNAUTHORIZED]: expirePurchaseListReducer,
      [LOGOUT_SUCCESS]: expirePurchaseListReducer
    }),
    clientRepository: combineReducers({
      context: combineReducers({
        session: createReducer({
          [UNAUTHORIZED]: unauthorizedReducer,
          [LOGOUT_SUCCESS]: clearReducer,
          [CLEAR_USERNAME]: clearUsernameReducer
        })
      })
    }),
    csrRepository: createReducer({
      [UNAUTHORIZED]: expireReturnReducer,
      [LOGOUT_SUCCESS]: expireReturnReducer
    })
  }),

  *saga() {
    yield all([takeEvery('logout', logoutSaga), takeLeading('ssoLogin', endpointSaga)]);
  }
};
