/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {all} from 'redux-saga/effects';
import {endpointSaga, takeLeading, takeLatest, createReducer} from '@oracle-cx-commerce/store/utils';
import {isEmptyObject} from '@oracle-cx-commerce/utils/generic';
import {
  getCardTypes,
  getCurrentProfileId,
  getInquireBalanceResponseForCurrentUser,
  getInquireBalanceResponses,
  getPaymentConfigurations,
  getPaymentRepository,
  getProfileRepository
} from '@oracle-cx-commerce/commerce-utils/selector';

const CLEAR_INQUIRE_BALANCE = 'clearInquireBalance';
const GET_CARD_TYPES = 'getCardTypes';
const GET_PAYMENT_CONFIGURATIONS = 'getPaymentConfigurations';

/**
 * Reducer which removes stored data under profileRepository.inquireBalanceResponses.<profileId> for the current logged in user
 * depending upon the payload passed with the invoked action.
 * If no payload is passed all the balances under inquireBalanceResponses are cleared.
 * If payload contains type either as giftCards,loyaltyPrograms or storeCredits without any id
 * clears all the balances stored under the specific type passed.
 * If payload contains type and a specific id(giftCardNumber,loyaltyProgramId or storeCreditNumber)
 * clears only the balance for the id passed.
 * @param {Object} state The current state.
 * @param {Object} payload The action payload containing
 * {type optional} The payment type whose previous stored balance has to be cleared.
 * {id optional} The id under the payment type whose balance is to be removed.
 * @returns {Object} The updated state
 */
const clearInquireBalanceReducer = (state, {payload = {}}) => {
  const inquireBalanceResponses = getInquireBalanceResponseForCurrentUser(state);
  if (!inquireBalanceResponses || isEmptyObject(inquireBalanceResponses)) {
    return state;
  }
  const {type, id} = payload;
  let remainingBalances = {};
  // If a specific payment type has not been passed all the balances will be cleared.
  if (type) {
    if (!inquireBalanceResponses[type] || (id && !inquireBalanceResponses[type][id])) {
      return state;
    }
    // Get the payment type whose balance has to be removed.
    const {[type]: paymentTypeBalances, ...otherPaymentTypeBalances} = inquireBalanceResponses;
    let otherBalances = {};
    // If an id has been passed separate the passed in id from other stored entries for the payment type.
    if (id) {
      const {[id]: removedBalance, ...remainingEntries} = paymentTypeBalances;
      // If the state for the payment type contains only the customPaymentProperties and all the balance have been removed, remove the customPaymentProperties
      if (
        Object.keys(remainingEntries).length === 1 &&
        Object.prototype.hasOwnProperty.call(remainingEntries, 'customPaymentProperties')
      ) {
        otherBalances = {};
      } else {
        otherBalances = remainingEntries;
      }
    }
    // Add the type passed for removal to remainingBalances if there are some balances still remaining for the type.
    remainingBalances = {
      ...otherPaymentTypeBalances,
      ...(otherBalances && !isEmptyObject(otherBalances) && {[type]: otherBalances})
    };
  }

  // If there are no remainingBalances and if there are no inquiredBalances for other profile Ids, then remove the inquireBalanceResponses key from the profileRepository state
  // else add the remainingBalances to inquireBalanceResponses
  const profileRepository = getProfileRepository(state);
  const allInquiredBalances = getInquireBalanceResponses(state);
  let profileRepositoryState = {};
  if (isEmptyObject(remainingBalances) && Object.keys(allInquiredBalances).length === 1) {
    const {inquireBalanceResponses, ...remainingEntries} = profileRepository;
    profileRepositoryState = remainingEntries;
  } else {
    profileRepositoryState = {
      ...profileRepository,
      inquireBalanceResponses: {
        [getCurrentProfileId(state)]: {
          ...remainingBalances
        }
      }
    };
  }

  return {
    ...state,
    profileRepository: {
      ...profileRepositoryState
    }
  };
};

/**
 * Reducer which removes stored data under paymentRepository.cardTypes
 * @param {Object} state The current state.
 * @returns {Object} The updated state
 */
const clearCardTypesReducer = state => {
  const cardTypes = getCardTypes(state);
  if (!cardTypes || isEmptyObject(cardTypes)) {
    return state;
  }

  return {
    ...state,
    paymentRepository: {
      ...getPaymentRepository(state),
      cardTypes: {}
    }
  };
};

/**
 * Reducer which removes stored data under paymentRepository.paymentConfigurations
 * @param {Object} state The current state.
 * @returns {Object} The updated state
 */
const clearPaymentConfigurationsReducer = state => {
  const paymentConfigurations = getPaymentConfigurations(state);
  if (!paymentConfigurations || isEmptyObject(paymentConfigurations)) {
    return state;
  }

  return {
    ...state,
    paymentRepository: {
      ...getPaymentRepository(state),
      paymentConfigurations: {}
    }
  };
};

export default {
  reducer: createReducer({
    [CLEAR_INQUIRE_BALANCE]: clearInquireBalanceReducer,
    [GET_CARD_TYPES]: clearCardTypesReducer,
    [GET_PAYMENT_CONFIGURATIONS]: clearPaymentConfigurationsReducer
  }),
  *saga() {
    yield all([
      takeLeading('addPayments', endpointSaga),
      takeLeading('applyPayments', endpointSaga),
      takeLeading('calculateRemainingBalance', endpointSaga),
      takeLeading('deleteAppliedPayment', endpointSaga),
      takeLatest('getBillingCountries', endpointSaga),
      takeLatest('getCardTypes', endpointSaga),
      takeLatest('getPaymentGroup', endpointSaga),
      takeLeading('getPaymentInitiatedOrder', endpointSaga),
      takeLatest('getPaymentConfigurations', endpointSaga),
      takeLeading('initiatePayment', endpointSaga),
      takeLeading('inquireBalance', endpointSaga),
      takeLeading('updateAppliedPayment', endpointSaga)
    ]);
  }
};
