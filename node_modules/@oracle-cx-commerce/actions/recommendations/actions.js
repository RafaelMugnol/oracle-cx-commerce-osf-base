/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

/* eslint-env browser */

import {all, select} from 'redux-saga/effects';
import {endpointSaga, takeEvery, subscribe} from '@oracle-cx-commerce/store/utils';
import {
  getCategoryIdForCurrentPage,
  getCurrentCatalogId,
  getCurrentOrder,
  getCurrentOrderId,
  getCurrentOrgId,
  getCurrentPageId,
  getCurrentProductId,
  getCurrentProfileId,
  getGlobalContext,
  getOrder,
  getPage,
  getProductionRecommendations,
  getRecommendationsRepository,
  getRegion,
  getSite,
  getSearchResults,
  getTypeaheadSearchResults,
  getWidget,
  isAuthenticated
} from '@oracle-cx-commerce/commerce-utils/selector';
import {isObject, isEmptyObject, merge} from '@oracle-cx-commerce/utils/generic';
import {ORDER_STATE_SUBMITTED} from '@oracle-cx-commerce/commerce-utils/constants';
import {getCookie} from '@oracle-cx-commerce/utils/node';
// Temporary workaround until the OSF version is available in the state
import commerceUtilsPackage from '@oracle-cx-commerce/commerce-utils/package.json';

/**
 * Gets the currency code from the state
 *
 * @param {*} state
 */
export const getCurrencyCode = state => {
  const {priceListGroupList = []} = getSite(state);
  const {priceListGroup = ''} = getGlobalContext(state);
  const {currency = {}} = priceListGroupList.find(({id}) => id === priceListGroup) || {};

  return currency.currencyCode;
};

/**
 * Returns an array of product ids of the products in an order
 *
 * @param {*} order
 */
export const getProductIdsFromOrder = (order = {}) => {
  let productIds = [];
  if (order.commerceItems) {
    productIds = Object.values(order.commerceItems).map(item => item.productId);
  }

  return productIds;
};

/**
 * Returns an array of product details for Recommendations from an order
 *
 * @param {*} order
 */
export const getProductsFromOrder = (order = {}) => {
  let products = [];
  if (order.commerceItems) {
    // return just the productId, quantity and price values to send to Recommendations
    products = Object.values(order.commerceItems).map(item => {
      const product = {
        productId: item.productId,
        quantity: item.quantity,
        price: item.price
      };

      return product;
    });
  }

  return products;
};

/**
 * Add resource to resources array making sure to keep view as the first element and
 * recommendations resource as last to work around issue with pipeline handling in PR
 *
 * @param {*} resources
 * @param {*} params
 * @param {*} resource
 * @param {*} json
 */
export const addResource = (resources = [], params = {}, resource, json) => {
  // add the resource unless it already exists
  if (!resources.includes(resource)) {
    resources.push(resource);
  }

  // Reorder the array to make sure "view" is first element and "recommendations" is the last
  // and everything else is alphabetical.
  // pipe-lined resources are in the form of view/recommendations or view/cart/recommendations only
  resources.sort((a, b) => {
    /* eslint-disable no-nested-ternary */
    return a === 'view' || b === 'recommendations' ? -1 : a === 'recommendations' || b === 'view' ? 1 : a < b ? -1 : 1;
    /* eslint-enable no-nested-ternary */
  });

  // Merge the passed json into the params Object
  merge(params, json);
};

/**
 * Add or replace a parameter in the params object
 *
 * @param {*} params
 * @param {*} obj
 */
export const addParam = (params = {}, obj) => {
  let paramName, paramValue;

  for (paramName in obj || {}) {
    paramValue = obj[paramName];

    // if the param isn't an Object or Array, its a scalar
    // we only want to keep scalars to return
    // we also want to exempt retailerId as it is passed in the request path
    if (!isObject(paramValue) && paramName !== 'retailerId') {
      // we don't have to clone this because scalars will be copied
      // on assignment
      params[paramName] = paramValue;
    }
  }
};

// Helper functions to make the look-ups used in getChildWidgets and getWidgetsForPage more succinct
export const getWidgetFromState = state => widgetId => getWidget(state, {widgetId});
export const getRegionFromState = state => regionId => getRegion(state, {regionId});
// Converting the arrays to a Set will de-duplicate them, then convert the Set back into an Array
export const deduplicateArrays = (...arrays) => Array.from(new Set(arrays.flatMap(array => array || [])));

// Selector for globalRules
export const getRecommendationGlobalRules = state =>
  (getRecommendationsRepository(state).preview || {}).globalRules || [];

// Selector for strategy
export const getRecommendationStrategy = (state, {strategyId} = {}) =>
  ((getRecommendationsRepository(state).preview || {}).strategies || {})[strategyId] || {};

/**
 * Recursively get all child widgets of the specified widgetId by
 * finding the widget regions and all of their widgets.
 * NOTE: This function does not currently support stacks.
 *
 * @param {*} state
 * @param {*} widgetId
 */
export const getChildWidgets = (state, {widgetId}) => {
  // With all the regionIds of the widget
  const childWidgets = (getWidgetFromState(state)(widgetId).regions || [])
    // get the region object
    .map(getRegionFromState(state))
    // get the region's widgetIds
    .flatMap(region => region.widgets || [])
    // get the widget object
    .map(getWidgetFromState(state));

  // Append the widgets of children of each child widget recursively
  return childWidgets.concat(
    childWidgets.flatMap(widget => (widget.id ? getChildWidgets(state, {widgetId: widget.id}) : []))
  );
};

/**
 * Get all widgets for the specified pageId (defaulting to the current page id)
 * NOTE: This function does not currently support stacks.
 *
 * @param {*} state
 * @param {*} pageId
 */
export const getWidgetsForPage = (state, {pageId = getCurrentPageId(state)} = {}) => {
  const {header, main, footer} = getPage(state, {pageId});

  return (
    // With all the unique regions on the page sections
    deduplicateArrays(header, main, footer)
      // get region object
      .map(getRegionFromState(state))
      // get the region's widgetIds
      .flatMap(region => region.widgets || [])
      // get widget objects for each, recursively into each widget
      .flatMap(widgetId => deduplicateArrays([getWidgetFromState(state)(widgetId)], getChildWidgets(state, {widgetId})))
  );
};

/**
 * Check if the site requires GDPRCookieConsent and if the current browser has granted P13nConsent
 */
export const hasP13nCookieConsent = state => {
  const {requireGDPRCookieConsent = false} = getSite(state);

  // If either cookies are set to anything then consent has been granted.
  // NOTE: getCookie returns both the name and value (i.e. 'GDPRCookieP13nConsentGranted=true') -- not just the value
  return !!(
    !requireGDPRCookieConsent ||
    getCookie(document.cookie, 'GDPRCookieP13nConsentNotRequired') ||
    getCookie(document.cookie, 'GDPRCookieP13nConsentGranted')
  );
};

// Put session specific variables outside the function
let firstRequest = true;
let checkoutOrderId = '';

export function* recommendationsSaga(action) {
  const state = yield select();
  const {pageType, title, locale, layout} = getPage(state);
  const {isPreview, priceListGroup, site, visitorId} = getGlobalContext(state);
  const {version} = commerceUtilsPackage;

  let sendSearch = false;
  // If action is endpointResolved and not 'search' return immediately
  if (action.type === 'endpointResolved') {
    const {endpointId} = action;
    // Ignore every endpoint except search and only on category and search pages
    // Only send search if the endpoint completed successfully
    if (
      endpointId === 'search' &&
      (pageType === 'collection' || pageType === 'category' || pageType === 'search') &&
      action.ok
    ) {
      sendSearch = true;
    } else {
      return;
    }
  }

  let response;
  let productionRecommendations = getProductionRecommendations(state);
  if (isEmptyObject(productionRecommendations)) {
    response = yield endpointSaga({
      ...action,
      endpointId: 'getProductionRecommendations',
      payload: {}
    });
    productionRecommendations = yield select(getProductionRecommendations);
  }

  const resources = [];
  const params = {};
  let sendCart = false;

  // Locale
  addParam(params, {locale});

  // Site id
  addParam(params, {ccSiteId: site});

  // Only add the customerId if the user is authenticated
  if (isAuthenticated(state)) {
    addParam(params, {customerId: getCurrentProfileId(state)});
  }

  // OCC Visitor ID
  if (visitorId) {
    addParam(params, {ccVisitorId: visitorId});
  }

  // OCC B2B Account ID
  // Note: this is undefined during the initRecommendations action
  // because the profileRepository has not yet been populated.
  const currentOrgId = getCurrentOrgId(state);
  if (currentOrgId) {
    addParam(params, {accountId: currentOrgId});
  }

  // Preview
  addParam(params, {preview: isPreview});

  // GDPR
  if (!hasP13nCookieConsent(state)) {
    addParam(params, {gdpr: true});
  }

  // Channel
  const channel = `OSF${version ? `-${version}` : ''}`;
  addParam(params, {channel});

  // If this is a page load or initial page, then add a view request for Recommendations
  if (action.type === 'getApplicationPageResolved' || action.type === 'initRecommendations') {
    const {url} = (action.originalAction && action.originalAction.payload) || action.payload;

    // The object to add on any extra view data to the request
    const viewData = {
      url: url && url.href,
      layoutId: layout,
      pageType
    };

    // add the referrer if this was the landing page
    if (firstRequest) {
      // Note: this needs to be updated once the referrer is added to the state
      const {referrer} = document;
      if (referrer) {
        viewData.referrer = referrer;
      }
      firstRequest = false;
    }

    // Catalog ID
    const catalogId = getCurrentCatalogId(state);
    if (catalogId) {
      viewData.storeId = catalogId;
      viewData.excludeDefaultStore = true;
    }

    if (pageType === 'product') {
      viewData.productId = getCurrentProductId(state);
    }

    if (pageType === 'collection' || pageType === 'category') {
      // Send leaf id for now.
      viewData.category = getCategoryIdForCurrentPage(state);
      // If the initial page is a category page, the search endpoint is not used
      // so we need to make sure to remember to include the search payload here.
      if (action.type === 'initRecommendations') {
        sendSearch = true;
      }
    }

    // Page title
    viewData.pageTitle = title;

    // Price list Group
    viewData.pricelistGroupId = priceListGroup;

    // Currency code
    const currencyCode = getCurrencyCode(state, priceListGroup);
    if (currencyCode) {
      viewData.currencyCode = currencyCode;
    }

    // Always send cart on view requests
    sendCart = true;

    if (pageType === 'search') {
      sendSearch = true;
      const {searchEventSummary} = getSearchResults(state);
      if (searchEventSummary && searchEventSummary.searchTermsRaw) {
        viewData.searchText = searchEventSummary.searchTermsRaw;
      } else if (url && url.search) {
        // url is defined as a Location above
        const query = Object.fromEntries(new URLSearchParams(url.search));
        if (query.Ntt) {
          viewData.searchText = query.Ntt;
        }
      }
    }

    addResource(resources, params, 'view', {
      view: viewData
    });

    const slotData = {};
    const defaultSlotConfig = {numRecs: 12, dataItems: ['repositoryId']};

    // TODO: Find a better way to filter recommendations widgets (i.e. a non-visible configuration on the component?)
    const recsWidgets = getWidgetsForPage(state).filter(widget => widget.maximumNumberOfProducts && widget.strategy);

    // Get global rules if isPreview and there are recommendations widgets
    if (isPreview && recsWidgets.length > 0) {
      yield endpointSaga({
        ...action,
        endpointId: 'listRecommendationGlobalRules',
        payload: {}
      });
    }

    for (const recWidget of recsWidgets) {
      const {id, maximumNumberOfProducts = '12', strategy = 'Blended'} = recWidget;

      // Handle if maximumNumberOfProducts is bad (negative, zero, etc.)
      let numRecs = 12;
      if (parseInt(maximumNumberOfProducts, 10) > 0) {
        // Cap the number of recommendations to request to 100 in case the configured value is very large
        numRecs = Math.min(parseInt(maximumNumberOfProducts, 10), 100);
      }

      const slotObject = {numRecs};
      // If preview, add globalRules to slot
      if (isPreview) {
        // Add globalRules to slot even if the strategy details cannot be retrieved
        const globalRules = yield select(getRecommendationGlobalRules);
        if (globalRules && globalRules.length > 0) {
          slotObject.globalRules = globalRules;
        }
      }
      if (strategy !== 'Blended' && strategy !== '') {
        // Map strategy to rule
        // This map translates between the OOTB strategy IDs and the rule IDs the old widget used to send.
        const RULE_MAP = {
          'Top Sellers': 'topSellers',
          'Browsed Together': 'topCobrowses',
          'Purchased Together': 'topCobuys',
          'Most Recently Viewed': 'mostRecentlyViewed'
        };

        // If an OOTB strategy was chosen, use an array with the old rule ID (or no rule in the case they chose Blended)
        if (RULE_MAP[strategy]) {
          slotObject.rule = [RULE_MAP[strategy]];
        } else {
          // Otherwise, a custom strategy must have been chosen, in which case, strategy is either a JSON string or an object.
          // Add strategy ID to the slot OR
          // if running in preview mode add the strategy recommendation groups to the slot
          let strategyObject = {};
          // If strategy is a string, try to create an object from it
          try {
            strategyObject = typeof strategy === 'string' && strategy.startsWith('{') ? JSON.parse(strategy) : strategy;
          } catch (e) {
            // no-op
          }
          const {id: strategyId} = strategyObject;
          if (strategyId) {
            slotObject.strategyId = strategyId;

            // If preview, add recommendationGroups to slot instead of strategyId
            if (isPreview) {
              // Get strategy details
              const response = yield endpointSaga({
                ...action,
                endpointId: 'getRecommendationStrategy',
                payload: {strategyId}
              });

              if (response.ok) {
                // Add recommendationGroups to slot instead of strategyId
                const strategy = yield select(getRecommendationStrategy, {
                  strategyId
                });
                if (strategy && strategy.recommendationGroups) {
                  slotObject.recommendationGroups = strategy.recommendationGroups;
                  delete slotObject.strategyId;
                }
              }
            }
          }
        }
      }

      slotData[id] = {
        ...defaultSlotConfig,
        ...slotObject,
        dataItems: [...defaultSlotConfig.dataItems, ...(slotObject.dataItems ? slotObject.dataItems : [])]
      };
    }

    if (!isEmptyObject(slotData)) {
      addResource(resources, params, 'recommendations', {
        slots: slotData
      });
    }
  }

  if (action.type === 'typeaheadResolved' && action.payload.ok) {
    const {searchEventSummary} = getTypeaheadSearchResults(state);
    if (searchEventSummary) {
      addResource(resources, params, 'search', {search: searchEventSummary});
    }
  }

  if (sendSearch) {
    const {searchEventSummary} = getSearchResults(state);
    if (searchEventSummary) {
      addResource(resources, params, 'search', {search: searchEventSummary});
    }
  }

  // Hold onto the order id so it it available during the 'checkoutCartResolved'
  if (action.type === 'checkoutCart') {
    checkoutOrderId = getCurrentOrderId(state);
  }
  if (action.type === 'checkoutCartResolved' && action.payload.ok) {
    const order = getOrder(state, {id: checkoutOrderId});
    // Valid states copied from checkout place order button component, handleOrderSubmitSuccess
    if (
      order.state === ORDER_STATE_SUBMITTED ||
      order.state === 'PENDING_APPROVAL' ||
      order.state === 'PENDING_APPROVAL_TEMPLATE'
    ) {
      if (order.commerceItems && Object.keys(order.commerceItems).length > 0) {
        addResource(resources, params, 'checkout', {
          checkout: {
            productIds: getProductIdsFromOrder(order),
            products: getProductsFromOrder(order),
            pricelistGroupId: (order.priceListGroup || {}).id,
            currencyCode: (order.priceInfo || {}).currencyCode,
            totalPrice: (order.priceInfo || {}).total
          }
        });
        // Clear out cached order id
        checkoutOrderId = undefined;
      }
    }
  }

  // TODO: gift with purchase actions
  if (
    (action.type === 'addItemsToCartResolved' ||
      action.type === 'deleteItemFromCartResolved' ||
      action.type === 'updateCartItemResolved' ||
      action.type === 'updateCartItemsResolved' ||
      action.type === 'loginComplete' ||
      action.type === 'logoutComplete') &&
    action.payload.ok
  ) {
    sendCart = true;
  }

  if (sendCart) {
    // Cart
    // Use orderRepository and parse order object.
    const order = getCurrentOrder(state);
    if (order.commerceItems && Object.keys(order.commerceItems).length > 0) {
      addResource(resources, params, 'cart', {
        cart: {
          productIds: getProductIdsFromOrder(order),
          products: getProductsFromOrder(order),
          pricelistGroupId: (order.priceListGroup || {}).id,
          currencyCode: (order.priceInfo || {}).currencyCode,
          totalPrice: (order.priceInfo || {}).total
        }
      });
    } else {
      // Otherwise just return the empty array or productIds.
      addResource(resources, params, 'cart', {
        cart: {
          productIds: getProductIdsFromOrder(order)
        }
      });
    }
  }

  if (action.type === 'recommendationsClickThru') {
    const {product, recSetId} = action.payload;
    if (product && recSetId) {
      addResource(resources, params, 'clickThru', {
        click: {
          recSetId,
          productId: product.id
        }
      });
    }
  }

  // Only send request if we have resources
  if (resources.length > 0) {
    response = yield endpointSaga({
      ...action,
      endpointId: 'recommendations',
      payload: {resources, params}
    });

    return response;
  }
}

export default {
  *saga() {
    yield all([
      // TODO: Possibly change this to takeOnce:
      subscribe('initRecommendations', recommendationsSaga),
      subscribe('getApplicationPageResolved', recommendationsSaga),
      subscribe('addItemsToCartResolved', recommendationsSaga),
      subscribe('deleteItemFromCartResolved', recommendationsSaga),
      subscribe('updateCartItemResolved', recommendationsSaga),
      subscribe('updateCartItemsResolved', recommendationsSaga),
      subscribe('checkoutCart', recommendationsSaga),
      subscribe('checkoutCartResolved', recommendationsSaga),
      subscribe('loginComplete', recommendationsSaga),
      subscribe('logoutComplete', recommendationsSaga),
      subscribe('typeaheadResolved', recommendationsSaga),
      // Currently used by show more products button
      subscribe('searchResolved', recommendationsSaga),
      // Used to send search data from asynchronous search requests used on category pages
      subscribe('endpointResolved', recommendationsSaga),
      takeEvery('recommendationsClickThru', recommendationsSaga)
    ]);
  }
};
