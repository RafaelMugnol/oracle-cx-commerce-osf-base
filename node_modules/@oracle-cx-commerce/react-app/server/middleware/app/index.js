/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {Request, Response} from 'node-fetch';
import {URL, URLSearchParams} from 'url';
import {getCookie, getCookieFromSetCookieHeader, getCookieValue} from '@oracle-cx-commerce/utils/node';
import {isStorable, setAdditionalState} from '@oracle-cx-commerce/react-app/server/middleware/app/utils';

import {createStore} from '@oracle-cx-commerce/store/server';
import {createWapi} from '@oracle-cx-commerce/wapi';
import {getLocalPage} from '@oracle-cx-commerce/react-app/server/middleware/app/local';
import {getWidgets} from '@oracle-cx-commerce/commerce-utils/selector';
import {preloadComponents} from '@oracle-cx-commerce/commerce-utils/react';
import sendRenderedPageBody from '@oracle-cx-commerce/react-app/server/middleware/app/html/index.html';
import {updateState} from '@oracle-cx-commerce/utils/store';

/**
 * Send the raw (unprocessed) page body-- will be either json or html/text.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const sendRawPageBody = (req, res) => {
  const {baseUrl} = req;

  const {pageResponse} = res.locals;

  const {json, text} = pageResponse;

  let body;

  if (text) {
    body = text.replace(/\/ccstore\/v1\/clientApplications\/[^/]+\/page/, baseUrl);
  } else {
    body = json;
  }

  res.send(body);
};

/**
 * Should this page response header be forwarded to the current response?
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const shouldForwardHeader = (header = '') => {
  header = header.toLowerCase();

  if (
    header === 'connection' ||
    header === 'vary' ||
    header === 'content-encoding' ||
    header === 'content-length' ||
    header === 'keep-alive' ||
    header === 'transfer-encoding' ||
    header === 'te' ||
    header === 'trailer' ||
    header === 'upgrade' ||
    header === 'proxy-authorization' ||
    header === 'proxy-authenticate'
  ) {
    return false;
  }

  return true;
};

/**
 * Send the raw (unprocessed) page headers.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const sendRawPageHeaders = (req, res) => {
  const {pageResponse} = res.locals;

  const {headers} = pageResponse;

  // Send page response headers
  for (const [key, value] of Object.entries(headers.raw())) {
    if (shouldForwardHeader(key)) {
      if (value.length > 1) {
        res.set(key, value);
      } else {
        res.set(key, value[0]);
      }
    }
  }
};

/**
 * Send the raw (unprocessed) page status.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const sendRawPageStatus = (req, res) => {
  const {pageResponse} = res.locals;

  const {status} = pageResponse;

  res.status(status);
};

/**
 * Send the complete raw (unprocessed) page response.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const sendRawPage = (req, res) => {
  sendRawPageStatus(req, res);

  sendRawPageHeaders(req, res);

  sendRawPageBody(req, res);
};

/**
 * Determine if the SSR page is store-able.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 * @returns {Boolean}
 */
const isPageStorable = (req, res) => {
  return isStorable(...res.locals.fetched);
};

/**
 * Send the server rendered page headers.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const sendRenderedPageHeaders = (req, res) => {
  if (isPageStorable(req, res) === true) {
    res.set('Cache-Control', 'public, s-max-age=300');
  } else {
    res.set('Cache-Control', 'private, no-cache');
  }

  res.set('X-Content-Type-Options', 'nosniff');

  res.set('X-XSS-Protection', '1; mode=block');
};

/**
 * Was the page response a basic authentication challenge.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const isLoginChallengeAfterBasicAuth = (req, res) => {
  const {pageResponse} = res.locals;

  const authorization = req.get('Authorization') || '';

  if (authorization.includes('Basic') && pageResponse.status === 401) {
    return true;
  }

  return false;
};

/**
 * Send the server rendered page status.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const sendRenderedPageStatus = (req, res) => {
  const {pageResponse} = res.locals;

  let {status} = pageResponse;

  /* 
    Non production server that have Basic Auth enabled, however
    this can interfere with the application authenticated page 
    mechanism, i.e. sending a 401 status after a basic auth 
    challenge is not handled well by Chrome. The workaround is to 
    detect the scenario and send a 200 status instead.

    !!! This issue DOES NOT affect production servers !!! 
   */
  if (isLoginChallengeAfterBasicAuth(req, res)) {
    status = 200;
  }

  res.status(status);
};

/**
 * Send the complete server rendered page response.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const sendRenderedPage = async (req, res) => {
  sendRenderedPageStatus(req, res);

  sendRenderedPageHeaders(req, res);

  await sendRenderedPageBody(req, res);
};

/**
 * Run the component data fetchers.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setState = async (req, res) => {
  const {originalComponents} = req.app.locals;

  const {store} = res.locals;

  const state = store.getState();

  /*
   * The `Root` component does not appear in the page so must be added manually. `Root` is
   * ALWAYS the root component of the application.
   */
  // eslint-disable-next-line new-cap
  const allFetchers = [...(await originalComponents.Root()).fetchers];

  for (const widgetConfig of Object.values(getWidgets(state))) {
    const {componentId} = widgetConfig;

    const load = originalComponents[componentId];

    if (load) {
      const {fetchers} = await load();

      if (fetchers) {
        // Collect all fetchers
        for (const fetcher of fetchers) {
          // Create partial fetcher function to ensure the correct (corresponding) widget configuration
          // values are passed to each fetcher.
          //
          // NB Some fetchers will depend on the widget configuration (Widget specific), others will not (Generic),
          // but it's always passed.
          allFetchers.push(store => fetcher(store, widgetConfig));
        }
      }
    }
  }

  // Initiate fetch (in parallel) and wait for all (parallel) fetch requests to complete
  await Promise.all(allFetchers.map(fetcher => fetcher(store)));

  res.locals.state = store.getState();
};

/**
 * Forward the plg cookie from the page response on the current response
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setPriceListGroupCookie = (req, res) => {
  const {page} = res.locals;

  const {currentPriceGroupId} = page.context;

  res.cookie('storePriceListGroupId', currentPriceGroupId, {httpOnly: true, sameSite: true});
};

/**
 * Forward the visitor cookies from the page response on the current response
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setVisitorCookie = (req, res) => {
  const {pageResponse} = res.locals;

  const cookie = pageResponse.headers.get('Set-Cookie');

  const visitorIdCookie = getCookieFromSetCookieHeader(cookie, 'xd.*?');

  if (visitorIdCookie) {
    res.append('Set-Cookie', `${visitorIdCookie};Path=/`);
  }

  const visitIdCookie = getCookieFromSetCookieHeader(cookie, 'xv.*?');

  if (visitIdCookie) {
    res.append('Set-Cookie', `${visitIdCookie};Path=/`);
  }

  const maxymizerCookie = getCookieFromSetCookieHeader(cookie, 'xm.*?');

  if (maxymizerCookie) {
    res.append('Set-Cookie', `${maxymizerCookie};Path=/`);
  }
};

/**
 * If x-frame-options header is there in response then add respective
 * headers in res
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setAntiClickJackHeaders = (req, res) => {
  const {pageResponse} = res.locals;

  const xFrameHeader = pageResponse.headers.get('x-frame-options');
  if (xFrameHeader && xFrameHeader === 'SAMEORIGIN') {
    res.set('x-frame-options', 'SAMEORIGIN');
    res.set('Content-Security-Policy', 'frame-ancestors self');
  }
};

/**
 * Extract (and/or set) application relevant contextual information from the page response. This is
 * information is placed on `res.local` so it is accessible to all subsequent middleware.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setContextFromPage = (req, res) => {
  setVisitorCookie(req, res);

  setPriceListGroupCookie(req, res);

  setAntiClickJackHeaders(req, res);
};

/**
 * Determine if the fetched page has a valid layout.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const pageHasLayout = (req, res) => {
  const {page = {}} = res.locals;

  const {context, layout, metadata, status} = page;

  if (context && layout && metadata && status) {
    return true;
  }

  return false;
};

/**
 * Handle a redirect directive from the page layout request (if present).
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const handleRedirect = (req, res) => {
  const {page = {}} = res.locals;

  const {status} = page;

  if (status) {
    const {pageResponse} = res.locals;

    const {headers} = pageResponse;

    const redirectType = headers.get('X-CC-Redirect-Type') || status.status;

    const redirectLocation = headers.get('X-CC-Redirect-Location') || status.location;

    if (redirectType && redirectLocation) {
      res.redirect(Number(redirectType), redirectLocation);

      return true;
    }
  }

  return false;
};

/**
 * Should we load assets filesystem (local)?--i.e. `dsAssetMode = false`.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const getDsAssetMode = req => {
  const {options} = req.app.locals;

  const dsAssetMode = options.dsAssetMode || '';

  return dsAssetMode.toLowerCase();
};

/**
 * Fetch the page layout and set the response on the middleware chain.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setPage = async (req, res) => {
  const {store, location} = res.locals;

  const pageResponse = await store.endpoint('getApplicationPage', {
    url: location,

    getLocalPage(page) {
      if (getDsAssetMode(req) === 'local') {
        res.locals.page = page;

        return getLocalPage(req, res);
      }
    }
  });

  res.locals.pageResponse = pageResponse;

  res.locals.page = pageResponse.json;
};

/**
 * Create initial application state that will be used to initialize the Store.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const createInitialState = (req, res) => {
  const {options} = req.app.locals;

  const {browserCapabilities, additionalState = [], fetch, location} = res.locals;

  // Create initial state
  let state = {
    clientRepository: {
      context: {
        global: {
          baseUrl: req.baseUrl,
          path: req.path,
          application: options.appName,
          production: options.production,
          appServerURL: options.appServerURL,
          // TODO - remove - this needs to come from getApplicationPage
          mobile: browserCapabilities.has('mobile'),
          publicBaseUrl: options.publicBaseUrl
        }
      }
    },
    configRepository: {
      endpoints: {
        getApplicationPage: {
          useOptimisticLock: false,
          method: 'GET',
          requestType: null,
          cachingEnabled: false,
          hasPathParams: true,
          url: '/ccstore/v1/clientApplications/{}/page/{}',
          httpsRequired: false,
          authRequired: false,
          responseType: 'application/json',
          localeHint: 'assetLanguageOptional',
          hasDoc: false,
          id: 'getApplicationPage',
          singular: false
        }
      }
    },
    global: {
      fetch,
      location
    }
  };

  // Merge additional state
  for (const delta of additionalState) {
    state = updateState(state, delta);
  }

  return state;
};

/**
 * Initialize the Store on middleware chain.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setStore = async (req, res) => {
  const {wapi} = req.app.locals;

  const state = createInitialState(req, res);

  res.locals.store = createStore({wapi, state});
};

/**
 * Extract the shopper context from the request and ensure it is put into the
 * initial store state.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setShopperContextFromRequest = (req, res) => {
  const OCStateData = getCookieValue(req.get('Cookie'), 'OCStateData');

  if (OCStateData) {
    setAdditionalState(res, {
      clientRepository: {
        context: {
          session: {
            OCStateData
          }
        }
      }
    });
  }
};

/**
 * Extract preview context data from the request and ensure it is put into the
 * initial store state.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setPreviewContextFromRequest = (req, res) => {
  const {ccdate} = req.query;

  if (ccdate) {
    setAdditionalState(res, {
      clientRepository: {
        context: {
          global: {
            ccdate
          }
        }
      }
    });
  }
};

/**
 * Extract the organization from the request and ensure it is put into the
 * initial store state.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setOrganizationFromRequest = (req, res) => {
  let {currentOrganization} = req.query;

  if (!currentOrganization) {
    currentOrganization = getCookieValue(req.get('Cookie'), 'currentOrganization');
  }

  if (currentOrganization) {
    setAdditionalState(res, {
      clientRepository: {
        context: {
          global: {
            currentOrganization
          }
        }
      }
    });
  }
};

/**
 * Extract the price list group from the request and ensure it is put into the
 * initial store state.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setPriceListGroupFromRequest = (req, res) => {
  let {storePriceListGroupId} = req.query;

  if (!storePriceListGroupId) {
    storePriceListGroupId = getCookieValue(req.get('Cookie'), 'storePriceListGroupId');
  }

  if (storePriceListGroupId) {
    setAdditionalState(res, {
      clientRepository: {
        context: {
          global: {
            priceListGroup: storePriceListGroupId
          }
        }
      }
    });
  }
};

/**
 * Set the values for the `X-Forwarded-*` and `Forwarded` headers on the middleware chain.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setForwardedHeaders = (req, res) => {
  if (!req.get('X-Forwarded-For')) {
    res.locals['X-Forwarded-For'] = req.ip;
  }

  if (!req.get('X-Forwarded-Host')) {
    res.locals['X-Forwarded-Host'] = req.get('Host');
  }

  if (!req.get('X-Forwarded-Proto')) {
    res.locals['X-Forwarded-Proto'] = req.protocol;
  }

  if (!req.get('Forwarded')) {
    const byId = '_Oracle_OCX_OSF';
    const host = req.get('Host');
    const proto = req.protocol;
    // OSF server receives incorrect data about the source IP address,
    // which is always set to 'localhost'.
    //const forId = req.ip;
    //res.locals['Forwarded'] = `by=${byId};for=${forId};host=${host};proto=${proto}`;
    res.locals['Forwarded'] = `by=${byId};host=${host};proto=${proto}`;
  }
};

/**
 * Set the value for the `Host` header on the middleware chain.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setHost = (req, res) => {
  const {options} = req.app.locals;

  res.locals.Host = new URL(options.appServerURL).host;
};

/**
 * If the request contain a visitorId then set earlyVisitInitialized=true
 * to prevent [redudant] initialization of visitor id.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setVisitorFromRequest = (req, res) => {
  const cookie = req.get('Cookie');

  if (cookie) {
    const visitorIdCookie = getCookie(cookie, 'xd.*?');

    if (visitorIdCookie) {
      setAdditionalState(res, {
        clientRepository: {
          context: {
            global: {
              earlyVisitInitialized: true
            }
          }
        }
      });
    }
  }
};

/**
 * Extract (and/or set) application relevant contextual information from the request. This is information
 * is placed on `res.local` so it is accessible to all subsequent middleware.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setContextFromRequest = (req, res) => {
  setVisitorFromRequest(req, res);

  setHost(req, res);

  setForwardedHeaders(req, res);

  setPriceListGroupFromRequest(req, res);

  setOrganizationFromRequest(req, res);

  setShopperContextFromRequest(req, res);

  setPreviewContextFromRequest(req, res);
};

/**
 * Set some common browser globals on the node global scope, i.e. `fetch`, `URL`, etc. This helps facilitate some
 * isomorphic modules such as `@oracle-cx-commerce/wapi`.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setBrowserGlobals = (req, res) => {
  global.Request = Request;

  global.Response = Response;

  global.URL = URL;

  global.URLSearchParams = URLSearchParams;

  res.locals.location = new URL(`${req.protocol}://${req.get('Host')}${req.originalUrl}`);
};

/**
 * JSON.stringify replacer function that filters props with keys that start with the
 * string `pattern`.
 *
 * @param {String} pattern
 * @returns {any}
 */
const createPropFilter = pattern => (key, value) => {
  if (key.startsWith(pattern)) {
    return undefined;
  }

  return value;
};

/**
 * Remove properties with keys that start with the string `pattern`. The default pattern is
 * "__" that means props with keys like "__propsA" would be removed from objects. The purpose
 * is to provide a decalrative mechanism for server only configuration, i.e. configuration
 * that is NOT put into from the client state.
 *
 * @param {any} object The source configuration object
 * @param {String} pattern The filter pattern (default "__", e.g. "__propA")
 * @returns {any} The source object with properties who's key start with `pattern` removed
 */
const filterPropsStartingWith = (object = {}, pattern = '__') => {
  return JSON.parse(JSON.stringify(object, createPropFilter(pattern)));
};

/**
 * Put relevant CLI config options into the state, e.g. api config.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setStateFromConfigOptions = (req, res) => {
  const {options} = res.app.locals;

  // Set api config -- i.e. configuration for external wapi servers
  const {endpointOrigins = {}, appConfig = {}} = options;

  setAdditionalState(res, {
    configRepository: {
      endpointOrigins: filterPropsStartingWith(endpointOrigins),
      appConfig: appConfig.configRepositoryState
    }
  });
};

/**
 * Initialize the WAPI on middleware chain.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setWapi = app => {
  const {endpoints} = app.locals;

  app.locals.wapi = createWapi({endpoints});
};

/**
 * Initialize the UI on middleware chain.
 *
 * @param {express.Request} req
 * @param {express.Response} res
 */
const setUi = async app => {
  const {components} = app.locals;

  // Copy frozen object so it can be modified (by preloadComponents)
  app.locals.components = {...components};

  // Preserve original components before they are preloaded
  app.locals.originalComponents = {...components};

  // Must preload all async (`lazy`) Components (i.e. make them sync) as SSR doesn't support async Components
  await preloadComponents(app.locals.components);
};

/**
 * Create react-app (express) middleware, which is responsible for serving the application.
 *
 * @param {express.application} app The express application instance
 * @returns {[express.Middleware]}
 */
export default async app => {
  setWapi(app);

  await setUi(app);

  return {
    async serveApp(req, res, next) {
      try {
        setStateFromConfigOptions(req, res);

        setBrowserGlobals(req, res);

        setContextFromRequest(req, res);

        await setStore(req, res);

        await setPage(req, res);

        if (!handleRedirect(req, res)) {
          if (pageHasLayout(req, res)) {
            setContextFromPage(req, res);

            await setState(req, res);

            // TODO - temporary solution to facilitate API tests
            if (app.isApiTest) {
              return next();
            }

            await sendRenderedPage(req, res);
          } else {
            sendRawPage(req, res);
          }
        }
      } catch (error) {
        next(error);
      }
    }
  };
};
