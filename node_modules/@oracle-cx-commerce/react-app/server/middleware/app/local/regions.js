/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import path from 'path';
import {ASSETS_ROOT, COMPONENT_ASSETS, SLOT_ASSETS, readJson} from './assets';
import {lookupComponents} from './components';

const TYPES = {
  header: 100,
  main: 101,
  footer: 102
};

const STRUCTURES = {
  flat: 100,
  stack: 101,
  slot: 102
};

/**
 * Infer region types based on their position within the layout.
 *
 * @param {Object} row
 * @param {Number} length
 * @returns {Number} a type identifying what kind of region it is
 */
const getType = region => {
  return TYPES[region.type] || 101;
};

/**
 * Return the structure of this region
 *
 * @param {Object} region
 * @returns {Number} identifying the structure of the region
 */
const getStructure = region => {
  return STRUCTURES[region.structure] || 100;
};

/**
 * Return the width of this region
 *
 * @param {Object} region
 * @returns {Number} width of the region
 */
const getWidth = region => {
  return region.width || 12;
};

/**
 * Return the mobile width of this region
 *
 * @param {Object} region
 * @returns {Number} mobile width of the region
 */
const getMobileWidth = region => {
  return region.mobileWidth || 12;
};

/**
 * Return the components in this region (if any)
 *
 * @param {Object} region
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 * @returns {Map} components in this region
 */
const getComponents = (region, appDir, locale, meta) => {
  return region.components ? lookupComponents(region.components, appDir, locale, meta, transformRegion) : [];
};

/**
 * Return the Display Name of this region
 *
 * @param {Object} region
 * @returns {String} Display Name of this region
 */
const getDisplayName = region => {
  return region.displayName || 'Region Display Name';
};

/**
 * Return the Name of this region
 *
 * @param {Object} region
 * @returns {String} Name of this region
 */
const getName = region => {
  return region.name || 'Region Name';
};

/**
 * Return the Slot for this region (if any)
 *
 * @param {Object} region
 * @returns {String} Name of this region
 */
const getSlot = region => {
  return region.slot || '';
};

/**
 * Return the CSS class for this region (if any)
 *
 * @param {Object} region
 * @returns {String} CSS class for this region
 */
const getCSSClass = region => {
  return region.cssClass || '';
};

/**
 * function transforms a local region format (simple json format),
 * into the page model returned from the storefront endpoint.
 *
 * @param {String} pageType the current page type e.g. 'category'
 * @param {Object} region the current region
 * @param {Number} regionIndex the index of the current region
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 *
 * @returns the region information in the format returned from the storefront endpoint
 */
const transformBasicRegion = (pageType, region, regionIndex, appDir, locale, meta) => {
  return {
    metadata: {},
    repositoryId: `${pageType}Region1000${regionIndex}`,
    width: getWidth(region),
    type: getType(region),
    structure: getStructure(region),
    components: getComponents(region, appDir, locale, meta),
    displayName: getDisplayName(region),
    name: getName(region),
    mobileWidth: getMobileWidth(region),
    regions: [],
    cssClass: getCSSClass(region),
    slot: getSlot(region)
  };
};

/**
 * function transforms a local stack region format (simple json format),
 * into the page model returned from the storefront endpoint.
 *
 * @param {Object} stack the current stack
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 *
 * @returns the region information in the format returned from the storefront endpoint.
 */
const transformStackRegions = (stack, appDir, locale, meta) => {
  const stackComponent = stack.components[0] ? stack.components[0].instanceId : 'stack';
  const rootLocation = path.join(appDir, ASSETS_ROOT, COMPONENT_ASSETS, stackComponent);
  const structureLocation = path.join(rootLocation, 'structure.json');

  const structureJson = readJson(structureLocation);

  if (structureJson) {
    return structureJson.regions.map((region, regionIndex) => {
      return transformRegion(stackComponent, region, regionIndex, appDir, locale, meta);
    });
  }
};

/**
 * function transforms a local stack format (simple json format),
 * into the page model returned from the storefront endpoint.
 *
 * @param {Object} transformedRegion Formatted current region (i.e. the stack)
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 *
 * @returns the region information in the format returned from the storefront endpoint.
 */
const transformStack = (transformedRegion, appDir, locale, meta) => {
  transformedRegion.regions = transformStackRegions(transformedRegion, appDir, locale, meta);

  transformedRegion.name = transformedRegion.components[0].instanceId;
  transformedRegion.structure = STRUCTURES['stack'];
  transformedRegion.stackType = transformedRegion.components[0].component.name;

  // TODO retrieve translations
  transformedRegion.previousButton = 'Previous';
  transformedRegion.nextButton = 'Next';

  return transformedRegion;
};

/**
 * function selects a local slot variant format and transforms it
 * (from simple json format), into the page model returned from
 * the storefront endpoint.
 *
 * @param {Object} slot the current slot
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 *
 * @returns the region information in the format returned from the storefront endpoint.
 */
const selectSlotVariant = (slotRegion, appDir, locale, meta) => {
  const slotInstance = slotRegion.slot;
  const rootLocation = path.join(appDir, ASSETS_ROOT, SLOT_ASSETS, slotInstance);
  const structureLocation = path.join(rootLocation, 'structure.json');

  const structureJson = readJson(structureLocation);

  if (structureJson) {
    // For now just return the first variant, i.e. the default or control.
    return transformRegion(slotInstance, structureJson.regions[0], 0, appDir, locale, meta);
  }
};

/**
 * function transforms a local slot format (simple json format),
 * into the page model returned from the storefront endpoint.
 *
 * @param {Object} transformedRegion Formatted current region (i.e. the slot)
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 *
 * @returns the region information in the format returned from the storefront endpoint.
 */
const transformSlot = (transformedRegion, appDir, locale, meta) => {
  const variant = selectSlotVariant(transformedRegion, appDir, locale, meta);

  // make sure variant follows the width & type of the slot
  variant.width = transformedRegion.width;
  variant.type = transformedRegion.type;

  // nb: returning variant rather than transformedRegion
  // to replicate slot resolver functionality
  return variant;
};

/**
 * function transforms a local region format (simple json format),
 * into the page model returned from the storefront endpoint.
 *
 * Can be called recursively for nested structured regions.
 *
 * @param {String} pageType the current page type e.g. 'category'
 * @param {Object} region the current region
 * @param {Number} regionIndex the index of the current region
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 *
 * @returns the region information in the format returned from the storefront endpoint.
 */
function transformRegion(pageType, region, regionIndex, appDir, locale, meta) {
  const transformedRegion = transformBasicRegion(pageType, region, regionIndex, appDir, locale, meta);

  if (transformedRegion.components && transformedRegion.components.length === 1) {
    const componentInst = transformedRegion.components[0];

    if (componentInst.component.type && componentInst.component.type === 'stack') {
      return transformStack(transformedRegion, appDir, locale, meta);
    }
  }

  if (transformedRegion.slot && transformedRegion.slot.length > 0) {
    return transformSlot(transformedRegion, appDir, locale, meta);
  }

  return transformedRegion;
}

/**
 * Public facing function which transforms a local region format (simple json format),
 * into the page model returned from the storefront endpoint.
 *
 * @param {String} pageType the current page type e.g. 'category'
 * @param {Object} region the current region
 * @param {Number} regionIndex the index of the current region
 * @param {String} appDir the application directory
 * @param {String} locale the locale for the current request
 * @param {Object} meta request meta data
 *
 * @returns the region information in the format returned from the storefront endpoint.
 */
export const lookupRegions = (pageType, region, regionIndex, appDir, locale, meta) => {
  return transformRegion(pageType, region, regionIndex, appDir, locale, meta);
};
