/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import path from 'path';
import {isEmptyObject} from '@oracle-cx-commerce/utils/generic';
import {ASSETS_ROOT, COMPONENT_ASSETS, readJson, readHtml} from './assets';

const lookupResources = (meta, componentName, locale, resourceOverrides) => {
  const {components = {}} = meta;
  const {resources = {}} = components[componentName] || {};
  const overrides = resourceOverrides || {};

  return {
    ...resources[locale],
    ...overrides[locale]
  };
};

const lookupConfiguration = (configJson, locale, rootLocation) => {
  if (!configJson || isEmptyObject(configJson)) {
    return {};
  }

  for (const configKey in configJson) {
    const configValue = configJson[configKey];

    if (typeof configValue == 'object') {
      for (const propertyKey in configValue) {
        const propertyValue = configValue[propertyKey];

        if (propertyKey === 'resourceFolder') {
          const resourceFolder = path.join(rootLocation, propertyValue, `${locale}.html`);
          const resourceContents = readHtml(resourceFolder);

          configJson[configKey] = resourceContents;
        }
      }
    }
  }

  return configJson;
};

export const lookupComponents = (components, appDir, locale, meta, regionHandler) => {
  return components.map((component, componentIndex) => {
    const rootLocation = path.join(appDir, ASSETS_ROOT, COMPONENT_ASSETS, component);

    const componentLocation = path.join(rootLocation, 'index.json');
    const configLocation = path.join(rootLocation, 'config.json');
    const layoutLocation = path.join(rootLocation, 'layout.json');
    const resourcesLocation = path.join(rootLocation, 'resources.json');
    const appJsonLocation = path.join(appDir, '.occ', 'app.json');

    const componentJson = readJson(componentLocation);

    if (componentJson) {
      const configJson = readJson(configLocation);
      const layoutJson = readJson(layoutLocation);
      const resources = readJson(resourcesLocation);
      const appJson = readJson(appJsonLocation);

      // Pre-configured containers specify their own component type but
      // for local rendering the component they are based on is required
      // therefore take superType value, if any, before type value.
      const componentType = componentJson.superType || componentJson.type;

      let componentTypeData = {};

      if (appJson && appJson.components && appJson.components[componentType]) {
        componentTypeData = appJson.components[componentType];
      }

      return {
        repositoryId: `ci1000${componentIndex}${component}`,
        componentId: componentType,
        instanceId: component,
        resources: lookupResources(meta, componentType, locale, resources),
        configuration: lookupConfiguration(configJson, locale, rootLocation),
        regions: layoutJson
          ? layoutJson.regions.map((region, regionIndex) => {
              return regionHandler(component, region, regionIndex, appDir, locale, meta);
            })
          : [],
        component: {
          name: componentType,
          type: componentTypeData['type'] || 'widget'
        }
      };
    }

    // if we've gotten here, there's no local override for this component, just return some default data pointing to the correct component name
    return {
      repositoryId: `ci1000${componentIndex}${component}`,
      componentId: component,
      instanceId: component,
      resources: lookupResources(meta, component, locale),
      configuration: {},
      regions: [],
      component: {
        name: component
      }
    };
  });
};
