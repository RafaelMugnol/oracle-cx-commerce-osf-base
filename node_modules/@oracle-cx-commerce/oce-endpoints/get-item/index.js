/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {populateError, getBodyAsJson} from '@oracle-cx-commerce/endpoints/utils';
import {
  getContentItemsList,
  getContentSettings,
  getContentWidgetItemIds
} from '@oracle-cx-commerce/commerce-utils/selector';
import {STARTING_CEC_TAG, ENDING_CEC_TAG} from '@oracle-cx-commerce/react-widgets/oce/utils';
import {createOceEndpoint} from '../factory';

export const processInput = (payload, state) => {
  const paramId = payload.id;
  const {paramRoute} = payload;
  const contentSetting = getContentSettings(state);

  // TODO product aware is actually query on listing endpoint and should be changed
  if (payload.productAware) {
    // oceGetItem endpoint requires {id} param
    // for product aware item this is replaced with the query to avoid
    // `{}` appearing in request url
    payload.query += `&expand=all&channelToken=${contentSetting.accessToken}`;

    return {
      params: [payload.query]
    };
  }

  return {
    params: [paramId, paramRoute],
    query: {
      q: payload.query,
      expand: 'all',
      channelToken: contentSetting.accessToken
    }
  };
};

// if there is fields.native.links[0] and it is an image asset
// then return the href of the image
const getImageHref = function (fields, payload) {
  // if retrieved image is false then the product aware image
  if (payload.retrievedContent === true && payload.retrievedImage === false) {
    const firstLink = (((((fields || {}).productAwareImage || {}).fields || {}).native || {}).links || [])[0];

    return firstLink.href;
  }

  const firstLink = (((fields || {}).native || {}).links || [])[0];
  // check if there is an href and the mimeType starts with 'image'
  if (firstLink && firstLink.href && /^image/i.test(fields.mimeType || '')) {
    return firstLink.href;
  }
};

const processProductAwareImage = function (payload, json, state) {
  const {widgetId} = payload;
  const prevItems = getContentItemsList(state, {widgetId});
  const prevContentItem = prevItems[payload.contentItemId];
  const productImageFields = prevContentItem.fields[payload.fieldName];

  productImageFields['productAwareImage'] = json;

  return prevContentItem;
};

const processRichText = function (payload, response, state) {
  const {widgetId} = payload;
  const prevItems = getContentItemsList(state, {widgetId});
  const prevContentItem = prevItems[payload.contentItemId];
  let richTextField = prevContentItem.fields[payload.fieldName];

  const replaceWith = (((((response || {}).fields || {}).native || {}).links || [])[0] || {}).href;
  if (replaceWith) {
    // if we found an HREF to replace with
    const replaceStr = STARTING_CEC_TAG + payload.id + ENDING_CEC_TAG;
    // replace each occurrence of the current CEC tag
    while (richTextField.indexOf(replaceStr) > -1) {
      richTextField = richTextField.replace(replaceStr, replaceWith);
    }
  }

  const widgetName = `contentWidget-${payload.widgetId}`;

  return {
    contentRepository: {
      contentItems: {
        ...prevItems,
        [payload.contentItemId]: {
          ...prevContentItem,
          fields: {
            ...prevContentItem.fields,
            [payload.fieldName]: richTextField
          }
        }
      }
    },
    pageRepository: {
      pages: {
        [payload.pageId]: {
          [widgetName]: {
            ...getContentWidgetItemIds(state, {widgetId}),
            [payload.contentItemId]: 1
          }
        }
      }
    }
  };
};

export const processOutput = async (response, state, payload) => {
  if (response.ok) {
    let json = await getBodyAsJson(response);

    if (json && payload.productAware && !payload.id) {
      [json] = json.items;
    }

    if (json && json.fields) {
      // If fieldName is present then item is richTextAsset, no data manipulation needed
      if (payload.richText === true) {
        return processRichText(payload, json, state);
      }

      if (payload.retrievedImage === false) {
        json = processProductAwareImage(payload, json, state);
      }

      const contentFields = json.fields;
      const descriptionPreview = 80;
      let value;
      if (payload.retrievedContent !== false) {
        //if product aware content without image no data manipulation
        // TODO check if Preview for listing widget or full item call
        Object.keys(contentFields).map(function (key) {
          // if the key has more than 10 characters check if it's an item description
          if (key.length > 10 && key.substring(key.length - 11, key.length) === 'description') {
            let description = contentFields[key];
            if (description) {
              // Max characters for description preview
              if (description.length > descriptionPreview) {
                description = `${description.substring(0, descriptionPreview)}...`;
              }
              json.description = description;
            }
          } else {
            value = contentFields[key];
            if (value) {
              if (typeof value == 'object') {
                //do something else with this
                if (Array.isArray(value) && value.length > 0) {
                  // there are multiple assets for this content type field
                  // use the 1st image (if any)
                  for (const val of value) {
                    json.imageUrl = json.imageUrl || getImageHref(val.fields, payload);
                  }
                  // eslint-disable-next-line no-prototype-builtins
                } else if (payload.retrievedImage === false && value.productAwareImage) {
                  getImageHref(value, payload);
                } else if (value.type === 'DigitalAsset') {
                  json.imageUrl = getImageHref(value.fields, payload);
                }
              }
            }
          }

          return json;
        });
      }

      const {widgetId} = payload;
      const widgetName = `contentWidget-${payload.widgetId}`;

      return {
        contentRepository: {
          contentItems: {
            [json.id]: json
          }
        },
        pageRepository: {
          pages: {
            [payload.pageId]: {
              [widgetName]: {
                ...getContentWidgetItemIds(state, {widgetId}),
                [json.id]: 0
              }
            }
          }
        }
      };
    }
  }
  const json = await getBodyAsJson(response);

  return populateError(response, json);
};

export default createOceEndpoint('getItem', {
  processInput,
  processOutput
});
