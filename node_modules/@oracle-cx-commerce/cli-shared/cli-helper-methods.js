/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const fs = require('fs');
const path = require('path');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});

/* This function validates values in the options object. The validation is specific to options
 * used in the cli. Not all options are validated. To add more, just add to this function using
 * the same pattern.
 *
 * use verifyOptions to limit the validation to a specific set of options. For example, we use this to
 * limit validation to just the options supported by an action.
 *
 * If no verifyOptions are provided all the available option validation will occur
 *
 * @param  {Object} options Command-line options from Commander.
 * @param  {Array}  verifyOptions Limits the validation to just these options. Otherwise all validation is performed.
 */
function validateConfiguration(options, verifyOptions) {
  if (!options) {
    return true;
  }
  let valid = true;
  //make sure http port is an integer
  if (options.httpPort && (!verifyOptions || verifyOptions.includes('httpPort'))) {
    // eslint-disable-next-line radix
    const newval = Number(options.httpPort);
    if (!Number.isInteger(newval) || isNaN(newval)) {
      valid = false;
      console.error(___`Invalid configuration value for httpPort:  "${options.httpPort}".`);
    } else {
      //normalize to int value
      options.httpPort = newval;
    }
  }
  if (options.httpsPort && (!verifyOptions || verifyOptions.includes('httpsPort'))) {
    // eslint-disable-next-line radix
    const newval = Number(options.httpsPort);
    if (!Number.isInteger(newval) || isNaN(newval)) {
      valid = false;
      console.error(___`Invalid configuration value for httpsPort:  "${options.httpsPort}".`);
    } else {
      //normalize to int value
      options.httpsPort = newval;
    }
  }

  if (options.appServer && (!verifyOptions || verifyOptions.includes('appServer'))) {
    try {
      // eslint-disable-next-line no-unused-vars
      options.appServer = new URL(options.appServer).origin;
    } catch (reason) {
      valid = false;
      console.error(___`Invalid configuration value for appServer:  "${options.appServer}". ${reason}`);
    }
  }
  if (options.appServerAdmin && (!verifyOptions || verifyOptions.includes('appServerAdmin'))) {
    try {
      // eslint-disable-next-line no-unused-vars
      options.appServerAdmin = new URL(options.appServerAdmin).origin;
    } catch (reason) {
      valid = false;
      console.error(___`Invalid configuration value for appServerAdmin:  "${options.appServerAdmin}". ${reason}`);
    }
  }
  if (!verifyOptions || verifyOptions.includes('appName')) {
    if (!options.appName) {
      valid = false;
      console.error(___`Missing appName configuration:  "${options.appName}".`);
    }
    if (!validateAppName(options.appName)) {
      valid = false;
      console.error(___`Invalid configuration value for appName:  "${options.appName}".`);
    }
  }
  if (options.localDevAppName && (!verifyOptions || verifyOptions.includes('localDevAppName'))) {
    if (typeof options.localDevAppName === 'string' && !validateAppName(options.localDevAppName)) {
      valid = false;
      console.error(___`Invalid configuration value for localDevAppName:  "${options.localDevAppName}".`);
    }
  }
  if (
    (!verifyOptions || verifyOptions.includes('dsAssetMode')) &&
    options.dsAssetMode &&
    options.dsAssetMode.trim() !== 'remote' &&
    options.dsAssetMode.trim() !== 'local'
  ) {
    valid = false;
    console.error(___`Invalid configuration value for dsAssetMode:  "${options.dsAssetMode}".`);
  }

  return valid;
}

/**
 * Returns an object with all the options relevant to the executed command.
 *
 * Includes both global and command-specific options, but only those with a defined value.
 * This method filters out the private properties included in the Commander object.
 *
 * @param  {Object} cliOptions Command-line options from Commander.
 * @return {Object}         Object with all the relevant options.
 */
function getProgramConfiguration(cliOptions) {
  if (!cliOptions) {
    return {};
  }
  // Collapse global options into the command-level options. This is a Commander's peculiarity.
  let allOptions = cliOptions;

  //All the action's options available in th options object
  const actionOptions = cliOptions.options.map(option => {
    return option.long.substring(2);
  });

  //All the action's arguments available in th options object
  const argOptions = cliOptions._args.map(option => {
    return option.name;
  });

  if (cliOptions.parent || cliOptions.opts) {
    allOptions = Object.assign(
      {},
      cliOptions.parent ? cliOptions.parent.opts() : {},
      cliOptions.opts ? cliOptions.opts() : {}
    );
    // Save the action options provided (through the cli command line) on this run. i.e. the subset
    // of the options selected by the user.
    allOptions._occSelectedOptions = Object.keys(allOptions);
  }

  allOptions._occActionOptions = actionOptions;
  allOptions._occArgOptions = argOptions;
  allOptions._occActionName = cliOptions._name;

  return allOptions;
}

/**
 * Returns the location of the Rollup configuration file for an application.
 *
 * If the application includes a rollup.config.js file in its root directory,
 * that file is used. Otherwise, OSF's default configuration file is used.
 * An exception is thrown if the default configuration file is missing.
 *
 * @param  {string} appDir  The root directory of the application.
 * @return {string}         The path of the Rollup configuration file.
 */
function getRollupConfigurationLocation(appDir) {
  // Use the app's config file, if it exists.
  let rollupConfig = path.resolve(appDir, 'rollup.config.js');
  if (fs.existsSync(rollupConfig)) {
    return rollupConfig;
  }

  rollupConfig = require.resolve('@oracle-cx-commerce/rollup-config/defaults');
  if (fs.existsSync(rollupConfig)) {
    return rollupConfig;
  }

  throw new Error(___`Default Rollup configuration is missing`);
}

/**
 * Validates the application name.
 *
 * This method performs a series of checks:
 * - name has at least one alphanumeric character
 * - the characters composing the name string will not cause problems with the file system
 * - the name is not a WindowsÂ® reserved filename
 *
 * @param      {string}  name    The application name.
 * @return     {Boolean}  `true` if the argument passes the checks, `false` otherwise.
 */
function validateAppName(name) {
  const validCharacters = /^[-_ %\w.]+$/;
  const windowsNames = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i;
  // An alternative would be to use the 'filename-reserved-regex' package so filenames can include UNICODE characters.

  return (
    typeof name === 'string' &&
    Boolean(name.trim()) &&
    Boolean(name.match(validCharacters)) &&
    !name.match(windowsNames)
  );
}

/**
 * Will prompt to confirm if the publish option has been selected
 */
const promptConfirmPublish = options => {
  if (options.publishAll) {
    if (typeof options.publishAll === 'string' && options.publishAll.toUpperCase() === 'Y') {
      return Promise.resolve(true);
    }

    return new Promise(resolve => {
      const readline = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
      });
      readline.question(
        ___`Specifying --publishAll will cause all the changes currently in the publishing queue to be published. Please confirm the publishAll option by entering 'Y': `,
        confirm => {
          readline.close();
          confirm = confirm.toUpperCase();
          if (confirm === 'Y') {
            return resolve(true);
          }
          console.info(___`Publish will be skipped.`);

          return resolve(false);
        }
      );
    });
  }

  return Promise.resolve(false);
};

const promptConfirmOverwriteWorkspaceFiles = options => {
  if (options.confirm) {
    return Promise.resolve(true);
  }

  return new Promise(resolve => {
    const readline = require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    });
    readline.question(
      ___`This action will overwrite files in the local workspace and may cause local changes to be lost. Enter 'Y' to continue with this operation: `,
      confirm => {
        readline.close();
        confirm = confirm.toUpperCase();
        if (confirm === 'Y') {
          return resolve(true);
        }
        console.info(___`Overwrite cancelled`);

        return resolve(false);
      }
    );
  });
};

/**
 * If options contains an -appKey key, the user is prompted for an appKey
 *
 * The value provided is returned and also replaced in the given options.
 */
async function promptAppKey(options) {
  if (options.appKey) {
    if (typeof options.appKey === 'string') {
      console.log(___`The app key provide on the command line ignored.`);
    }
    const readline = require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    });

    return new Promise(resolve => {
      readline.question(___`Please provide an appKey: `, appKey => {
        readline.close();
        options.appKey = appKey;
        resolve(appKey);
      });
    });
  }
}

/**
 * Will prompt to confirm if the publish option has been selected
 */
const promptConfirmReset = options => {
  if (options.reset) {
    if (typeof options.reset === 'string' && options.reset.toUpperCase() === 'Y') {
      return Promise.resolve(true);
    }

    return new Promise(resolve => {
      const readline = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
      });
      readline.question(
        ___`Specifying --reset will delete all the assets for the application ${options.appName} from Design Studio and replace them with the assets defined in this workspace. Please confirm the reset option by entering 'Y': `,
        confirm => {
          readline.close();
          confirm = confirm.toUpperCase();
          if (confirm === 'Y') {
            return resolve(true);
          }
          console.log(___`Reset will be skipped.`);

          return resolve(false);
        }
      );
    });
  }

  return Promise.resolve(false);
};

module.exports = {
  getProgramConfiguration,
  getRollupConfigurationLocation,
  validateAppName,
  promptConfirmPublish,
  promptConfirmOverwriteWorkspaceFiles,
  promptAppKey,
  promptConfirmReset,
  validateConfiguration
};
