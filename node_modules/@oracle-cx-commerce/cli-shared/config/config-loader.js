/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const {___} = require('@oracle-cx-commerce/tools-i18n').i18n({directory: path.join(__dirname, './locales')});
const {getApplicationDir} = require('@oracle-cx-commerce/tools-util');
const defaults = require('./defaults');
const env = require('./env');

const removeProperty =
  prop =>
  ({[prop]: _, ...rest}) =>
    rest;

const assert = (value, message) => {
  if (!value) {
    console.log(message);
    process.exit(1);
  }
};

/**
 * If the given error is not a module not found error,
 * displays the contents to the console to aid in debugging
 * config file problems.
 * @param {Object} error - The thrown error to be handled
 */
const handleLoadError = error => {
  // no config - that's ok - this file is not required
  if (error.code !== 'MODULE_NOT_FOUND') {
    // Help debug mistakes in the config file
    console.log(___`Error while loading OCC config. Details follow:`);
    throw error;
  }
};

/**
 * Loads the configuration at the given directory. It will attempt to load two
 * config files at that location: /config/index.json and /.occ/config.json
 * Returns an object with the merged configuration.
 *
 * @param {String} dir the path to the directory containing the config
 */
const loadConfig = dir => {
  if (dir == null) {
    return {};
  }

  let options = {};
  let mergedServerConfig = {};
  // load the first file. if not there, continue to load the second
  // file.
  try {
    // load up the /config/index.json
    delete require.cache[require.resolve(`${dir}/config`)];
    options = require(path.resolve(`${dir}/config`));
  } catch (error) {
    handleLoadError(error);
  }

  mergedServerConfig = options.serverConfig || {};
  try {
    // load up the workspace specific config (/.occ/config)
    delete require.cache[require.resolve(`${dir}/.occ/config`)];
    const occConfig = require(path.resolve(`${dir}/.occ/config`));
    Object.assign(options, occConfig);

    const occServerConfig = occConfig.serverConfig || {};

    // merge the serverEnv config for each environment key
    // For each key already in mergedServerConfig, overlay values (i.e merge) from
    // the occ config layer config
    Object.keys(mergedServerConfig).forEach(key => {
      if (key in occServerConfig) {
        Object.assign(mergedServerConfig[key], occServerConfig[key]);
      }
    });

    // for any serverEnv key in the occ config layer but not defined at all in the
    // mergeServerConfig already, copy it wholesale to the mergeServerConfig.
    Object.keys(occServerConfig).forEach(key => {
      if (!(key in mergedServerConfig)) {
        mergedServerConfig[key] = occServerConfig[key];
      }
    });
    // Set the final server config object from the mergedServerConfig
    if (Object.entries(mergedServerConfig).length > 0) {
      Object.assign(options, {serverConfig: mergedServerConfig});
    }
  } catch (error) {
    handleLoadError(error);
  }

  // return whatever we have so far.
  return options;
};

const loadAppConfigFile = filePath => {
  if (filePath == null) {
    return {};
  }
  let options = {};
  try {
    // flush the cache to get a fresh
    // copy.
    delete require.cache[require.resolve(filePath)];
    options = require(path.resolve(filePath));
  } catch (error) {
    handleLoadError(error);
  }

  // return whatever we have so far.
  return options;
};

/**
 * Returns an object that contains the OCC environment configuration.
 *
 * @param {String} config the current set of default and global config settings
 * @param {String} serverEnv the serverConfig entry that contains the OCC server config
 * file.
 */
const getServerConfig = (config, serverEnv) => {
  if (typeof serverEnv === 'undefined' || serverEnv == null) {
    return {};
  }

  return {...(config.serverConfig ? config.serverConfig[serverEnv] : {})};
};

const isServerConfig = (config, serverEnv) => {
  if (
    typeof serverEnv === 'undefined' ||
    serverEnv == null ||
    !config.serverConfig ||
    Object.entries(config.serverConfig).length === 0
  ) {
    return false;
  }

  if (config.serverConfig[serverEnv]) {
    return true;
  }

  return false;
};

//does a shallow copy of newProps into props
const mergeAppProps = (props, newProps) => {
  Object.keys(newProps).forEach(key => {
    //merge app folder config into default config up to 1 level.
    if (typeof newProps[key] === 'object') {
      if (!props[key]) {
        props[key] = {};
      }
      Object.assign(props[key], newProps[key]);
    } else {
      props[key] = newProps[key];
    }
  });
};

/**
 * Checks top-level properties 'configRepositoryState', 'endpointOrigins' and 'liveConfigurations'
 * are capitalized correctly.
 * @param {*} appConfig
 */
function verifyAppConfigPropertiesName(appConfig) {
  const topLevelPropertiesKeys = Object.keys(appConfig);
  const lowerCaseTopLevelPropertiesKeys = topLevelPropertiesKeys.map(key => key.toLocaleLowerCase());

  const keysToChecks = ['configRepositoryState', 'endpointOrigins', 'liveConfigurations'];
  keysToChecks.forEach(key => {
    if (!topLevelPropertiesKeys.includes(key)) {
      // either the key does not exists in the appConfig or is not capitalized correctly
      if (lowerCaseTopLevelPropertiesKeys.includes(key.toLocaleLowerCase())) {
        console.warn(`${key} is not capitalized correctly in app-config (correct capitalization: ${key}).`);
      }
    }
  });
}

/**
 * Determine which appContext to promote to the top level of the app-config
 * @param {*} appConfig   object containing the app configurations
 * @param {*} appContext  app context to use
 */
function resolveAppContext(appConfig, selectedAppContext) {
  // Only print warn messages if user provided appContext or env variable ENV_TYPE is present
  const notifyOnError = selectedAppContext !== defaults.appContext;
  // appContextConfigurations object is missing from appConfig
  if (!appConfig.appContextConfigurations) {
    if (notifyOnError) {
      console.warn(
        ___`Error occurred when trying to resolve appContext:\nNo appContextConfigurations object found in app-config.`
      );
    }

    return;
  }

  if (typeof appConfig.appContextConfigurations !== 'object') {
    console.warn(
      ___`Error occurred when trying to resolve appContext:\nUnable to load appContextConfigurations from app config, appContextConfigurations must be an object (appContextConfigurations is of type: ${typeof appConfig.appContextConfigurations}).`
    );

    return;
  }

  // appContextConfigurations is present and is a valid object, extracting appContextConfigurations from appConfig
  const appContextConfigurations = {...appConfig.appContextConfigurations};

  // Check if the selectedAppContext is present in the appContextConfigurations object
  if (!appContextConfigurations[selectedAppContext]) {
    if (notifyOnError) {
      console.warn(
        ___`Error occurred when trying to resolve appContext:\nCannot resolve selected appContext "${selectedAppContext}" from the app config.`
      );
    }

    return;
  }

  if (typeof appContextConfigurations[selectedAppContext] !== 'object') {
    console.warn(
      ___`Error occurred when trying to resolve appContext:\nUnable to load selected appContext "${selectedAppContext}" from app config, "${selectedAppContext}" must be an object (selected appContext "${selectedAppContext}" is of type: ${typeof appContextConfigurations[
        selectedAppContext
      ]}).`
    );

    return;
  }

  return {...appContextConfigurations[selectedAppContext]};
}

/**
 * Resolves appConfig based on appContext and live
 * @param {Object}  appConfig         object containing the app configurations
 * @param {String}  selectedAppContext        current app context that is being used.
 * @param {Boolean} isLive            boolean to indicate if to check preview or live
 */
function resolveAppConfigs(appConfig, selectedAppContext, isLive) {
  // A utility function to notify on misspelled top-level properties
  verifyAppConfigPropertiesName(appConfig);

  const resolvedAppContext = resolveAppContext(appConfig, selectedAppContext);
  let resolvedAppContextLiveConfigurations; // initialize empty variable to hold appContext's liveConfigurations

  // if appContextConfigurations exists and the selected appContext is present in the appConfig promote the selected appContext to the top level of the appConfig
  if (resolvedAppContext) {
    if (resolvedAppContext.liveConfigurations) {
      resolvedAppContextLiveConfigurations = resolvedAppContext.liveConfigurations; // extract the selected appContext liveConfigurations
      delete resolvedAppContext.liveConfigurations; // remove the liveConfigurations reference from the resolvedAppContext
    }

    mergeAppProps(appConfig, resolvedAppContext); // Overlay all other appContext's properties with appConfig's properties
    console.log(
      ___`Successfully loaded appContextConfigurations "${selectedAppContext}" configurations onto app-config.`
    );
  }

  // If running in live, promote *live* object top top level arguments
  if (isLive && appConfig.liveConfigurations) {
    // if the resolvedAppContext contained liveConfigurations, merge those configurations with the other liveConfigurations
    if (resolvedAppContextLiveConfigurations) {
      // Check if liveConfigurations of resolvedAppContext is a valid object
      if (typeof resolvedAppContextLiveConfigurations !== 'object') {
        console.warn(
          ___`Error occurred when trying to resolve app-config:\nUnable to merge "liveConfigurations" of appContextConfigurations "${selectedAppContext}".  "liveConfigurations" must be an object. (liveConfigurations of appContextConfigurations "${selectedAppContext}" is of type: ${typeof resolvedAppContextLiveConfigurations}).`
        );
      } else {
        mergeAppProps(appConfig.liveConfigurations, resolvedAppContextLiveConfigurations);
      }
    }
    if (typeof appConfig.liveConfigurations !== 'object') {
      console.warn(
        ___`Unable to load live configurations from app config, "liveConfigurations" must be an object. (live configurations of app-config is of type: ${typeof appConfig.liveConfigurations}).`
      );
    } else {
      const liveAppConfigurations = {...appConfig.liveConfigurations};
      console.log(___`Successfully loaded "liveConfigurations" onto app-config.`);
      mergeAppProps(appConfig, liveAppConfigurations);
    }
  }

  // Remove appContext configurations object from final result of app config
  delete appConfig.appContextConfigurations;
  // Remove live configurations object from final result of app config
  delete appConfig.liveConfigurations;
}

/**
 * Returns app configuration object loaded from the following two sources.
 * packages/apps/[appname]/config/app-config/index.js
 * packages/apps/[appname]/.occ/config.js
 *
 * @param {String} appName.     Optional. current app directory that is being used.
 * @param {String} selectedAppContext.  current app context that is being used.
 * @param {Boolean} isLive.     boolean to indicate if to check preview or live
 * @param {String} occActionName.  name of the occ command invoked.
 *
 * @returns {Object} an object containing the app configurations.
 */
const loadAppConfig = (appName, selectedAppContext, isLive, occActionName) => {
  let appConfig = {};
  const defaultAppConfigPath = '@oracle-cx-commerce/osf-config/app-config';
  try {
    appConfig = {...require(defaultAppConfigPath)};
  } catch (error) {
    handleLoadError(error);
  }

  if (!appName) {
    return appConfig;
  }
  try {
    const appPath = path.resolve(getApplicationDir(appName));
    const customAppConfig = loadAppConfigFile(path.join(appPath, '/config/app-config'));
    mergeAppProps(appConfig, customAppConfig);
  } catch (error) {
    handleLoadError(error);
  }
  //include the .occ/config.js too, if available
  mergeAppProps(appConfig, loadConfig(path.resolve(getApplicationDir(appName))));

  // Only resolve the appConfig and selected appContext when running 'occ serve' command
  if (occActionName === 'serve') {
    resolveAppConfigs(appConfig, selectedAppContext, isLive);
  }

  return appConfig;
};

/**
 * Returns a workspace configuration object loaded from the defaults, the workspace config
 * files and the environment var settings.
 *
 * @param {Object} additionalConfig. Optional. Identifies additional config that will
 * be included in the return config object. Values here can be new or overrides for
 * existing config values.
 *
 * @returns {Object} an object containing the current workspace configuration including
 * the additionalConfig.
 */
const loadWorkspaceConfig = (appName, additionalConfig = {}) => {
  // load the config from defaults and config files.
  const config = {
    ...defaults,
    ...loadConfig(process.cwd())
  };

  const userProvidedServerEnv = additionalConfig.serverEnv || env.serverEnv;
  const selectedAppContext = additionalConfig.appContext || env.appContext || config.appContext;
  let isLive;
  if (typeof additionalConfig.live !== 'undefined') {
    isLive = additionalConfig.live;
  } else if (typeof env.live !== 'undefined') {
    isLive = env.live;
  } else {
    isLive = config.live;
  }
  const occActionName = additionalConfig._occActionName;

  //when asking for a specific serverEnv, make sure it exists
  if (userProvidedServerEnv && !isServerConfig(config, userProvidedServerEnv)) {
    throw new Error(
      ___`Server configuration does not exist for environment ${userProvidedServerEnv}. Check configuration for valid serverEnv setting.`
    );
  }
  // determine which serverConfig entry contains the OCC server configuration
  // to be loaded.
  const serverEnv = userProvidedServerEnv || config.serverEnv;
  // set the resolved values or appName and appDir.
  appName = appName || env.appName || config.appName;
  // appConfig will be merged with the rest of the config, configRepositoryState will only
  // be available under config.appConfig.configRepositoryState
  const appConfig = loadAppConfig(appName, selectedAppContext, isLive, occActionName);
  Object.assign(
    config,
    getServerConfig(config, serverEnv),
    removeProperty('configRepositoryState')(appConfig),
    {appConfig},
    env,
    // if 'serverEnv' name was expressed as additional config or environment var
    // (e.g. --serverEnv on command line),
    // those values from the config file (e.g. appServer, appKey, etc) should override those values
    // set by environment vars. (e.g OCC_APP_SERVER, OCC_APP_KEY)
    getServerConfig(config, userProvidedServerEnv),
    //lastly the command line values
    //e.g. if --appServer specified on command line, it should take precedence.
    additionalConfig
  );
  const appDir = getApplicationDir(appName);
  Object.assign(config, {appName}, {appDir});

  return config;
};

module.exports = {
  assert,
  mergeAppProps,
  loadConfig,
  loadAppConfig,
  getServerConfig,
  loadWorkspaceConfig,
  resolveAppConfigs,
  resolveAppContext
};
