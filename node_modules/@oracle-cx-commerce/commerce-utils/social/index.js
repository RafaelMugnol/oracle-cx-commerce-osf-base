/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {getCurrentProduct, getPage, getSite, getProductionFacebook} from '@oracle-cx-commerce/commerce-utils/selector';
import {getBaseURL} from '@oracle-cx-commerce/utils/generic';

//constants
const HTTPS_PROTOCOL = 'https:';
const STOCK_STATUS_OG = {
  IN_STOCK: 'instock',
  OUT_OF_STOCK: 'oos',
  PREORDERABLE: 'preorderable',
  BACKORDERABLE: 'backorderable'
};

const OG = {
  TYPE: 'og:type',
  TITLE: 'og:title',
  DESCRIPTION: 'og:description',
  URL: 'og:url',
  IMAGE: 'og:image',
  BRAND: 'og:brand',
  AVAILABILITY: 'og:availability',
  FB_APP_ID: 'fb_app_id'
};

const TWITTER = {
  CARD: 'twitter:card',
  TITLE: 'twitter:title',
  DESCRIPTION: 'twitter:description',
  IMAGE: 'twitter:image',
  SITE: 'twitter:site',
  URL: 'twitter:url'
};

let previousPath = null;
let previousTags = null;

/**
 * Adds a new  meta tag to the document fragment
 */
const addMetaTag = function ({document, attr, key, content, fragment}) {
  const meta = document.createElement('meta');
  meta.setAttribute(attr, key);
  meta.setAttribute('content', content);
  fragment.append(meta);
};

/**
 * Updates an existing meta tag
 */
const updateMetaTag = function ({document, attr, key, content}) {
  const element = document.querySelector(`meta[${attr}="${key}"]`);
  if (element != null && element.getAttribute('content') !== content) {
    element.setAttribute('content', content);
  }
};

/**
 * Removes a meta tag
 */
const removeMetaTag = function ({document, attr, key}) {
  const element = document.querySelector(`meta[${attr}="${key}"]`);
  element && element.remove();
};

/**
 * Adds meta tags to DOM
 */
const addMetaTags = (document, tags) => {
  if (document && tags && tags.length > 0) {
    // Creating a fragment and updating DOM at once
    const fragment = document.createDocumentFragment();
    for (const tag of tags) {
      const {attr, key, content} = tag;
      addMetaTag({document, attr, key, content, fragment});
    }
    document.querySelector('head') && document.querySelector('head').append(fragment);
  }
};

/**
 * Adds current social tags to DOM
 */
const updateMetaTags = (document, tags) => {
  if (document && tags && tags.length > 0) {
    for (const tag of tags) {
      const {attr, key, content} = tag;
      updateMetaTag({document, attr, key, content});
    }
  }
};

/**
 * Removes previous social tags from DOM
 */
const removeMetaTags = (document, tags) => {
  if (document && tags && tags.length > 0) {
    for (const tag of tags) {
      const {attr, key} = tag;
      removeMetaTag({document, attr, key});
    }
  }
};

/**
 * Returns the social tags
 * @param  {Object} window
 * @param  {Object} state state
 * @return {String} social tags object
 */
export const getProductSocialTags = ({req, window, state}) => {
  const {pageType = ''} = getPage(state);
  const baseUrlWithoutProtocol = getBaseURL({req, window, withoutProtocol: true});
  const protocol = typeof window !== 'undefined' ? window.location.protocol : HTTPS_PROTOCOL;
  const baseUrl = baseUrlWithoutProtocol ? protocol + baseUrlWithoutProtocol : '';
  const productSocialTags = [];

  if (pageType === 'product') {
    const {displayName = '', description = '', primarySmallImageURL, brand = ''} = getCurrentProduct(state);
    const {path = ''} = getPage(state);
    const {applicationId: facebookAppId = ''} = getProductionFacebook(state);
    const {siteSettings: {productSocialSettings: {twitterHandle = ''} = {}} = {}} = getSite(state);

    // add Facebook tags
    productSocialTags.push({attr: 'property', key: OG.TYPE, content: pageType});
    productSocialTags.push({attr: 'property', key: OG.TITLE, content: displayName});
    productSocialTags.push({attr: 'property', key: OG.DESCRIPTION, content: description});
    productSocialTags.push({attr: 'property', key: OG.URL, content: `${baseUrl}/${path}`});
    productSocialTags.push({attr: 'property', key: OG.IMAGE, content: baseUrl + primarySmallImageURL});
    productSocialTags.push({attr: 'property', key: OG.BRAND, content: brand});
    productSocialTags.push({attr: 'property', key: OG.AVAILABILITY, content: STOCK_STATUS_OG.IN_STOCK});
    productSocialTags.push({attr: 'property', key: OG.FB_APP_ID, content: facebookAppId});

    // add twitter tags
    productSocialTags.push({attr: 'name', key: TWITTER.CARD, content: pageType});
    productSocialTags.push({attr: 'name', key: TWITTER.TITLE, content: displayName});
    productSocialTags.push({attr: 'name', key: TWITTER.DESCRIPTION, content: description});
    productSocialTags.push({attr: 'name', key: TWITTER.IMAGE, content: baseUrl + primarySmallImageURL});
    productSocialTags.push({attr: 'name', key: TWITTER.SITE, content: twitterHandle});
    productSocialTags.push({attr: 'name', key: TWITTER.URL, content: `${baseUrl}/${path}`});
  }

  return productSocialTags;
};

/**
 * Returns the social tags
 * @param  {Object} window
 * @param  {Object} state state
 * @return {String} social tags object
 */
export const getSocialTags = ({req, window, state}) => {
  const {metaTags = [], keywords, noindex} = getPage(state);
  const socialTags = [];

  // add page metaTags
  metaTags.forEach(metaTag => {
    if (metaTag.name) {
      socialTags.push({attr: 'name', key: metaTag.name, content: metaTag.content});
    } else {
      socialTags.push({attr: 'property', key: metaTag.property, content: metaTag.content});
    }
  });

  // Add robots meta tag if no index is true
  if (noindex) {
    socialTags.push({attr: 'name', key: 'robots', content: 'noindex'});
  }

  // add Page keywords
  if (keywords) {
    socialTags.push({attr: 'name', key: 'keywords', content: keywords});
  }

  return socialTags.concat(getProductSocialTags({req, window, state}));
};

/**
 * Builds social tags during server side rendering
 * @param  {Object} req request
 * @param  {Object} state state
 * @return {String} social tags string
 */
export const buildSocialTagsForServer = ({req, state}) => {
  const socialTags = getSocialTags({req, state});
  const socialTagsForServer = [];

  for (const {attr, key, content} of socialTags) {
    socialTagsForServer.push(`<meta ${attr}="${key}" content="${content}" />`);
  }

  return socialTagsForServer.join('');
};

/**
 * Builds social tags when requested from client
 * @param  {Object} req request
 * @param  {Object} state state
 * @return {String} social tags string
 */
export const buildSocialTagsForClient = (window, state) => {
  if (window) {
    const {path: currentPath = ''} = getPage(state);
    const {document} = window;
    const currentTags = getSocialTags({state, window});
    // not firstTime rendering
    if (previousPath && previousPath !== currentPath) {
      removeMetaTags(document, previousTags);
      // add new social tags
      addMetaTags(document, currentTags);
    }
    previousPath = currentPath;
    previousTags = currentTags;
  }
};

/**
 * Updates product social tags
 * @param  {Object} window
 * @param  {Object} state state
 */
export const updateProductSocialTagsForClient = (window, state) => {
  if (window) {
    const {document} = window;
    const productSocialTags = getProductSocialTags({state, window});
    updateMetaTags(document, productSocialTags);
  }
};
