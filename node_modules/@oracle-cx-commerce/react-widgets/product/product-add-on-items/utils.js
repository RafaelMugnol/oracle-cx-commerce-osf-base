/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */

import {getProduct} from '@oracle-cx-commerce/commerce-utils/selector';
import {getData} from '@oracle-cx-commerce/react-widgets/product-listing/product-result-image-quick-view/components/quick-view-button/utils';

/**
 * updates the Add-On items selection for a base product.
 * @param {Object} event - the event object which contains currently selected add-on item product id.
 * @param {Array} childItems - Array of Add-On items associated with the current base product.
 * @param {Object} addOnItemsWithProductDetails - The object which contains product details of each add-on item.
 * @param {Method} setSelections - Setter method to update the 'selections' Object
 */
export const updateAddOnItemSelection = ({event, childItems, addOnItemsWithProductDetails, setSelections}) => {
  //Update Add-On Product selection.
  let selectedAddOns = childItems;
  const addOnProductId = event.target.name;
  if (event.target.checked) {
    // If Add-On is selected, then add Add-On product to selectedAddOnProducts
    // If Add-On product has only one Sku associated with it, then add the Sku Id directly else add the selected Sku Id
    // Add the Sku Id Directly along with Product Id.
    const childItem = {
      addOnItem: true,
      quantity: 1,
      productId: addOnProductId,
      catRefId:
        addOnItemsWithProductDetails[addOnProductId].childSKUs.length === 1
          ? addOnItemsWithProductDetails[addOnProductId].childSKUs[0]
          : ''
    };
    selectedAddOns.push(childItem);
  } else {
    // If Add-On is not selected, then remove the Add-On product from selectedAddOnProducts
    selectedAddOns = selectedAddOns.filter(selectedAddOn => selectedAddOn.productId !== addOnProductId);
  }

  setSelections(prevState => {
    return {
      ...prevState,
      childItems: [...selectedAddOns]
    };
  });
};

/**
 * Fetches the product details of each Add-On Item associated with the current base product.
 * @param {Array} addOnProducts - Array of Add-On items associated with the current base product.
 * @param {Object} setAddOnItemsWithProductDetails - Setter method to set the object which contains product details of each add-on item.
 * @param {Method} getState - Getter method to access the global state.
 */
export const fetchAddOnItemDetails = ({addOnProducts, setAddOnItemsWithProductDetails, action, getState, onError}) => {
  const addOnItemsWithProductDetails = {};
  for (const addOnProduct of addOnProducts) {
    const productId = addOnProduct.addOnOptions[0].product.repositoryId;
    const addOnProductDetails = getProduct(getState(), {productId});
    if (addOnProductDetails && Object.keys(addOnProductDetails).length === 0) {
      getData(action, productId, response => {
        const {products} = response.getProductResponse.delta.catalogRepository;
        addOnItemsWithProductDetails[productId] = products[productId];
        if (Object.keys(addOnItemsWithProductDetails).length === addOnProducts.length) {
          setAddOnItemsWithProductDetails(prevState => {
            return {
              ...prevState,
              ...addOnItemsWithProductDetails
            };
          });
        }
        const productType = addOnItemsWithProductDetails[productId].type;
        if (productType) {
          action('getProductType', {typeId: productType}).then(response => {
            action('notifyClearAll');
            if (response.ok === false) {
              onError(response);
            }
          });
        }
      });
    }
  }
};

/**
 * Initializes the product details of each Add-On Item from global state.
 * @param {Array} addOnProducts - Array of Add-On items associated with the current base product.
 * @param {Object} setAddOnItemsWithProductDetails - Setter method to set the object which contains product details of each add-on item.
 * @param {Method} getState - Getter method to access the global state.
 */
export const initializeAddOnItemDetails = ({addOnProducts, setAddOnItemsWithProductDetails, getState}) => {
  const addOnItemsWithProductDetails = {};
  let emptyProductFound = false;
  for (const addOnProduct of addOnProducts) {
    const productId = addOnProduct.addOnOptions[0].product.repositoryId;
    const addOnProductDetails = getProduct(getState(), {productId});
    if (Object.keys(addOnProductDetails).length === 0) {
      emptyProductFound = true;
    }
    addOnItemsWithProductDetails[productId] = addOnProductDetails;
  }
  if (!emptyProductFound) {
    setAddOnItemsWithProductDetails(prevState => {
      return {
        ...prevState,
        ...addOnItemsWithProductDetails
      };
    });
  }
};

/**
 * Method to update the shopper input value.
 * @param {*} newValue
 */
export const updateShopperInputValue = ({
  shopperInputEvent,
  shopperInput,
  addOnItemDetails,
  childItems,
  setSelections
}) => {
  if (shopperInputEvent && shopperInputEvent.target) {
    const shopperInputValue =
      shopperInputEvent.target.type === 'checkbox' ? shopperInputEvent.target.checked : shopperInputEvent.target.value;
    const targetAddOn = childItems.find(selectedAddOn => selectedAddOn.productId === addOnItemDetails.id);
    let targetShopperInput = targetAddOn.shopperInput;
    if (shopperInputValue !== undefined && shopperInputValue !== '') {
      targetShopperInput = {...targetShopperInput, [shopperInput.name]: `${shopperInputValue}`};
    } else {
      delete targetShopperInput[shopperInput.name];
    }
    const addOnsWithUpdatedShopperInput = childItems.map(selectedAddOn =>
      selectedAddOn.productId === addOnItemDetails.id
        ? {
            ...selectedAddOn,
            shopperInput: {
              ...targetShopperInput
            }
          }
        : selectedAddOn
    );
    setSelections(prevState => {
      return {
        ...prevState,
        childItems: [...addOnsWithUpdatedShopperInput]
      };
    });
  }
};
