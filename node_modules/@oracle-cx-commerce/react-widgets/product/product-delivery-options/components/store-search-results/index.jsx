/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import React from 'react';
import StoreSearchResultItem from '@oracle-cx-commerce/react-widgets/product/product-delivery-options/components/store-search-result-item';
import {validateQty} from '@oracle-cx-commerce/react-widgets/product/product-delivery-options/utils';
import {t} from '@oracle-cx-commerce/utils/generic';
import {useDateFormatter} from '@oracle-cx-commerce/react-components/utils/hooks';

/**
 * Renders the Pick up in Store Search Results
 */
const StoreSearchResults = props => {
  const {
    textInStock,
    textPreOrderable,
    textBackOrderable,
    textInStockWithQty,
    textBackOrderableWithQty,
    textPreOrderableWithQty,
    textBackOrderableWithAvailabilityDate,
    textPreOrderableWithAvailabilityDate,
    textPreOrderableWithQtyAndDate,
    textBackOrderableWithQtyAndDate,
    textOutOfStock,
    textSelect,
    skuInventory,
    storeSettings,
    stockStatuses,
    displayInStockStores,
    displayAvailabilityDate,
    displayNumberOfItemsAvailable,
    hideStoreLocatorOverlay,
    displayStoreSelectorModal,
    shippingGroupCommerceItem = {},
    shippingGroups = {},
    skuId,
    selectedQuantity,
    qty,
    orderLimit,
    messageInsufficientStockAtStore,
    shippingGroupId = ''
  } = props;
  let inStockIndex = 0;

  const formatDate = useDateFormatter();

  /**
   * Returns the formatted Availability Date
   * @param: locationId - location ID of the store
   */
  const getFormattedAvailabilityDate = locationId => {
    let formattedAvailabilityDate = null;
    const availabilityDate =
      skuInventory[locationId].stockStatus === stockStatuses.PREORDERABLE ||
      skuInventory[locationId].stockStatus === stockStatuses.BACKORDERABLE
        ? skuInventory[locationId].availabilityDate
        : null;
    if (displayAvailabilityDate && availabilityDate) {
      try {
        formattedAvailabilityDate = formatDate(new Date(availabilityDate));
      } catch (error) {
        console.error(error);
      }
    }

    return formattedAvailabilityDate;
  };

  /**
   * Returns the In Stock Availability Message based on the store
   * @param: locationId - location ID of the store
   */
  const getInStockAvailabilityMessage = locationId => {
    let stockAvailabilityMessage = null;
    if (displayNumberOfItemsAvailable) {
      stockAvailabilityMessage = t(textInStockWithQty, {
        availableQuantity: skuInventory[locationId].orderableQuantity
      });
    } else {
      stockAvailabilityMessage = textInStock;
    }

    return stockAvailabilityMessage;
  };

  // eslint-disable-next-line spellcheck/spell-checker
  /**
   * Returns the Back-Orderable/Pre-Orderable Item  Availability Message based on the store
   * @param: locationId - location ID of the store
   */
  const getBackOrPreOrderableMessage = locationId => {
    let itemAvailabilityMessage = null;
    const formattedAvailabilityDate = getFormattedAvailabilityDate(locationId);
    let orderableTextWithQty = '';
    let orderableTextWithDate = '';
    let orderableTextWithQtyAndDate = '';
    let orderableQuantity = '';

    if (skuInventory[locationId].stockStatus === stockStatuses.BACKORDERABLE) {
      orderableTextWithQty = textBackOrderableWithQty;
      orderableTextWithDate = textBackOrderableWithAvailabilityDate;
      orderableTextWithQtyAndDate = textBackOrderableWithQtyAndDate;
      orderableQuantity = skuInventory[locationId].backOrderableQuantity;
      itemAvailabilityMessage = textBackOrderable;
    } else if (skuInventory[locationId].stockStatus === stockStatuses.PREORDERABLE) {
      orderableTextWithQty = textPreOrderableWithQty;
      orderableTextWithDate = textPreOrderableWithAvailabilityDate;
      orderableTextWithQtyAndDate = textPreOrderableWithQtyAndDate;
      orderableQuantity = skuInventory[locationId].preOrderableQuantity;
      itemAvailabilityMessage = textPreOrderable;
    }

    if (displayNumberOfItemsAvailable && formattedAvailabilityDate) {
      itemAvailabilityMessage = t(orderableTextWithQtyAndDate, {
        availableQuantity: orderableQuantity,
        availabilityDate: formattedAvailabilityDate
      });
    } else if (displayNumberOfItemsAvailable && !formattedAvailabilityDate) {
      itemAvailabilityMessage = t(orderableTextWithQty, {
        availableQuantity: orderableQuantity
      });
    } else if (!displayNumberOfItemsAvailable && formattedAvailabilityDate) {
      itemAvailabilityMessage = t(orderableTextWithDate, {
        availabilityDate: formattedAvailabilityDate
      });
    }

    return itemAvailabilityMessage;
  };

  return (
    <>
      {Object.keys(storeSettings.stores).map((locationId, index) => {
        if (skuInventory[locationId]) {
          inStockIndex =
            displayInStockStores === true &&
            (skuInventory[locationId].stockStatus === stockStatuses.IN_STOCK ||
              skuInventory[locationId].stockStatus === stockStatuses.PREORDERABLE ||
              skuInventory[locationId].stockStatus === stockStatuses.BACKORDERABLE)
              ? inStockIndex + 1
              : inStockIndex;

          let stockAvailabilityMessage = null;
          let isStockInsuffiecient = false;
          let selectedQty = 0;
          if (selectedQuantity >= 1) {
            selectedQty = selectedQuantity;
          } else if (shippingGroupCommerceItem && shippingGroupCommerceItem.quantity) {
            selectedQty = shippingGroupCommerceItem.quantity;
          } else if (selectedQuantity === 0 && !shippingGroupCommerceItem) {
            selectedQty = 1;
          } else {
            selectedQty = qty;
          }
          const {isQtyValid, maxQtyAllowed} = validateQty(
            selectedQty,
            skuInventory[locationId].orderableQuantity,
            locationId,
            skuId,
            shippingGroups,
            shippingGroupId,
            orderLimit
          );
          if (!isQtyValid) {
            stockAvailabilityMessage = t(messageInsufficientStockAtStore, {MAXQUANTITY: maxQtyAllowed});
            isStockInsuffiecient = true;
          }
          if (!isStockInsuffiecient) {
            if (skuInventory[locationId].stockStatus === stockStatuses.IN_STOCK) {
              stockAvailabilityMessage = getInStockAvailabilityMessage(locationId);
            } else if (
              skuInventory[locationId].stockStatus === stockStatuses.BACKORDERABLE ||
              skuInventory[locationId].stockStatus === stockStatuses.PREORDERABLE
            ) {
              stockAvailabilityMessage = getBackOrPreOrderableMessage(locationId);
            }
          }

          return (
            <React.Fragment key={`${locationId}-${index + 1}`}>
              {!isStockInsuffiecient &&
                (skuInventory[locationId].stockStatus === stockStatuses.IN_STOCK ||
                  skuInventory[locationId].stockStatus === stockStatuses.PREORDERABLE ||
                  skuInventory[locationId].stockStatus === stockStatuses.BACKORDERABLE) && (
                  <StoreSearchResultItem
                    isFirstItem={
                      (displayInStockStores === true && inStockIndex - 1 === 0) ||
                      (displayInStockStores === false && index === 0)
                    }
                    store={storeSettings.stores[locationId]}
                    textSelect={textSelect}
                    stockAvailabilityMessage={stockAvailabilityMessage}
                    isStockInsuffiecient={isStockInsuffiecient}
                    hideStoreLocatorOverlay={hideStoreLocatorOverlay}
                    displayStoreSelectorModal={displayStoreSelectorModal}
                  />
                )}
              {displayInStockStores === false &&
                skuInventory[locationId] &&
                (skuInventory[locationId].stockStatus === stockStatuses.OUT_OF_STOCK || isStockInsuffiecient) && (
                  <StoreSearchResultItem
                    isFirstItem={index === 0}
                    store={storeSettings.stores[locationId]}
                    textSelect={textSelect}
                    textOutOfStock={
                      skuInventory[locationId].stockStatus === stockStatuses.OUT_OF_STOCK ? textOutOfStock : ''
                    }
                    stockAvailabilityMessage={stockAvailabilityMessage}
                    isStockInsuffiecient={isStockInsuffiecient}
                  />
                )}
            </React.Fragment>
          );
        }

        return <></>;
      })}
    </>
  );
};

export default React.memo(StoreSearchResults);
