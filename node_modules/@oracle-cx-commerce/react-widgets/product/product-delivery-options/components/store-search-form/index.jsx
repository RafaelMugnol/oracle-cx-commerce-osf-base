/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useEffect} from 'react';
import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import SearchIcon from '@oracle-cx-commerce/react-components/icons/search';
import InfoIcon from '@oracle-cx-commerce/react-components/icons/info';
import Styled from '@oracle-cx-commerce/react-components/styled';
import {formToJson} from '@oracle-cx-commerce/react-components/utils';
import {useComponentData} from '@oracle-cx-commerce/react-widgets/product/product-delivery-options/selectors';
import css from '@oracle-cx-commerce/react-widgets/product/product-delivery-options/components/store-search-form/styles.css';
import formCss from '@oracle-cx-commerce/react-components/form/styles.css';

/**
 * Displays pickup in stores search from.
 */
const StoreSearchForm = props => {
  const {
    storeSettings,
    setStoreSettings,
    labelFindAStore,
    queryInputParam,
    skuId,
    productId,
    textStoreSearchHelper,
    shippingGroupId = null
  } = props;

  /** Configuration Settings */
  const {numberOfMatchingStoresToDisplay = 10} = props;

  const {currentSiteId, locations, locationIdsForQuery} = useComponentData(productId, skuId);

  const {action} = useContext(StoreContext);

  /**
   * Notify that an error occurred
   * @param {*} error contains the failure response information
   */
  const handleListLocationsError = useCallback(
    ({error = {}}) => {
      action('notify', {level: 'error', message: error.message});
    },
    [action]
  );
  /**
   * As action was complete successfully, get the locations data and render the
   * Pickup Store search results.
   * @param {*} response the response object
   * @param {*} currentQueryForLocations current query for the locations
   */
  const handleListLocationsComplete = useCallback(
    currentQueryForLocations => {
      const newLocationsForQuery = {};
      const currentLocations = locationIdsForQuery[currentQueryForLocations];

      if (currentLocations) {
        for (let i = 0; i < currentLocations.length; i++) {
          if (Object.prototype.hasOwnProperty.call(locations, currentLocations[i])) {
            newLocationsForQuery[currentLocations[i]] = locations[currentLocations[i]];
          }
        }
      }

      setStoreSettings(prevState => {
        return {
          ...prevState,
          stores: newLocationsForQuery,
          currentQueryForLocations
        };
      });
    },
    [locationIdsForQuery, locations, setStoreSettings]
  );

  useEffect(() => {
    if (storeSettings.currentQueryForLocations) {
      handleListLocationsComplete(storeSettings.currentQueryForLocations);
    }
  }, [handleListLocationsComplete, storeSettings.currentLocations, storeSettings.currentQueryForLocations]);

  /**
   * Invoked when the HTML form is submitted.  Triggers the `listLocations` action
   * when the query is not available in the transient data of client repository
   * @param {*} event the form event.
   */
  const handleListLocationsForQuery = event => {
    event.preventDefault();

    const form = event.target;
    action('notifyClearAll');

    if (form.checkValidity()) {
      const {query} = formToJson(form);
      const queryString = `sites EQ "${currentSiteId}" AND type EQ "store" AND pickUp EQ true AND (address1 CO "${query}" OR address2 CO "${query}" OR city CO "${query}" OR postalCode CO "${query}" OR name CO "${query}" OR stateAddress CO "${query}")`;

      const params = {
        q: queryString,
        limit: Number(numberOfMatchingStoresToDisplay)
      };

      const newLocationsForQuery = {};

      if (queryString in locationIdsForQuery) {
        locationIdsForQuery[queryString].forEach(locationId => {
          if (Object.prototype.hasOwnProperty.call(locations, locationId)) {
            newLocationsForQuery[locationId] = locations[locationId];
          }
        });
        setStoreSettings(prevState => {
          return {
            ...prevState,
            stores: newLocationsForQuery,
            getStockStatusCompleted: false
          };
        });
      } else {
        action('listLocations', params).then(response => {
          if (response.ok === false) {
            handleListLocationsError(response);
          } else {
            handleListLocationsComplete(queryString);
            setStoreSettings(prevState => {
              return {
                ...prevState,
                getStockStatusCompleted: false
              };
            });
          }
        });
      }
    }
  };

  return (
    <Styled
      id="StoreSearchForm"
      css={`
        ${css} ${formCss}
      `}
    >
      <form onSubmit={handleListLocationsForQuery} noValidate={true}>
        <label htmlFor="query">{labelFindAStore}</label>
        <div className={'StoreSearchForm__InputDiv'}>
          <input
            type="text"
            maxLength="50"
            tabIndex={storeSettings.displayStoreSelectorModal ? 0 : -1}
            ref={queryInputParam}
            data-testid={`${skuId}${shippingGroupId ? `-${shippingGroupId}` : ``}-SearchInput`}
            id="query"
            name="query"
            required
          />
          <span className="validationMessage"></span>
          <input type="hidden" id="skuId" name="skuId" defaultValue={skuId} />
        </div>
        <div className="StoreSearchForm__SearchButtonDiv">
          <button
            tabIndex={storeSettings.displayStoreSelectorModal ? 0 : -1}
            data-testid={`${skuId}${shippingGroupId ? `-${shippingGroupId}` : ``}-SearchStores`}
            className={`secondary`}
            aria-label={labelFindAStore}
            type="submit"
          >
            <SearchIcon className="StoreSearchForm__SearchIcon" />
          </button>
        </div>
        <div className="StoreSearchForm__SearchHelperText">
          <InfoIcon className="StoreSearchForm__HelperTextIcon" /> {textStoreSearchHelper}
        </div>
      </form>
    </Styled>
  );
};

export default React.memo(StoreSearchForm);
