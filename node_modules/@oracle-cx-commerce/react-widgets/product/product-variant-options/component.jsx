/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
/* eslint-disable jsx-a11y/no-onchange */

import {ContainerContext, ProductContext, StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import React, {useContext, useState, useCallback} from 'react';
import VariantButtons from '@oracle-cx-commerce/react-widgets/product/product-variant-options/components/product-variant-button';
import VariantSelect from '@oracle-cx-commerce/react-widgets/product/product-variant-options/components/product-variant-select';
import VariantSwatches from '@oracle-cx-commerce/react-widgets/product/product-variant-options/components/product-variant-swatches';
import Styled from '@oracle-cx-commerce/react-components/styled';
import css from '@oracle-cx-commerce/react-widgets/product/product-variant-options/styles.css';
import {getCurrentPageId} from '@oracle-cx-commerce/commerce-utils/selector';

/**
 * Utility method to get the currently selected variant
 * @param {Object} pVariantOptions the variant options
 * @return {String} the selected option
 */
const getCurrentSelectedItem = (pVariantOptions = []) => {
  return Object.keys(pVariantOptions).reduce((previous, current) => {
    const {selectedValue} = pVariantOptions[current];

    return `${previous}${current}=${selectedValue !== null ? selectedValue : '.+'};`;
  }, '');
};

/**
 * A widget for displaying product variant options in the form of drop down, buttons or swatches based on configuration.
 * The temporary selections of the variant options and sku are maintained at the ContainerContext level.
 * This information is used by other widgets to get selected Sku, selected Sku images, selected Sku stock status.
 * Only valid Sku options can be selected, invalid options or unavailable options are disabled.
 */
const ProductVariantOptions = props => {
  const {variantOptionType = 'buttons', colorSwatchImageWidth = 40, colorSwatchImageHeight = 40} = props;
  // resources
  const {
    textPleaseSelect,
    colorSwatchUrlPlaceholder = '',
    unavailableSwatchOverlayImage = '',
    colorSwatchMappingProperty = 'x_swatchMapping',
    swatchVariantOption = 'color',
    colorSwatchShape
  } = props;

  // context
  const {getState} = useContext(StoreContext);

  const pageId = getCurrentPageId(getState()) || '';

  const {
    id: productId,
    [colorSwatchMappingProperty]: swatchMapping = null,
    variantOptionPermutations,
    variantOptionsSeed,
    variantToSkuLookup = []
  } = useContext(ProductContext);

  const {selections = {}, setSelections} = useContext(ContainerContext);

  // state
  const [optionChanged, setOptionChanged] = useState(false);
  const variantOptions = {...variantOptionsSeed};

  /**
   * Update and return the variant options with selections from URL, if any
   */
  const updateSelections = useCallback(() => {
    // get the latest selected item from the options
    const currentSelectedItem = getCurrentSelectedItem(variantOptions);
    const variantOptionsLite = {};
    // loop through each variant and enable/disable options
    Object.entries(variantOptions || {}).forEach(([optionKey, {selectedValue, optionId, optionName, options = {}}]) => {
      variantOptionsLite[optionKey] = {
        optionName,
        optionId,
        selectedValue
      };
      // loop through each variant option
      options.forEach(option => {
        const optionKeyValuePair = `${optionKey}=${option.value};`;
        // replace any matching value between = and ; with the option key, handles number or '.+' placeholder
        const newSelectedItemKey = currentSelectedItem.replace(new RegExp(`${optionKey}=.+?;`), optionKeyValuePair);
        const newSelectedItemKeyRegEx = new RegExp(newSelectedItemKey);
        // if the selected variant combination is not in the variantOptionPermutations then disable that variant
        option.disabled = !newSelectedItemKeyRegEx.test(new RegExp(variantOptionPermutations));
      });
    });
    setSelections({
      ...selections,
      variantOptions: variantOptionsLite,
      skuId: variantToSkuLookup[currentSelectedItem],
      selectedStore: {},
      isPickupInStoreOptionSelected: false
    });
  }, [selections, setSelections, variantOptionPermutations, variantOptions, variantToSkuLookup]);

  /**
   * Update and return the variant options with selections from URL, if any
   */
  (() => {
    // for the first time loading the page
    if (!optionChanged && variantOptions) {
      const queryPart = pageId.split('?')[1];
      const urlParams = new URLSearchParams(queryPart ? queryPart : {});
      const optionNameURL = urlParams.get('variantName');
      const optionValUrl = urlParams.get('variantValue');
      Object.entries(variantOptions).forEach(([, variantOption]) => {
        const {optionName, options = []} = variantOption;
        variantOption.selectedValue = null;
        if (optionNameURL && optionValUrl && optionName === optionNameURL) {
          const optionFound = options.find(({name}) => name === optionValUrl);
          if (optionFound) {
            variantOption.selectedValue = optionFound.value;
            setOptionChanged(true);
            updateSelections();
          }
        }
      });
    }
  })();

  /**
   * Handle the variant change for drop down, button & swatches
   * @param {String} value The value of the selected option
   * @param {String} optionKey The name of the selected option
   */
  const handleVariantOptionChange = useCallback(
    (value, optionKey) => {
      value = parseInt(value, 10);

      if (isNaN(value) || variantOptions[optionKey].selectedValue === value) {
        value = null;
      }
      variantOptions[optionKey].selectedValue = value;
      !optionChanged && setOptionChanged(true);
      updateSelections();
    },
    [optionChanged, updateSelections, variantOptions]
  );

  /**
   * Build up the URL used to retrieve the swatch image
   *
   * @param {*} productId the product id
   * @param {*} optionName the option name
   * @return {String} swatchImageUrl
   */
  const getSwatchUrl = useCallback(
    (productId, optionName) => {
      if (swatchMapping) {
        try {
          const parsedColorCodeMapping = JSON.parse(swatchMapping);
          const swatchId = parsedColorCodeMapping[optionName];

          if (swatchId) {
            return colorSwatchUrlPlaceholder
              .replace('__productId__', productId)
              .replace('__swatchKey__', swatchId)
              .replace('__height__', colorSwatchImageHeight)
              .replace('__width__', colorSwatchImageWidth);
          }
        } catch (i) {
          return '';
        }
      }

      return '';
    },
    [colorSwatchImageHeight, colorSwatchImageWidth, colorSwatchUrlPlaceholder, swatchMapping]
  );

  /**
   * Decides the type of variant picker to use
   *
   * @param {Object} props the function payload
   * @param {number} props.optionKey the variant id
   * @param {Array} props.options the available options for variant
   * @param {String} props.selectedValue selected option value
   */
  const renderVariantSelectorType = (optionKey, options, selectedValue) => {
    if (swatchMapping && optionKey.endsWith(swatchVariantOption)) {
      return (
        <VariantSwatches
          options={options}
          optionKey={optionKey}
          selectedValue={selectedValue}
          getSwatchUrl={getSwatchUrl}
          productId={productId}
          unavailableSwatchOverlayImage={unavailableSwatchOverlayImage}
          handleVariantOptionChange={handleVariantOptionChange}
          colorSwatchShape={colorSwatchShape}
        />
      );
    }
    if (variantOptionType === 'dropdown') {
      return (
        <VariantSelect
          options={options}
          optionKey={optionKey}
          selectedValue={selectedValue}
          handleVariantOptionChange={handleVariantOptionChange}
          textPleaseSelect={textPleaseSelect}
        />
      );
    }

    return (
      <VariantButtons
        options={options}
        optionKey={optionKey}
        selectedValue={selectedValue}
        handleVariantOptionChange={handleVariantOptionChange}
      />
    );
  };

  return (
    <Styled id="ProductVariantOptions" css={css}>
      <div className="ProductVariantOptions">
        {Object.entries(variantOptions || {}).map(
          ([optionKey, {options = [], selectedValue, optionId, optionName}]) => {
            let optionNameDisplay = optionName;
            if (swatchMapping && optionId.endsWith(swatchVariantOption) && selectedValue !== null) {
              const {name} = options.find(option => option.value === selectedValue);
              optionNameDisplay += `: ${name}`;
            }

            return (
              <div key={`${optionId}-${optionKey}`} className="ProductVariantOptions__Wrapper">
                <span className="ProductVariantOptions__OptionName">{optionNameDisplay}</span>
                {renderVariantSelectorType(optionKey, options, selectedValue)}
              </div>
            );
          }
        )}
      </div>
    </Styled>
  );
};

export default ProductVariantOptions;
