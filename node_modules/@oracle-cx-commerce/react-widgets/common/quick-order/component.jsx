/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useEffect, useRef, useState} from 'react';
import {getCurrentCatalogId, getCurrentPriceListGroup} from '@oracle-cx-commerce/commerce-utils/selector';

import AddedToCartModal from '@oracle-cx-commerce/react-widgets/common/quick-order/components/added-to-cart-modal';
import Form from '@oracle-cx-commerce/react-components/form';
import ImportCSV from '@oracle-cx-commerce/react-widgets/common/quick-order/components/quick-order-import-csv';
import ProductSelectorRow from '@oracle-cx-commerce/react-widgets/common/quick-order/components/quick-order-product-selector-row';
import PropTypes from 'prop-types';
import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import Styled from '@oracle-cx-commerce/react-components/styled';
import css from '@oracle-cx-commerce/react-widgets/common/quick-order/styles.css';

/*
 ** Quick Order Widget
 * A widget which allows user to add batch of products to the cart quickly.
 */
const QuickOrder = props => {
  const {skuEntryFields, skuSuggestions, maxImportRows} = props;
  //resources
  const {
    textQuickOrderTitle,
    textQuickOrderDescription,
    textImportCSV,
    textImportingCSV,
    textClearFields,
    textQuickOrderHeaderProduct,
    textQuickOrderHeaderQuantity,
    textQuickOrderSearchRow,
    textQuickOrderAddToCartContent,
    textViewCart,
    closeLinkAltText,
    actionAddRows,
    actionQuickOrderAddToCart,
    alertAddToCartAdding,
    alertAddedToCart,
    alertNotAddedToCart,
    alertInlineError,
    alertCannotFetchSku,
    alertFileTypeNotSupported,
    alertMaxItemsImported,
    labelProductQuantity,
    labelAddToQuickOrder,
    quickOrderOutOfStockText,
    quickOrderInvalidText,
    quickOrderInactiveText,
    quickOrderInsufficientStockText,
    quickOrderRowInvalidText,
    quickOrderInvalidQuantity
  } = props;
  const {action, getState} = useContext(StoreContext);
  const [listSkuEntries, setListSkuEntries] = useState({});
  const [formDisabled, setFormDisabled] = useState(false);
  const [modalView, setModalView] = useState(false);
  const searchInput = useRef(null);
  const addToCartButtonRef = useRef(null);
  const [noOfItemAdded, setNoOfItemAdded] = useState();
  const catalogId = getCurrentCatalogId(getState());
  const storePriceListGroupId = getCurrentPriceListGroup(getState()).id;

  /**
   * generates required number of rows from specified start index.
   */
  const generateRows = useCallback(
    (noOfRows = skuEntryFields, startId = 0) => {
      const rows = [...new Array(parseInt(noOfRows, 10))].reduce((target, _, index) => {
        target[index + startId] = {id: index + startId, product: {quantity: 1}};

        return target;
      }, {});

      return rows;
    },
    [skuEntryFields]
  );

  /**
   * Closes addedToCart modal.
   */
  const closeModal = useCallback(() => {
    setModalView(false);
  }, []);

  const updateAddToCartButton = useCallback(
    (enable, text) => {
      addToCartButtonRef.current.disabled = enable;
      addToCartButtonRef.current.innerText = text;
    },
    [addToCartButtonRef]
  );

  /**
   * Resets all rows to default or empty.
   */
  const resetAllFields = useCallback(() => {
    setListSkuEntries(generateRows());
    action('clearTypeahead');
  }, [action, generateRows]);

  useEffect(() => {
    resetAllFields();
  }, [resetAllFields]);

  /**
   * Invalid items returned from addQuickOrderItemsToCart action will be transformed to rows with
   * errors in each if present.
   */
  const transformInvalidItems = useCallback(
    responseSkus => {
      const skuEntries = {...listSkuEntries};
      const skuEntryRows = Object.keys(skuEntries).length;
      let containsInvalidItems = false;
      let count = 0;
      let noOfItems = 0;
      for (const key in skuEntries) {
        const catRefId = skuEntries[key].product.catRefId || skuEntries[key].product.displayName;
        if (!catRefId || (catRefId && responseSkus[catRefId] === 'valid')) {
          delete skuEntries[key];
          count++;
          if (responseSkus[catRefId] === 'valid') {
            noOfItems++;
          }
        } else if (catRefId && responseSkus[catRefId] !== 'valid') {
          containsInvalidItems = true;
          skuEntries[key - count] = skuEntries[key];
          skuEntries[key - count].product.errorType = responseSkus[catRefId];
          skuEntries[key - count].id = key - count;
          if (count !== 0) {
            delete skuEntries[key];
          }
        }
      }
      const extraRows = count > 0 ? generateRows(count, skuEntryRows - count) : {};
      setNoOfItemAdded(noOfItems);

      return {skuEntries: {...skuEntries, ...extraRows}, containsInvalidItems};
    },
    [generateRows, listSkuEntries]
  );

  /**
   * Success callback for addQuickOrderItemsToCart action.
   */
  const onOk = useCallback(
    responseSkus => {
      const {skuEntries, containsInvalidItems} = transformInvalidItems(responseSkus);
      setListSkuEntries(skuEntries);
      if (!containsInvalidItems) {
        setModalView(true);
      }

      action('notify', {
        level: containsInvalidItems ? 'error' : 'success',
        message: containsInvalidItems ? alertNotAddedToCart : alertAddedToCart
      });
    },
    [action, alertAddedToCart, alertNotAddedToCart, transformInvalidItems]
  );

  /**
   * Error callback for addQuickOrderItemsToCart action.
   */
  const onNotOk = useCallback(
    responseSkus => {
      const {skuEntries} = transformInvalidItems(responseSkus);
      setListSkuEntries(skuEntries);
      action('notify', {level: 'error', message: alertNotAddedToCart});
    },
    [action, alertNotAddedToCart, transformInvalidItems]
  );

  /**
   * Makes call to addQuickOrderItemsToCart action which internally calls addItemsToCart endpoint to add the skus
   * to the current cart.
   */
  const addToCartAction = useCallback(
    payload => {
      action('addQuickOrderItemsToCart', {items: payload})
        .then(response => {
          updateAddToCartButton(false, actionQuickOrderAddToCart);
          const {skus: responseSkus = {}} = response.json || {};
          if (response.ok === true && (!response.json || !response.json.noItemsAdded)) {
            onOk(responseSkus);
          } else {
            onNotOk(responseSkus);
          }
        })
        .catch(() => {
          updateAddToCartButton(false, actionQuickOrderAddToCart);
          onNotOk({});
        });
    },
    [action, actionQuickOrderAddToCart, onNotOk, onOk, updateAddToCartButton]
  );

  /**
   * Makes call to listSkus to get the details of the sku entries which doesn't have corresponding productId.
   * On success callback it calls addToCartAction to add the items to the cart.
   */
  const processEntriesWithoutProductId = useCallback(
    (skusWithoutProdId, addToCartPayload) => {
      action('listSkus', {
        skuIds: [
          ...new Set(
            skusWithoutProdId.map(sku => {
              return sku.catRefId;
            })
          )
        ].join(','),
        storePriceListGroupId,
        catalogId,
        state: true
      }).then(response => {
        if (response.ok) {
          if (response.json.deletedSkus && response.json.deletedSkus.length > 0) {
            const skuEntries = {...listSkuEntries};
            const {deletedSkus = []} = response.json;
            deletedSkus.forEach(element => {
              for (const key in skuEntries) {
                const entry = skuEntries[key];
                if (entry.product.displayName === element) {
                  entry.product.errorType = 'invalidImport';
                }
              }
            });
            action('notify', {level: 'error', message: alertInlineError});
            setListSkuEntries({...skuEntries});
            updateAddToCartButton(false, actionQuickOrderAddToCart);

            return;
          }
          if (response.delta.catalogRepository) {
            const {skus = {}} = response.delta.catalogRepository;
            const additionalSkus = skusWithoutProdId.reduce((target, sku) => {
              if (skus[sku.catRefId]) {
                target.push({...sku, productId: skus[sku.catRefId].parentProducts[0].id});
              }

              return target;
            }, []);
            addToCartPayload = [...addToCartPayload, ...additionalSkus];
          }
          addToCartAction(addToCartPayload);
        } else {
          updateAddToCartButton(false, actionQuickOrderAddToCart);
          action('notify', {
            level: 'error',
            message: response.error.message
          });
        }
      });
    },
    [
      action,
      actionQuickOrderAddToCart,
      addToCartAction,
      alertInlineError,
      catalogId,
      listSkuEntries,
      storePriceListGroupId,
      updateAddToCartButton
    ]
  );

  /**
   * Handler for add to cart button in the widget.
   */
  const handleAddToCart = useCallback(() => {
    updateAddToCartButton(true, alertAddToCartAdding);
    const skuEntries = {...listSkuEntries};
    const payload = [];
    const skusWithoutProductId = [];
    for (const key in skuEntries) {
      const entry = skuEntries[key];
      if (entry.product.errorType) {
        action('notify', {level: 'error', message: alertInlineError});
        updateAddToCartButton(false, actionQuickOrderAddToCart);

        return;
      }
      const {
        product: {productId, catRefId, displayName, quantity}
      } = entry;
      if (catRefId || displayName) {
        if (!productId) skusWithoutProductId.push({catRefId: catRefId || displayName, quantity});
        else payload.push({productId, catRefId: catRefId || displayName, quantity});
      }
    }
    //used when user enter the skuId manually and search returns 0 records.
    if (skusWithoutProductId.length > 0) {
      processEntriesWithoutProductId(skusWithoutProductId, payload);
    } else if (payload.length > 0) {
      addToCartAction(payload);
    } else {
      updateAddToCartButton(false, actionQuickOrderAddToCart);
    }
  }, [
    action,
    actionQuickOrderAddToCart,
    addToCartAction,
    alertAddToCartAdding,
    alertInlineError,
    listSkuEntries,
    processEntriesWithoutProductId,
    updateAddToCartButton
  ]);

  /**
   * Adds more rows to the widget when clicked "Add more rows".
   */
  const addMoreRows = useCallback(() => {
    const rows = {...listSkuEntries};
    const moreRows = generateRows(skuEntryFields, Object.keys(rows).length);
    setListSkuEntries({...rows, ...moreRows});
  }, [generateRows, listSkuEntries, skuEntryFields]);

  return (
    <Styled id="QuickOrder" css={css}>
      <>
        <div className="QuickOrder">
          <h1>{textQuickOrderTitle}</h1>
          <p>{textQuickOrderDescription}</p>
          <span>
            <ImportCSV
              resources={{textImportCSV, textImportingCSV, alertFileTypeNotSupported, alertMaxItemsImported}}
              listSkuEntries={listSkuEntries}
              setListSkuEntries={setListSkuEntries}
              alertCannotFetchSku={alertCannotFetchSku}
              maxImportRows={maxImportRows}
              disableForm={setFormDisabled}
            />
          </span>
          <span className="QuickOrder__ClearAllButton">
            <button type="button" onClick={resetAllFields} disabled={formDisabled}>
              {textClearFields}
            </button>
          </span>

          <div>
            <Form>
              <div className="QuickOrder__Table">
                <div className="QuickOrder__Header">
                  <div className="QuickOrder__Column1">{textQuickOrderHeaderProduct}</div>
                  <div className="QuickOrder__Column2">{textQuickOrderHeaderQuantity}</div>
                </div>
                {Object.values(listSkuEntries).map(entry => (
                  <ProductSelectorRow
                    key={entry.id}
                    entry={entry}
                    listSkuEntries={listSkuEntries}
                    setListSkuEntries={setListSkuEntries}
                    resources={{
                      textQuickOrderSearchRow,
                      quickOrderInvalidText,
                      quickOrderInactiveText,
                      quickOrderOutOfStockText,
                      quickOrderInsufficientStockText,
                      quickOrderRowInvalidText,
                      quickOrderInvalidQuantity,
                      labelProductQuantity,
                      labelAddToQuickOrder
                    }}
                    formDisabled={formDisabled}
                    searchInput={searchInput}
                    skuSuggestions={skuSuggestions}
                  />
                ))}
              </div>
              <div className="QuickOrder__AddRow">
                <button type="button" onClick={addMoreRows} disabled={formDisabled}>
                  {actionAddRows}
                </button>
              </div>
              <div className="QuickOrder__AddToCart">
                <button type="button" onClick={handleAddToCart} disabled={formDisabled} ref={addToCartButtonRef}>
                  {actionQuickOrderAddToCart}
                </button>
              </div>
            </Form>
          </div>
          <AddedToCartModal
            noOfItems={noOfItemAdded}
            showModal={modalView}
            closeModal={closeModal}
            resources={{alertAddedToCart, closeLinkAltText, textQuickOrderAddToCartContent, textViewCart}}
          />
        </div>
      </>
    </Styled>
  );
};

QuickOrder.propTypes = {
  /** widget config property suggesting how many rows to be displayed */
  skuEntryFields: PropTypes.string.isRequired,
  /** widget config property suggesting how many search results to be displayed in typeahead */
  skuSuggestions: PropTypes.string.isRequired,
  /** widget config property suggesting how many rows can be imported maximum at once */
  maxImportRows: PropTypes.string.isRequired
};

QuickOrder.defaultProps = {};

export default QuickOrder;
