/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useState} from 'react';
import {getCurrentCatalogId, getCurrentPriceListGroup, getSkus} from '@oracle-cx-commerce/commerce-utils/selector';

import PropTypes from 'prop-types';
import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import Styled from '@oracle-cx-commerce/react-components/styled';
import css from '@oracle-cx-commerce/react-widgets/common/quick-order/components/quick-order-import-csv/style.css';
import {isEmptyObject} from '@oracle-cx-commerce/utils/generic';

/*
 ** ImportCSV component
 * A sub component for import csv button in quick order widget.
 */
const ImportCSV = props => {
  const {alertCannotFetchSku, listSkuEntries, disableForm, maxImportRows, setListSkuEntries, resources} = props;

  const {action, getState} = useContext(StoreContext);
  const catalogId = getCurrentCatalogId(getState());
  const storePriceListGroupId = getCurrentPriceListGroup(getState()).id;

  const [buttonText, setButtonText] = useState(resources.textImportCSV);

  /**
   * Transforms csv row in to quick order row.
   */
  const transformCSVRow = (id, csvRow, fetchedSkus) => {
    if (fetchedSkus.deletedSkus && fetchedSkus.deletedSkus[csvRow.product.catRefId]) {
      csvRow.id = id;
      csvRow.product.errorType = 'invalidImport';

      return csvRow;
    }
    if (csvRow.product.quantity <= 0 || isNaN(parseInt(csvRow.product.quantity, 10))) {
      csvRow.product.errorType = 'invalidQuantity';
    }
    const sku = fetchedSkus[csvRow.product.catRefId];
    csvRow.product.productId = sku.parentProducts[0].id;
    csvRow.id = id;

    return csvRow;
  };

  const onNotOk = useCallback(
    message => {
      action('notify', {level: 'error', message});
    },
    [action]
  );

  /**
   * Updates quick order widget rows with imported csv rows.
   */
  const updateSkuEntries = useCallback(
    (fetchedSkus, csvData) => {
      const listSkus = {...listSkuEntries};
      let count = 0;
      for (const [key, skuEntry] of Object.entries(listSkus)) {
        if (count >= csvData.length) {
          break;
        }
        //skip, if the row is occupied already
        if (!(skuEntry.product.catRefId || skuEntry.product.displayName)) {
          const row = csvData[count];
          listSkus[key] = transformCSVRow(key, row, fetchedSkus);
          count++;
        }
      }
      const moreRows = {}; //if CSV has more data left, transform them too.
      for (let i = count, j = 0; i < csvData.length; i++, j++) {
        const id = Object.keys(listSkus).length + j;
        moreRows[id] = transformCSVRow(id, csvData[i], fetchedSkus);
      }
      setListSkuEntries({...listSkus, ...moreRows});
      disableForm(false);
      setButtonText(resources.textImportCSV);
    },
    [disableForm, listSkuEntries, resources.textImportCSV, setListSkuEntries]
  );

  /**
   * Fetches skus data that are being imported.
   */
  const fetchSkuData = useCallback(
    (csvData, importedSkus) => {
      //If Skus already present in state, do not fetch them again.
      const existingSkus = {};
      let skusToBeFetched = [];
      const skusInState = getSkus(getState());
      if (isEmptyObject(skusInState)) {
        skusToBeFetched = [...importedSkus];
      } else {
        for (let i = 0; i < importedSkus.length; i++) {
          if (skusInState[importedSkus[i]]) {
            existingSkus[importedSkus[i]] = skusInState[importedSkus[i]];
          } else {
            skusToBeFetched.push(importedSkus[i]);
          }
        }
      }
      if (skusToBeFetched.length === 0) {
        updateSkuEntries(existingSkus, csvData);
      } else {
        action('listSkus', {
          skuIds: [...new Set(skusToBeFetched)].join(','),
          storePriceListGroupId,
          catalogId,
          state: true
        })
          .then(response => {
            if (response.ok === true) {
              let allSkus = {...existingSkus};
              const {deletedSkus = []} = response.json;
              const explodedDeletedSkus = deletedSkus.reduce((target, item) => {
                target[item] = item;

                return target;
              }, {});
              if (response.delta.catalogRepository) {
                const {skus = {}} = response.delta.catalogRepository;
                allSkus = {...skus, ...existingSkus, deletedSkus: explodedDeletedSkus};
              }
              updateSkuEntries(allSkus, csvData);
            } else {
              onNotOk(alertCannotFetchSku);
              disableForm(false);
              setButtonText(resources.textImportCSV);
            }
          })
          .catch(() => {
            onNotOk(alertCannotFetchSku);
            disableForm(false);
            setButtonText(resources.textImportCSV);
          });
      }
    },
    [
      action,
      alertCannotFetchSku,
      catalogId,
      disableForm,
      getState,
      onNotOk,
      resources.textImportCSV,
      storePriceListGroupId,
      updateSkuEntries
    ]
  );

  /**
   * Handler for import CSV button.
   */
  const handleFileImport = useCallback(
    event => {
      if (event.target.files && event.target.files.length) {
        disableForm(true);
        setButtonText(resources.textImportingCSV);
        const [file] = event.target.files;
        const fileExtension = file.name && file.name.split('.').pop();
        if (fileExtension !== 'csv') {
          onNotOk(resources.alertFileTypeNotSupported);
          disableForm(false);
          setButtonText(resources.textImportCSV);

          return;
        }
        const reader = new FileReader();
        reader.addEventListener('load', ev => {
          const csv = ev.target.result || '';
          const allTextLines = csv.split(/\r\n|\n/);
          if (allTextLines.length > parseInt(maxImportRows, 10) || allTextLines.length > 1000) {
            onNotOk(resources.alertMaxItemsImported);
            disableForm(false);
            setButtonText(resources.textImportCSV);

            return;
          }
          const skus = [];
          const csvData = allTextLines.reduce((target, line) => {
            const data = line.split(',');
            if (data[0] && data[0].length > 0) {
              skus.push(data[0]);
              let quantity = data[1];
              if (data[1] && !isNaN(parseInt(data[1], 10))) {
                quantity = parseInt(data[1], 10);
              }
              target.push({product: {catRefId: data[0], quantity}});
            }

            return target;
          }, []);
          fetchSkuData(csvData, skus);
        });
        reader.readAsText(file);
        event.target.value = '';
      }
    },
    [
      disableForm,
      fetchSkuData,
      maxImportRows,
      onNotOk,
      resources.alertFileTypeNotSupported,
      resources.alertMaxItemsImported,
      resources.textImportCSV,
      resources.textImportingCSV
    ]
  );

  return (
    <Styled id="Quantity" css={css}>
      <label
        htmlFor="QuickOrder__FileUpload"
        className={`QuickOrder__FileUpload ${
          buttonText === resources.textImportingCSV ? 'QuickOrder__FileUpload__disabled' : ''
        }`}
      >
        {buttonText}
      </label>
      <input
        className="QuickOrder__InputFile button button--secondary"
        id="QuickOrder__FileUpload"
        type="file"
        onChange={handleFileImport}
        disabled={buttonText === resources.textImportingCSV}
      />
    </Styled>
  );
};

ImportCSV.propTypes = {
  /** sku entries object representing rows in quick order widget */
  listSkuEntries: PropTypes.objectOf(PropTypes.object).isRequired,
  /** Callback function to be invoked to update the sku entries list */
  setListSkuEntries: PropTypes.func.isRequired,
  /** widget config property suggesting how many rows can be imported maximum at once */
  maxImportRows: PropTypes.string.isRequired,
  /** set this boolean flag to disable form when the csv import is in progress */
  disableForm: PropTypes.func.isRequired
};

ImportCSV.defaultProps = {};

export default ImportCSV;
