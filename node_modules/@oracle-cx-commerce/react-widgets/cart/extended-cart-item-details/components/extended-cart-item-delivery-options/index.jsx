/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useContext, useEffect} from 'react';
import {CartItemContext, ContainerContext, ProductContext, StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import ProductDeliveryOptions from '@oracle-cx-commerce/react-widgets/product/product-delivery-options/component';
import InStorePickupSelector from '@oracle-cx-commerce/react-widgets/cart/extended-cart-item-details/components/in-store-pickup-selector';
import {
  getShippingItemRelationships,
  getLocationBasedItemQtyFromSGs
} from '@oracle-cx-commerce/react-widgets/product/product-delivery-options/utils';
import {
  getPayloadForSwitchingDeliveryOption,
  setInvalidItemsQtyAndErrorMessage,
  removeCurrentItemFromInvalidItems,
  setDeliveryMethodChanged,
  setQuantityValidated,
  updateInvalidCommerceItemsQty
} from '@oracle-cx-commerce/react-components/utils/cart';
import {
  SHIPPING_GROUP_HARDGOOD,
  SHIPPING_GROUP_IN_STORE_PICKUP
} from '@oracle-cx-commerce/commerce-utils/constants/shipping';

import {getCurrentOrder, getSkuInventory} from '@oracle-cx-commerce/commerce-utils/selector';
import {useSelector} from '@oracle-cx-commerce/react-components/provider';
import {isEmptyObject, t, noop} from '@oracle-cx-commerce/utils/generic';

/**
 * Extended Cart Item Delivery Options widget - Used to change the delivery options for each line of the extended cart.
 * @param {*} props - Contains the Shipping Group and current line item data and corresponding locales.
 */
const ExtendedCartItemDeliveryOptions = props => {
  /* Store Context */
  const store = useContext(StoreContext);
  const {action} = store;

  /** Container Context Data */
  const {selections = {}, setSelections} = useContext(ContainerContext);
  const {
    skuId = null,
    selectedStore = {},
    isDeliveryMethodInitialized = false,
    isDeliveryMethodChanged = false,
    isQuantityValidated = false,
    selectedQuantity = 0,
    isPickupInStoreOptionSelected = false
  } = selections;

  /** Product Context Data */
  const {id: productId} = useContext(ProductContext);
  const skuInventory = useSelector(getSkuInventory, {skuId});
  const defaultSkuInventory = skuInventory['default'] || {};

  /** CartItem Context Data */
  const {errorMessage, setErrorMessage, commerceItem} = useContext(CartItemContext);

  /** Props Data */
  const {
    shippingGroupId,
    shippingGroupCommerceItem = {},
    currentOrder = {},
    messageInsufficientStock,
    messageInsufficientStockAtStore,
    setInvalidItems,
    invalidItemsOnQuantityChange,
    setInvalidItemsOnQuantityChange,
    displayDeliveryOptions = true
  } = props;

  const {shippingGroups = {}} = currentOrder;

  const shippingItemRelationships = getShippingItemRelationships(shippingGroups);
  const quantityToValidate = selectedQuantity === 0 ? shippingGroupCommerceItem.quantity : selectedQuantity;

  /**
   * Call back method to handle when an action response is a failure.
   */
  const onNotOk = ({
    response: {error = {}},
    shippingGroupId,
    shippingGroups,
    commerceItem,
    skuInventory,
    newRelationshipItemQuantity,
    messageInsufficientStock,
    messageInsufficientStockAtStore,
    setErrorMessage
  }) => {
    let itemLocation = '';
    if (error.errorCode === '28104') {
      if (!isEmptyObject(commerceItem) && !isEmptyObject(skuInventory) && shippingGroupId) {
        itemLocation =
          shippingGroups[shippingGroupId] &&
          shippingGroups[shippingGroupId].store &&
          shippingGroups[shippingGroupId].store.locationId
            ? shippingGroups[shippingGroupId].store.locationId
            : 'default';
        if (skuInventory[itemLocation] && newRelationshipItemQuantity > skuInventory[itemLocation].orderableQuantity) {
          if (itemLocation === 'default') {
            setErrorMessage(t(messageInsufficientStock, {MAXQUANTITY: skuInventory[itemLocation].orderableQuantity}));
          } else {
            setErrorMessage(
              t(messageInsufficientStockAtStore, {MAXQUANTITY: skuInventory[itemLocation].orderableQuantity})
            );
          }
        } else {
          setErrorMessage(error.message);
        }
      }
    } else {
      setErrorMessage(error.message);
    }
  };

  useEffect(() => {
    //On Page load set the delivery options based the availability of selected store for a particular SG.
    if (!isDeliveryMethodInitialized && !isPickupInStoreOptionSelected && selectedStore.locationId) {
      setSelections(prevState => {
        return {
          ...prevState,
          isPickupInStoreOptionSelected: true,
          isDeliveryMethodInitialized: true
        };
      });
    }

    const relationships = [];

    /**
     * Validates the line item quantity against the location based Sku inventory and
     * sets the validation error message if item is out of stock.
     */
    const validateLinetemQuantity = shippingGroupType => {
      //If quantity is valid, clear the error message
      let itemLocation = '';
      if (!isEmptyObject(commerceItem) && !isEmptyObject(skuInventory)) {
        itemLocation =
          isPickupInStoreOptionSelected && selectedStore && selectedStore.locationId
            ? selectedStore.locationId
            : 'default';
        let errorMsg = '';
        if (skuInventory[itemLocation] && quantityToValidate > skuInventory[itemLocation].orderableQuantity) {
          if (itemLocation === 'default') {
            errorMsg = t(messageInsufficientStock, {MAXQUANTITY: skuInventory[itemLocation].orderableQuantity});
            setErrorMessage(errorMsg);
          } else {
            errorMsg = t(messageInsufficientStockAtStore, {MAXQUANTITY: skuInventory[itemLocation].orderableQuantity});
            setErrorMessage(errorMsg);
          }
          setInvalidItemsQtyAndErrorMessage({
            setInvalidItems,
            setInvalidItemsOnQuantityChange,
            shippingGroupId,
            commerceId: commerceItem.id,
            quantity: quantityToValidate,
            errorMsg
          });
        } else if (
          skuInventory[itemLocation] &&
          quantityToValidate <= skuInventory[itemLocation].orderableQuantity &&
          shippingGroups[shippingGroupId].type === shippingGroupType
        ) {
          setErrorMessage('');
          if (
            (invalidItemsOnQuantityChange &&
              invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg !== undefined &&
              invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg[
                `${shippingGroupId}${shippingGroupCommerceItem.commerceId}`
              ]) ||
            (invalidItemsOnQuantityChange &&
              shippingGroups[shippingGroupId].type === SHIPPING_GROUP_HARDGOOD &&
              Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).some(function (k) {
                return k.indexOf(shippingGroupCommerceItem.commerceId) > -1;
              }))
          ) {
            removeCurrentItemFromInvalidItems({
              shippingGroupId,
              commerceId: commerceItem.id,
              setInvalidItems,
              setInvalidItemsOnQuantityChange
            });
          }
        }
      }
    };

    /**
     * Handles the store selection for a line item on extended cart.
     */
    const handleStoreSelection = async () => {
      //Reset isDeliveryMethodChanged property value.
      if (isDeliveryMethodChanged) {
        setDeliveryMethodChanged(setSelections, false);
      }
      //Invoke RelateItems action with appropriate payload
      //check for the combination of Sku ID and the Shipping Group if exits
      //catRefId is present in cart/checkout pages only which will have the same value as Sku ID.
      let targetShippingGroupId = null;
      let commerceItemFound = null;

      if (Object.keys(shippingGroups).length > 0 && skuId) {
        targetShippingGroupId = Object.keys(shippingGroups).find(shippingGroupId => {
          commerceItemFound = shippingGroups[shippingGroupId].items.find(item => {
            return (
              item.catRefId === skuId &&
              shippingGroups[shippingGroupId].type === SHIPPING_GROUP_IN_STORE_PICKUP &&
              shippingGroups[shippingGroupId].store.locationId === selectedStore.locationId
            );
          });

          //return based on commerceItem found or any SG exists with no commerce items but selected store
          return (
            commerceItemFound ||
            (shippingGroups[shippingGroupId].type === SHIPPING_GROUP_IN_STORE_PICKUP &&
              shippingGroups[shippingGroupId].store.locationId === selectedStore.locationId &&
              shippingGroups[shippingGroupId].items.length === 0)
          );
        });

        const currentRelationShipId = Object.keys(shippingItemRelationships).find(relationShipId => {
          return !commerceItemFound
            ? shippingGroupCommerceItem.commerceId === shippingItemRelationships[relationShipId].commerceId &&
                shippingItemRelationships[relationShipId].shippingGroupId === shippingGroupId
            : commerceItemFound.commerceId === shippingItemRelationships[relationShipId].commerceId &&
                shippingItemRelationships[relationShipId].shippingGroupId === shippingGroupId;
        });
        const currentRelationShip = shippingItemRelationships[currentRelationShipId];

        if (!commerceItemFound && !targetShippingGroupId) {
          const items = [];
          const payload = {};
          payload.type = SHIPPING_GROUP_IN_STORE_PICKUP;
          payload.shippingMethod = null;
          payload.locationId = selectedStore.locationId;

          items.push(payload);
          const response = await action('addShippingGroupsToCart', {items});

          if (response.ok) {
            /* 1st find the newly created shipping group by comparing SGs from Old State and latest State */
            const latestShippingGroups = getCurrentOrder(store.getState()).shippingGroups;

            if (Object.keys(latestShippingGroups).length > 0 && skuId) {
              targetShippingGroupId = Object.keys(latestShippingGroups).find(shippingGroupId => {
                return !(shippingGroupId in shippingGroups);
              });
            }
          } else {
            setErrorMessage(response.error ? response.error.message : '');

            return;
          }
        }

        // Check whether new Shipping Group ID and existing Shipping Group ID is same or not
        if (targetShippingGroupId && shippingGroupId !== targetShippingGroupId) {
          // invoke relateShippingGroupsToCartItems action
          const existingRelationShipId = Object.keys(shippingItemRelationships).find(relationShipId => {
            return shippingItemRelationships[relationShipId].shippingGroupId === targetShippingGroupId;
          });
          const existingRelationShip = shippingItemRelationships[existingRelationShipId];

          const payload = getPayloadForSwitchingDeliveryOption({
            relationships,
            currentShippingGroupId: shippingGroupId,
            targetShippingGroupId,
            existingRelationShip,
            currentRelationShip
          });

          action('relateShippingGroupsToCartItems', payload).then(response => {
            if (!response.ok) {
              const newRelationshipItemQuantity = payload.relationships[1].quantity; //New Relationship Quantity
              onNotOk({
                response,
                shippingGroupId: targetShippingGroupId,
                shippingGroups,
                commerceItem,
                skuInventory,
                newRelationshipItemQuantity,
                messageInsufficientStock,
                messageInsufficientStockAtStore,
                setErrorMessage
              });
            } else {
              removeCurrentItemFromInvalidItems({
                shippingGroupId,
                commerceId: commerceItem.id,
                setInvalidItems,
                setInvalidItemsOnQuantityChange
              });
              //Now Update/Correct the quantity of the other Home Delivery based invalid Cart Line items(if any) of the same Sku.
              if (
                (invalidItemsOnQuantityChange &&
                  invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg !== undefined &&
                  invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg[
                    `${shippingGroupId}${shippingGroupCommerceItem.commerceId}`
                  ]) ||
                (shippingGroups[shippingGroupId].type === SHIPPING_GROUP_HARDGOOD &&
                  Object.keys(invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg).some(function (k) {
                    return k.indexOf(shippingGroupCommerceItem.commerceId) > -1;
                  }))
              ) {
                //Pass current order object which has new shipping groups.
                const currentOrder = getCurrentOrder(store.getState());
                updateInvalidCommerceItemsQty({
                  relationships: [],
                  setInvalidItems,
                  commerceId: commerceItem.id,
                  shippingGroupId,
                  setSelections: noop,
                  currentOrder,
                  totalQtyAvailable: defaultSkuInventory['orderableQuantity'],
                  setErrorMessage,
                  setInvalidItemsOnQuantityChange,
                  action,
                  onNotOk
                });
              }
              setSelections(prevState => {
                return {
                  ...prevState,
                  selectedQuantity: payload.relationships[1].quantity
                };
              });
            }

            //Reset isDeliveryMethodChanged property value.
            if (isDeliveryMethodChanged) {
              setDeliveryMethodChanged(setSelections, false);
            }
          });
        }
      }
      validateLinetemQuantity(SHIPPING_GROUP_IN_STORE_PICKUP);
    };

    /**
     * Handles the selection of Home Delivery option for a line item on extended cart.
     */
    const setHomeDeliveryOption = async () => {
      //Reset isDeliveryMethodChanged property value.
      if (isDeliveryMethodChanged) {
        setDeliveryMethodChanged(setSelections, false);
      }
      //check for the 'hardgoodShippingGroup' Shipping Group type if exits
      let targetShippingGroupId = null;
      let commerceItemFound = null;
      if (Object.keys(shippingGroups).length > 0) {
        targetShippingGroupId = Object.keys(shippingGroups).find(shippingGroupId => {
          commerceItemFound = shippingGroups[shippingGroupId].items.find(item => {
            return item.catRefId === skuId && shippingGroups[shippingGroupId].type === SHIPPING_GROUP_HARDGOOD;
          });

          return commerceItemFound;
        });

        if (!commerceItemFound && !targetShippingGroupId) {
          // check for default HGSG exits without this commerce item
          targetShippingGroupId = Object.keys(shippingGroups).find(shippingGroupId => {
            return shippingGroups[shippingGroupId].type === SHIPPING_GROUP_HARDGOOD;
          });
        }
        const currentRelationShipId = Object.keys(shippingItemRelationships).find(relationShipId => {
          return !commerceItemFound
            ? shippingGroupCommerceItem.commerceId === shippingItemRelationships[relationShipId].commerceId &&
                shippingItemRelationships[relationShipId].shippingGroupId === shippingGroupId
            : commerceItemFound.commerceId === shippingItemRelationships[relationShipId].commerceId &&
                shippingItemRelationships[relationShipId].shippingGroupId === shippingGroupId;
        });
        const currentRelationShip = shippingItemRelationships[currentRelationShipId];

        if (!commerceItemFound && !targetShippingGroupId) {
          const items = [];
          const payload = {};
          payload.type = SHIPPING_GROUP_HARDGOOD;
          payload.shippingMethod = null;
          items.push(payload);
          const response = await action('addShippingGroupsToCart', {items});

          if (response.ok) {
            /* 1st find the newly created shipping group by comparing SGs from Old State and latest State */
            const latestShippingGroups = getCurrentOrder(store.getState()).shippingGroups;

            if (Object.keys(latestShippingGroups).length > 0 && skuId) {
              targetShippingGroupId = Object.keys(latestShippingGroups).find(shippingGroupId => {
                return !(shippingGroupId in shippingGroups);
              });
            }
          } else {
            setErrorMessage(response.error ? response.error.message : '');

            return;
          }
        }

        // Check whether new Shipping Group ID and existing Shipping Group ID is same or not
        if (targetShippingGroupId && shippingGroupId !== targetShippingGroupId) {
          // invoke relateShippingGroupsToCartItems action
          const existingRelationShipId = Object.keys(shippingItemRelationships).find(relationShipId => {
            return (
              commerceItemFound &&
              commerceItemFound.commerceId === shippingItemRelationships[relationShipId].commerceId &&
              shippingItemRelationships[relationShipId].shippingGroupId === targetShippingGroupId
            );
          });

          const existingRelationShip = shippingItemRelationships[existingRelationShipId];
          let payload = {};
          //let updateCommerceItemQuantities = true;

          // Before invoking 'relateShippingGroupsToCartItems' action, check whether the merged quantity of
          // current SG item and item quantities from other Home Delivery SGs in cart is within Order-able limit.
          const totalExistingQuantity = getLocationBasedItemQtyFromSGs({
            locationId: 'default',
            shippingGroups,
            skuId: shippingGroupCommerceItem.catRefId,
            shippingGroupId,
            isSplitShipping: true,
            invalidItemsOnQuantityChange: {}
          });
          const totalQtyToValidate = quantityToValidate + totalExistingQuantity;
          if (totalQtyToValidate <= skuInventory['default'].orderableQuantity) {
            payload = getPayloadForSwitchingDeliveryOption({
              relationships,
              currentShippingGroupId: shippingGroupId,
              targetShippingGroupId,
              existingRelationShip,
              currentRelationShip
            });
          } else {
            let maxQuantityAllowedForNewRelatioship = skuInventory['default'].orderableQuantity - totalExistingQuantity;
            maxQuantityAllowedForNewRelatioship =
              currentRelationShip.quantity <= maxQuantityAllowedForNewRelatioship
                ? currentRelationShip.quantity
                : maxQuantityAllowedForNewRelatioship;

            const newRelationship = {
              quantity: existingRelationShip
                ? existingRelationShip.quantity + maxQuantityAllowedForNewRelatioship
                : maxQuantityAllowedForNewRelatioship,
              commerceItemId: currentRelationShip.commerceId,
              shippingGroupId: targetShippingGroupId,
              updateItemQuantity: true
            };

            const currentRelationShipWithQtyZero = {
              quantity: 0,
              commerceItemId: currentRelationShip.commerceId,
              shippingGroupId,
              updateItemQuantity: true
            };
            relationships.push(currentRelationShipWithQtyZero);
            relationships.push(newRelationship);
            payload = {relationships};
          }

          setSelections(prevState => {
            return {
              ...prevState,
              isPickupInStoreOptionSelected: false
            };
          });

          if (shippingGroups[shippingGroupId].type === SHIPPING_GROUP_HARDGOOD) {
            setSelections(prevState => {
              return {
                ...prevState,
                selectedStore: {}
              };
            });
          }

          action('relateShippingGroupsToCartItems', payload).then(response => {
            if (!response.ok) {
              const newRelationshipItemQuantity = payload.relationships[1].quantity;
              onNotOk({
                response,
                shippingGroupId: targetShippingGroupId,
                shippingGroups,
                commerceItem,
                skuInventory,
                newRelationshipItemQuantity,
                messageInsufficientStock,
                messageInsufficientStockAtStore,
                setErrorMessage
              });
            } else {
              //Remove both existing and current SG commerce Item based invalid items
              if (existingRelationShip && existingRelationShip.shippingGroupId) {
                removeCurrentItemFromInvalidItems({
                  shippingGroupId: existingRelationShip.shippingGroupId,
                  commerceId: commerceItem.id,
                  setInvalidItems,
                  setInvalidItemsOnQuantityChange
                });
              }
              removeCurrentItemFromInvalidItems({
                shippingGroupId,
                commerceId: commerceItem.id,
                setInvalidItems,
                setInvalidItemsOnQuantityChange
              });

              setSelections(prevState => {
                return {
                  ...prevState,
                  selectedQuantity: payload.relationships[1].quantity
                };
              });
            }
          });
          //Reset isDeliveryMethodChanged property value.
          if (isDeliveryMethodChanged) {
            setDeliveryMethodChanged(setSelections, false);
          }
        }
      }
      //Reset isDeliveryMethodChanged property value.
      if (isDeliveryMethodChanged) {
        setDeliveryMethodChanged(setSelections, false);
      }
      validateLinetemQuantity(SHIPPING_GROUP_HARDGOOD);
    };

    /**
     * Method to select/change the delivery options for each line of the cart.
     */
    function relateSGsToCartItems() {
      if (isDeliveryMethodChanged && isPickupInStoreOptionSelected && selectedStore.locationId) {
        handleStoreSelection();
      } else if (isDeliveryMethodChanged && !isPickupInStoreOptionSelected) {
        if (selectedStore.locationId) {
          setHomeDeliveryOption();
        } else {
          //If there is no entry in the invalid quantity items, remove the current item from invalid items.
          const itemRef = `${shippingGroupId}${shippingGroupCommerceItem.commerceId}`;
          if (
            invalidItemsOnQuantityChange &&
            invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg &&
            !invalidItemsOnQuantityChange.invalidItemsQtyAndErrorMsg[
              `${shippingGroupId}${shippingGroupCommerceItem.commerceId}`
            ]
          ) {
            setInvalidItems(prevState => {
              let itemRefArrayNewState = prevState && prevState.length > 0 ? [...prevState] : [];
              //Filter Current Item from existing Invalid Item list
              itemRefArrayNewState = itemRefArrayNewState.filter(value => {
                return value !== itemRef;
              });

              return [...itemRefArrayNewState];
            });
          }
        }
      } else if (!isQuantityValidated && isPickupInStoreOptionSelected && selectedStore.locationId) {
        validateLinetemQuantity(SHIPPING_GROUP_IN_STORE_PICKUP);
        setQuantityValidated(setSelections, true);
      }
    }

    relateSGsToCartItems();
  }, [
    action,
    isDeliveryMethodChanged,
    isDeliveryMethodInitialized,
    isPickupInStoreOptionSelected,
    productId,
    selectedStore,
    setSelections,
    shippingGroupCommerceItem,
    shippingGroupId,
    shippingGroups,
    shippingItemRelationships,
    skuId,
    setErrorMessage,
    commerceItem,
    skuInventory,
    messageInsufficientStock,
    errorMessage,
    selectedQuantity,
    quantityToValidate,
    setInvalidItems,
    store,
    messageInsufficientStockAtStore,
    setInvalidItemsOnQuantityChange,
    currentOrder,
    defaultSkuInventory,
    invalidItemsOnQuantityChange,
    isQuantityValidated
  ]);

  return (
    <>
      {displayDeliveryOptions ? (
        /** Displays the Delivery Options to be selected for current Cart Line Item in case of Extended Cart */
        <ProductDeliveryOptions {...props} />
      ) : (
        /** Displays the Selected Store and link to change the store for current Cart Line Item in case of Extended Cart */
        <InStorePickupSelector {...props} />
      )}
    </>
  );
};

export default ExtendedCartItemDeliveryOptions;
