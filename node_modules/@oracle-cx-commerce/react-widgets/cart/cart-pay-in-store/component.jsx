/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useEffect, useRef, useState} from 'react';
import {
  deleteAppliedPaymentsByTypes,
  getPaymentGroupsByTypes,
  validatePaymentsEnabled
} from '@oracle-cx-commerce/react-components/utils/payment';

import ConfirmationDialog from '@oracle-cx-commerce/react-components/confirmation-dialog';
import {PAYMENT_TYPE_PAY_IN_STORE} from '@oracle-cx-commerce/commerce-utils/constants';
import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import Styled from '@oracle-cx-commerce/react-components/styled';
import {connect} from '@oracle-cx-commerce/react-components/provider';
import css from '@oracle-cx-commerce/react-widgets/cart/cart-pay-in-store/styles.css';
import {fetchPaymentConfigurations} from '@oracle-cx-commerce/fetchers/payments';
import {getComponentData} from '@oracle-cx-commerce/react-widgets/cart/cart-pay-in-store/selectors';
import {getCurrentOrder} from '@oracle-cx-commerce/commerce-utils/selector';
import {isEmptyObject} from '@oracle-cx-commerce/utils/generic';
import {useNavigator} from '@oracle-cx-commerce/react-components/link';
import {useOrderApprovalRequired} from '@oracle-cx-commerce/react-components/utils/payment/hooks';
import {usePaymentConfigurationsFetcher} from '@oracle-cx-commerce/fetchers/payments/hooks';
import PropTypes from 'prop-types';

//constants
const ERROR = 'error',
  INFO = 'info',
  CHECKOUT_REVIEW_ORDER = 'checkout-review-order';

/**
  Export payment configurations fetcher so that the server can use them to load state during 
  server-side rendering.
 */
export const fetchers = [fetchPaymentConfigurations];

/**
 * This component is a button which appears if all the cart items are being picked up
 * in single store and a store has been selected
 * It provide functionality to apply pay in store payment and navigate user directly to the order review page
 * @param {Object} props properties object
 */
const CartPayInStore = props => {
  const [isInProgress, setIsInProgress] = useState(false);
  const [showConfirmationDialog, setShowConfirmationDialog] = useState(false);
  const store = useContext(StoreContext);
  const {action, getState} = store;
  const payInStoreButtonRef = useRef(null);
  const goToPage = useNavigator();
  const [isApprovalRequired, setIsApprovalRequired] = useState(false);
  const {
    alertInstorePaymentApplied,
    currentOrderId,
    id,
    isApprovalEnabled = false,
    isDisplayCartPayInStore,
    isPaymentMethodEnabledForApproval,
    isPayAfterApprovalSelected,
    actionConfirm,
    headingConflictingPaymentMethods,
    actionCancel,
    alertForInstorePaymentWhenOtherPaymentsApplied,
    alertDoYouWantToPayInStore,
    closeLinkAltText,
    actionPayInStore,
    PaymentInfoForScheduledOrder
  } = props;

  const orderApproval = useOrderApprovalRequired();
  useEffect(() => {
    if (!isEmptyObject(orderApproval)) {
      if (orderApproval.requiresApproval) {
        setIsApprovalRequired(true);
      } else {
        setIsApprovalRequired(false);
      }
    }
  }, [orderApproval]);

  /**
   * This will set isPayAfterApprovalSelected in state.
   */
  const setPayAfterApprovalSelected = useCallback(
    value => {
      action('saveComponentData', {
        orders: {[currentOrderId]: {isPayAfterApprovalSelected: value}}
      });
    },
    [action, currentOrderId]
  );
  // Calls usePaymentConfigurations Fetcher hook to load the payment configurations data into the state
  // This will not perform any action if the payment configuration is already part of the state.
  usePaymentConfigurationsFetcher(store);

  /**
   * This method applies pay in store payment method to the order.
   * And navigate user to the order summary page on success.
   */
  const applyPayInStore = useCallback(async () => {
    const payload = {
      items: [
        {
          type: PAYMENT_TYPE_PAY_IN_STORE
        }
      ]
    };
    setIsInProgress(true);
    const response = await action('applyPayments', payload);
    setIsInProgress(false);
    if (response.ok) {
      action('notifyClearAll');
      action('notify', {level: INFO, message: alertInstorePaymentApplied});
      goToPage(CHECKOUT_REVIEW_ORDER);
    } else {
      action('notifyClearAll');
      action('notify', {level: ERROR, message: response.error.message});
    }
  }, [action, alertInstorePaymentApplied, goToPage]);

  /**
   * This method verifies if pay in store payment conflict with any other payment type.
   * If so then it opens conflict dialog otherwise proceed to apply pay in store payment group
   * if no payment group already applied
   */
  const onPayInStoreClick = () => {
    const paymentGroups = getPaymentGroupsByTypes(getCurrentOrder(getState()));
    if (paymentGroups.some(pGroup => pGroup.paymentMethod !== PAYMENT_TYPE_PAY_IN_STORE)) {
      setShowConfirmationDialog(true);
    } else if (paymentGroups.some(pGroup => pGroup.paymentMethod === PAYMENT_TYPE_PAY_IN_STORE)) {
      goToPage(CHECKOUT_REVIEW_ORDER);
    } else if (isPayAfterApprovalSelected) {
      setPayAfterApprovalSelected(false);
      applyPayInStore();
    } else {
      applyPayInStore();
    }
  };

  /**
   * Success callback function to be invoked on confirm button click on
   * confirmation dialog
   * @param response the response
   */
  const confirmCallback = useCallback(async () => {
    const response = await deleteAppliedPaymentsByTypes(store);
    setShowConfirmationDialog(false);
    //set focus to button once confirmation dialog is closed
    payInStoreButtonRef && payInStoreButtonRef.current && payInStoreButtonRef.current.focus();
    if (response.ok) {
      applyPayInStore();
    } else {
      store.action('notifyClearAll');
      store.action('notify', {level: ERROR, message: response.error.message});
    }
  }, [applyPayInStore, store]);

  /**
   * Cancel callback function to be invoked on cancel button click on
   * confirmation dialog
   */
  const cancelCallback = useCallback(() => {
    setShowConfirmationDialog(false);
    //set focus to button once confirmation dialog is closed
    payInStoreButtonRef && payInStoreButtonRef.current && payInStoreButtonRef.current.focus();
  }, []);

  //Button UI along with confirmation dialog reference
  return (
    isDisplayCartPayInStore &&
    validatePaymentsEnabled(
      isApprovalRequired,
      isApprovalEnabled,
      isPaymentMethodEnabledForApproval,
      PaymentInfoForScheduledOrder
    ) && (
      <Styled id="CartPayInStore" css={css}>
        <ConfirmationDialog
          id={id}
          title={headingConflictingPaymentMethods}
          closeAriaLabel={closeLinkAltText}
          closeIconTitle={closeLinkAltText}
          alertMessage={alertForInstorePaymentWhenOtherPaymentsApplied}
          confirmMessage={alertDoYouWantToPayInStore}
          labelConfirm={actionConfirm}
          labelCancel={actionCancel}
          confirmCallback={confirmCallback}
          cancelCallback={cancelCallback}
          closeCallback={cancelCallback}
          show={showConfirmationDialog}
        />
        <div className="CartPayInStore">
          <button
            type="button"
            ref={payInStoreButtonRef}
            disabled={isInProgress}
            className="secondary"
            onClick={onPayInStoreClick}
          >
            {actionPayInStore}
          </button>
        </div>
      </Styled>
    )
  );
};

CartPayInStore.propTypes = {
  /**
   * The unique id for the component
   */
  id: PropTypes.string.isRequired,

  /**
   * Indicates if approval is enabled
   */
  isApprovalEnabled: PropTypes.bool,

  /**
   * Indicates if payment method is enabled for approval
   */
  isPaymentMethodEnabledForApproval: PropTypes.bool.isRequired,

  /**
   * Indicates if pay after approval is selected
   */
  isPayAfterApprovalSelected: PropTypes.bool.isRequired,

  /**
   * Current order Id
   */
  currentOrderId: PropTypes.string.isRequired,

  /**
   * Flag to control display of component UI
   */
  isDisplayCartPayInStore: PropTypes.bool.isRequired
};

/**
 * Default values for props
 */
CartPayInStore.defaultProps = {
  isApprovalEnabled: false
};

export default connect(getComponentData)(CartPayInStore);
