/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useEffect, useMemo, useState} from 'react';

import ChildCollectionCard from '@oracle-cx-commerce/react-widgets/category/collection-navigation/components/child-collection-card';
import {CollectionNavContext} from '@oracle-cx-commerce/react-widgets/category/collection-navigation/context';
import {MenuMobileContext} from '@oracle-cx-commerce/react-widgets/common/menu-mobile/context';
import PropTypes from 'prop-types';
import RootCollectionCard from '@oracle-cx-commerce/react-widgets/category/collection-navigation/components/root-collection-card';
import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import Styled from '@oracle-cx-commerce/react-components/styled';
import css from '@oracle-cx-commerce/react-widgets/category/collection-navigation/styles.css';
import {fetchMenuCategories} from '@oracle-cx-commerce/react-widgets/category/collection-navigation/fetcher';
import {getCategories} from '@oracle-cx-commerce/commerce-utils/selector';
import {getData} from '@oracle-cx-commerce/react-widgets/category/collection-navigation/utils';
import {useMenuCategoriesFetcher} from '@oracle-cx-commerce/react-widgets/category/collection-navigation/hook';
import { useSelector } from '@oracle-cx-commerce/react-components/provider';

export const fetchers = [fetchMenuCategories];

/**
 * CollectionNavigation Widget - Provides menu cards that represent the collections.
 * Default view is the root-collection-card and child collections are represented by child-collection-card.
 * There's 1 root card and then n child cards, n being the number of child collections in the system.
 *
 * @param props
 */
const CollectionNavigation = props => {
  const {
    regions = [],
    labelMainMenu,
    labelShopByDepartment,
    labelViewAll,
    labelAllDepartments,
    viewAllOption = true
  } = props;

  let {numberOfChildCategoriesToDisplay = '2'} = props;
  numberOfChildCategoriesToDisplay = parseInt(numberOfChildCategoriesToDisplay, 10);

  const store = useContext(StoreContext);

  // Fetch the categories (if not present in the state already due to the fetcher)
  useMenuCategoriesFetcher(store, props);

  const categories = useSelector(getCategories);
  const {rootCategories, secondaryCategories} = useSelector(getData);

  const noOfMenuCards = useMemo(() => secondaryCategories.length, [secondaryCategories.length]);
  const [childrenVisible, setChildrenVisible] = useState(new Array(noOfMenuCards).fill(false));
  const [childCardDisplayInfo, setChildCardDisplayInfo] = useState([]); //use to get the previous category name and to know the order cards were shown

  const {toggleMenu, isVisible, hideParentViewFromA11y, menuOpen} = useContext(MenuMobileContext);

  // Reset all the sub category cards to unchecked to hide them
  const resetToRoot = useCallback(() => {
    setChildrenVisible(checkedChildren =>
      Object.keys(checkedChildren).reduce((acc, key) => {
        acc[key] = false;

        return acc;
      }, {})
    );
    setChildCardDisplayInfo([]);
    hideParentViewFromA11y(false);
  }, [hideParentViewFromA11y]);

  // reset the child cards to all be hidden
  useEffect(() => {
    resetToRoot();
  }, [resetToRoot, menuOpen]);

  // On change to visibility of the child cards
  const onCardVisibilityChange = useCallback(
    (index, visible, id, displayName) => {
      setChildrenVisible(checkedChildren => ({...checkedChildren, [index]: visible}));

      const addItemToVisibleList = (id, displayName, index) => {
        // find the previous entry
        const previousMenuCard =
          childCardDisplayInfo.length > 0 ? childCardDisplayInfo[childCardDisplayInfo.length - 1] : {displayName: null};

        return {id, index, parentCategoryText: previousMenuCard.displayName, displayName};
      };

      const updatedChildCardDisplayInfo = visible
        ? [...childCardDisplayInfo, addItemToVisibleList(id, displayName, index)]
        : childCardDisplayInfo.slice(0, -1);

      // Lets the parent component know that their are views overlaid and therefore it is hidden from view.
      hideParentViewFromA11y(updatedChildCardDisplayInfo.length > 0);

      // update the list of displayed cards
      setChildCardDisplayInfo(updatedChildCardDisplayInfo);
    },
    [childCardDisplayInfo, hideParentViewFromA11y]
  );

  // Gets the name of the parent category
  const getParentCategoryDisplayName = useCallback(
    id => {
      if (childCardDisplayInfo.length > 1) {
        const {parentCategoryText = ''} = childCardDisplayInfo.find(card => card.id === id) || {};

        return parentCategoryText;
      }
    },
    [childCardDisplayInfo]
  );

  // Indicates whether the child card should show the child category indicator
  const shouldHideChildCategoryIndicator = useCallback(
    id => {
      //find position of card in the array, then check if the index exceeds the max no of child categories
      const index = childCardDisplayInfo.map(category => category.id).indexOf(id);

      return index >= numberOfChildCategoriesToDisplay - 1;
    },
    [childCardDisplayInfo, numberOfChildCategoriesToDisplay]
  );

  // Indicates whether the child card should be hidden to the left of the screen
  const shouldCardBeHiddenToTheLeft = useCallback(
    childCardIndex => {
      if (!menuOpen) return false;

      // if the child card hasn't been displayed then this isn't relevant
      if (!childrenVisible[childCardIndex]) return false;

      // check the displayed cards for the one on the top, it is the only not to be slid to the side
      return childCardIndex !== childCardDisplayInfo[childCardDisplayInfo.length - 1].index;
    },
    [childCardDisplayInfo, childrenVisible, menuOpen]
  );

  // On navigation to a category
  const onNavigateToCategory = useCallback(() => {
    toggleMenu(false);
  }, [toggleMenu]);

  // check whether a child card is visible on screen
  const isCardVisible = useCallback(
    (cardIndex = -1) => {
      // menu closed, so card not visible
      if (!menuOpen) return false;

      // check whether the parent view is visible
      if (cardIndex === -1) return isVisible();

      // if the card hasn't been shown, then it's definitely not visible
      if (!childrenVisible[cardIndex]) return false;

      // By this point we know the card is on the stack but only the last one is visible
      return cardIndex === childCardDisplayInfo[childCardDisplayInfo.length - 1].index;
    },
    [childCardDisplayInfo, childrenVisible, isVisible, menuOpen]
  );

  // create the context for the menu cards
  const context = {
    config: {
      labelMainMenu,
      labelShopByDepartment,
      labelViewAll,
      labelAllDepartments,
      viewAllOption,
      numberOfChildCategoriesToDisplay,
      regions
    },
    visibleCards: childrenVisible,
    onCardVisibilityChange,
    getParentCategoryDisplayName,
    shouldHideChildCategoryIndicator,
    closeChildCards: resetToRoot,
    onNavigateToCategory,
    shouldCardBeHiddenToTheLeft,
    isCardVisible
  };


  return (
    <Styled id="CollectionNavigation" css={css}>
      <CollectionNavContext.Provider value={context}>
        <div className="CollectionNavigation">
          <RootCollectionCard categories={rootCategories} />

          {secondaryCategories.map((categoryId, i) => {
            return <ChildCollectionCard key={categoryId} category={categories[categoryId]} index={i} />;
          })}
        </div>
      </CollectionNavContext.Provider>
    </Styled>
  );
};

CollectionNavigation.propTypes = {
  /** Regions configured in the surrounding container, comes from the Redux state */
  regions: PropTypes.arrayOf(PropTypes.object),
  /** Flag indicating whether to show a "View all" link in the categories */
  viewAllOption: PropTypes.bool,
  /** Number of child categories to display */
  numberOfChildCategoriesToDisplay: PropTypes.string
};

CollectionNavigation.defaultProps = {
  regions: [],
  viewAllOption: true,
  numberOfChildCategoriesToDisplay: '2'
};

export default CollectionNavigation;
