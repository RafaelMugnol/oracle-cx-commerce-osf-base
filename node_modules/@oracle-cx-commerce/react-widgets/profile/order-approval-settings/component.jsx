/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useEffect, useState} from 'react';

import CancelSaveActions from '@oracle-cx-commerce/react-widgets/profile/add-or-edit-account-contact/components/cancel-save-actions';
import Form from '@oracle-cx-commerce/react-components/form';
import PropTypes from 'prop-types';
import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import Styled from '@oracle-cx-commerce/react-components/styled';
import ToggleSwitch from '@oracle-cx-commerce/react-components/toggle-switch';
import {WARNING_ICON_HTML} from '@oracle-cx-commerce/react-components/form/constants';
import {connect} from '@oracle-cx-commerce/react-components/provider';
import css from '@oracle-cx-commerce/react-widgets/profile/order-approval-settings/styles.css';
import {formToJson} from '@oracle-cx-commerce/react-components/utils';
import {getComponentData} from '@oracle-cx-commerce/react-widgets/profile/order-approval-settings/selectors';
import {getOrganizations} from '@oracle-cx-commerce/commerce-utils/selector';
import {noop} from '@oracle-cx-commerce/utils/generic';

const NUMERIC_STRING_PATTERN = /^[0-9]+(\.[0-9]+)?$/;

/**
 * Displays Purchase limit section and the corresponding field description text.
 * @param {Object} props
 */
const PurchaseLimit = props => {
  const {labelPurchaseLimit, orderPriceLimit, helpText, priceListGroup, readOnly, disabled, currencyCode} = props;
  const {currency = {}, displayName} = priceListGroup;

  const currencyCodeToDisplay = currency.currencyCode || currencyCode;

  return (
    <>
      <div className="PurchaseLimit__InputCurrencyContainer">
        <div className="PurchaseLimit__Input">
          <label htmlFor="purchase-limit">{labelPurchaseLimit}</label>
          <input
            type="text"
            id="purchase-limit"
            name="orderPriceLimit"
            defaultValue={orderPriceLimit}
            readOnly={readOnly}
            aria-readonly={readOnly}
            disabled={disabled}
          ></input>
          <span className="validationMessage"></span>
        </div>
        <div className="PurchaseLimit__CurrencyDetails">{`${currencyCodeToDisplay} (${displayName})`}</div>
      </div>
      <div className="PurchaseLimit__HelpMessage">{helpText}</div>
    </>
  );
};

/**
 * Displays requires approval toggle switch
 * @param {Object} props
 */
const RequiresApprovalSwitch = props => {
  const {labelRequiresApproval, readOnly, approvalRequired, onChangeHandler} = props;

  return (
    <div className="RequiresApprovalSwitch__Section">
      <ToggleSwitch
        id="requires-approval-switch"
        className="RequiresApprovalSwitch__ToggleSwitch"
        name="approvalRequired"
        label={labelRequiresApproval}
        value={approvalRequired}
        isOn={approvalRequired}
        onChange={onChangeHandler}
        readOnly={readOnly}
        aria-readonly={readOnly}
      />
      <label htmlFor="requires-approval-switch" className="RequiresApprovalSwitch__Text">
        {labelRequiresApproval}
      </label>
    </div>
  );
};

const OrderApprovalSettings = props => {
  const {
    currentOrganizationId,
    delegateApprovalManagement: isEditable,
    orderPriceLimit,
    isDelegatedAdmin,
    approvalRequired,
    headingOrderApprovalSettings,
    labelRequiresApproval,
    labelPurchaseLimit,
    labelCancel,
    actionSave,
    textPurchaseLimitFieldInformation,
    textMerchantRequiredPurchaseLimit,
    priceListGroup,
    messageUpdateSuccessfullySaved,
    textInvalidPurchaseLimit,
    currencyCode
  } = props;
  const {action, getState} = useContext(StoreContext);
  const [isApprovalReqired, setIsApprovalReqired] = useState(approvalRequired);

  useEffect(() => {
    if (orderPriceLimit === undefined) {
      action('getOrganization', {organizationId: currentOrganizationId})
        .then(response => {
          if (response.ok) {
            const currentOrg = getOrganizations(getState())[currentOrganizationId];
            setIsApprovalReqired(currentOrg.approvalRequired);
          }
          if (response.error) {
            action('notify', {level: 'error', message: response.error.message});
          }
        })
        .catch(error => {
          action('notify', {level: 'error', message: error.message || error});
        });
    }
  }, [action, currentOrganizationId, getState, orderPriceLimit]);

  /**
   * Validate element to set any custom errors
   * @param {Object} The element to validate
   * @param {function} The function to validate element
   */
  const setElementValidity = useCallback((element, validator) => {
    element.setCustomValidity('');

    if (validator) {
      if (element.name === 'orderPriceLimit') {
        element.setCustomValidity(validator(element.value));
      }
    }

    const {nextElementSibling} = element;
    if (element.willValidate && nextElementSibling && nextElementSibling.matches('.validationMessage')) {
      nextElementSibling.textContent = element.validationMessage;
      if (element.validationMessage) {
        nextElementSibling.insertAdjacentHTML('afterbegin', WARNING_ICON_HTML);
      }
    }
  }, []);

  /**
   * Validates purchase limit input field.
   * @param {String} invalidMessage The message to display when invalid input
   * @param {String} fieldValue The value of the input element
   */
  const customPurchaseLimitValidity = invalidMessage => fieldValue => {
    if (!(NUMERIC_STRING_PATTERN.test(fieldValue) || fieldValue === '')) {
      return invalidMessage;
    }

    return '';
  };

  /**
   * This method validates value for form purchase limit input field by passing
   * respective validation method to the custom setCustomValidity method
   * @param {Object} element ui element
   */
  const setCustomValidity = useCallback(
    element => {
      if (element.name === 'orderPriceLimit') {
        setElementValidity(element, customPurchaseLimitValidity(textInvalidPurchaseLimit));
      }
    },
    [setElementValidity, textInvalidPurchaseLimit]
  );

  /**
   * This method handles change of require approval toggle switch
   * when delegated admin is allowed to manage approval settings
   * @param {Object} element ui element
   */
  const requireApprovalChangeHandler = useCallback(
    event => {
      setIsApprovalReqired(event.target.checked);
    },
    [setIsApprovalReqired]
  );

  const onFormSubmitHandler = event => {
    event.preventDefault();
    const payload = formToJson(event.target);
    const {orderPriceLimit} = payload;
    payload.orderPriceLimit = orderPriceLimit === '' ? null : orderPriceLimit;
    action('updateOrganization', payload)
      .then(response => {
        if (response.ok) {
          action('notify', {level: 'success', message: messageUpdateSuccessfullySaved});
        }
        if (response.error) {
          action('notify', {level: 'error', message: response.error.message});
        }
      })
      .catch(error => {
        action('notify', {level: 'error', message: error.message || error});
      });
  };

  return (
    <Styled id="OrderApprovalSettings" css={css}>
      <div className="OrderApprovalSettings">
        <h1>{headingOrderApprovalSettings}</h1>

        {isDelegatedAdmin && (
          <div>
            <div>{textMerchantRequiredPurchaseLimit}</div>
            <Form onSubmit={onFormSubmitHandler} setCustomValidity={setCustomValidity} noValidate>
              <input type="hidden" value={currentOrganizationId} name="organizationId" />
              <RequiresApprovalSwitch
                approvalRequired={isApprovalReqired}
                labelRequiresApproval={labelRequiresApproval}
                readOnly={!isEditable}
                onChangeHandler={isEditable ? requireApprovalChangeHandler : noop}
              />
              <PurchaseLimit
                labelPurchaseLimit={labelPurchaseLimit}
                orderPriceLimit={orderPriceLimit}
                helpText={textPurchaseLimitFieldInformation}
                priceListGroup={priceListGroup}
                readOnly={!isEditable || !isApprovalReqired}
                disabled={isEditable && !isApprovalReqired}
                currencyCode={currencyCode}
              />
              {isEditable && <CancelSaveActions labelCancel={labelCancel} actionSave={actionSave} />}
            </Form>
          </div>
        )}
      </div>
    </Styled>
  );
};

OrderApprovalSettings.propTypes = {
  /**
   * Flag to indicate if the current logged in user is having role of Delegated Admin in the current organization.
   */
  isDelegatedAdmin: PropTypes.bool.isRequired,
  /**
   * Current organization ID of the logged-in user.
   */
  currentOrganizationId: PropTypes.string.isRequired,
  /**
   * Flag to indicate that delegated admin is allowed to manage approval settings.
   * Value can be found in ProfileRepository->organizations[organizationId] object in redux state.
   */
  delegateApprovalManagement: PropTypes.bool.isRequired,
  /**
   * Order price limit for the current organization
   * Value can be found in ProfileRepository->organizations[organizationId] object in redux state.
   */
  orderPriceLimit: PropTypes.number,
  /**
   * Is approval required for the current organization.
   * Value can be found in ProfileRepository->organizations[organizationId] object in redux state.
   */
  approvalRequired: PropTypes.bool.isRequired,
  /**
   * Current Price list group object as obtained from SiteRepository -> sites -> siteId -> priceListGroupList[index] redux state.
   */
  priceListGroup: PropTypes.shape({
    displayName: PropTypes.string.isRequired,
    currency: PropTypes.shape({
      currencyCode: PropTypes.string.isRequired
    }).isRequired
  }).isRequired
};

OrderApprovalSettings.defaultProps = {
  orderPriceLimit: undefined
};

export default connect(getComponentData)(OrderApprovalSettings);
