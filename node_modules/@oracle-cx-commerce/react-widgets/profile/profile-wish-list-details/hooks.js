/*
 ** Copyright (c) 2021 Oracle and/or its affiliates.
 */

import {StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import {useCallback, useEffect, useMemo, useRef, useState, useContext} from 'react';
import {useSelector} from '@oracle-cx-commerce/react-components/provider';
import {getWishList, access} from '@oracle-cx-commerce/commerce-utils/selector/wishlists';
import {getPage, getProduct} from '@oracle-cx-commerce/commerce-utils/selector';

/**
 * Hook to fetch and transform all the data to be rendered on the details page
 */

export const useWishListData = (sortOptions = {}, isProductDeleted = false) => {
  const wishListId = useSelector(getPage).contextId;
  const wishList = useSelector(getWishList, {id: wishListId});
  const {siteId} = useSelector(access);
  const {productsOrder = []} = wishList;
  const store = useContext(StoreContext);
  const {action, getState} = store;

  const wishListProductIds = useMemo(() => {
    const wishListProductIds = [];

    Object.values(wishList.products || {}).forEach(item => {
      if (item.productProductId) wishListProductIds.push(item.productProductId);
    });

    return wishListProductIds;
  }, [wishList.products]);

  const [selectedSort, setSelectedSort] = useState(`${sortOptions[0].sortTerm}:${sortOptions[0].order}`);
  const [fetchingData, setFetchingData] = useState(true);
  const [transformedList, setTransformedList] = useState([]);
  const count = useRef(0);

  const onNotOk = useCallback(
    ({error: {message = ''} = {}} = {}) => {
      action('notify', {level: 'error', message});
    },
    [action]
  );

  /**
   * Method to fetch the details of a wishlist
   */

  const fetchWishListDetails = useCallback(async () => {
    setFetchingData(false);
    try {
      const payload = {
        wishlistId: wishListId,
        query: {offset: 0, limit: 12, orderBy: selectedSort}
      };
      //TODO: Invalid WL id scenario
      const response = await action('getWishlist', payload);
      if (response.ok === false) {
        onNotOk(response);
      }
    } catch (error) {
      console.error(error);
    }
  }, [action, onNotOk, selectedSort, wishListId]);

  /**
   * Method to reorder or reset the products in transformedList
   */
  const resetTransformedList = useCallback(
    pathFound => {
      const wishListProducts = [];
      Array.from(productsOrder).forEach(contentId => {
        const item = wishList.products[contentId];
        const wishListItem = {
          catRefId: item.productSkuId,
          quantityDesired: item.productDesiredQuantity,
          productId: item.productProductId,
          productName: item.productTitle,
          thumbnailUrl: item.productUrl,
          price: item.productPrice,
          currency: item.productCurrencyCode,
          priority: item.productDesiredPriority !== '' ? item.productDesiredPriority : 1,
          contentId,
          comments: item.replies,
          selectedOptions:
            item.productVariantOptions &&
            JSON.parse(item.productVariantOptions) &&
            JSON.parse(item.productVariantOptions).length > 0
              ? JSON.parse(item.productVariantOptions)
              : null,
          path:
            pathFound || getProduct(getState(), {productId: item.productProductId}).route
              ? getProduct(getState(), {productId: item.productProductId}).route
              : ''
        };
        wishListProducts.push(wishListItem);
      });
      setTransformedList(wishListProducts);
    },
    [getState, productsOrder, wishList.products]
  );

  /**
   * Transform wishList data from state to display in the UI
   */
  useMemo(() => {
    if (
      wishList &&
      wishList.products &&
      Object.keys(wishList.products).length !== 0 &&
      productsOrder &&
      productsOrder.length > 0
    ) {
      resetTransformedList(false);
    }
  }, [wishList, productsOrder, resetTransformedList]);

  useEffect(() => {
    if (siteId && !isProductDeleted && fetchingData) {
      fetchWishListDetails();
    }
    if (wishListProductIds && wishListProductIds.length !== 0 && count.current === 0) {
      count.current++;
      action('listProducts', {productIds: wishListProductIds}).then(response => {
        if (response.ok === false) {
          onNotOk(response);
        } else {
          resetTransformedList(true);
        }
      });
    }
  }, [
    action,
    fetchWishListDetails,
    fetchingData,
    isProductDeleted,
    onNotOk,
    resetTransformedList,
    siteId,
    wishList,
    wishListProductIds
  ]);

  return {
    selectedSort,
    setSelectedSort,
    fetchingData,
    setFetchingData,
    transformedList,
    setTransformedList
  };
};
