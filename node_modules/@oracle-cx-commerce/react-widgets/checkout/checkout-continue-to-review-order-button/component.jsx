/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {useNavigator} from '@oracle-cx-commerce/react-components/link';
import React, {useContext, useState} from 'react';
import {PaymentsContext, StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import {connect} from '@oracle-cx-commerce/react-components/provider';
import {getCurrentOrder} from '@oracle-cx-commerce/commerce-utils/selector';
import Styled from '@oracle-cx-commerce/react-components/styled';
import css from '@oracle-cx-commerce/react-widgets/checkout/checkout-continue-to-review-order-button/styles.css';
import {isEmptyObject} from '@oracle-cx-commerce/utils/generic';
import {
  deleteAppliedPaymentsByTypes,
  deleteAppliedPaymentsByIds,
  getAmountRemainingPaymentGroup,
  isPaymentDetailsComplete,
  isZeroValueOrder
} from '@oracle-cx-commerce/react-components/utils/payment';
import {
  PAYMENT_STATE_INITIAL,
  PAYMENT_TYPE_PAY_IN_STORE,
  PAYMENT_TYPE_STORECREDIT,
  PAYMENT_TYPE_GIFTCARD,
  PAYMENT_TYPE_LOYALTYPOINTS,
  PAYMENT_TYPE_PAY_LATER
} from '@oracle-cx-commerce/commerce-utils/constants';
import PropTypes from 'prop-types';

const ERROR = 'error';

/**
 * Widget for Continue To Review Order button, navigates to review order page on click after applying selected payment.
 * @param props
 */
const CheckoutContinueToReviewOrderButton = props => {
  const {continueToPageAddress, actionContinueToReviewOrder, paymentGroups = {}} = props;
  const {payments = [], selectedPaymentType} = useContext(PaymentsContext) || {};
  const store = useContext(StoreContext);
  const {action, getState} = store;
  //these payments can be combined with some other payment type like credit card, gift card etc.
  //so these payment type should not be deleted while applying new compatible payment type
  const compatiblePaymentTypes = [PAYMENT_TYPE_GIFTCARD, PAYMENT_TYPE_LOYALTYPOINTS, PAYMENT_TYPE_STORECREDIT];

  const [inProgress, setInProgress] = useState(false);

  const goToPage = useNavigator();

  /**
   * Navigates to the review order page
   */
  const goToReviewOrderPage = () => {
    const pageAddress = continueToPageAddress.split('/');
    const pageName = pageAddress.length > 1 ? pageAddress[1] : pageAddress[0];
    goToPage(pageName);
  };

  /**
   * Invokes apply payment action on the passed in payments payload.
   * @param paymentsToApply Array The payments to be applied
   */
  const applyPayments = paymentsToApply => {
    if (paymentsToApply.length > 0) {
      action('applyPayments', {items: paymentsToApply}).then(response => {
        if (response.ok) {
          const order = getCurrentOrder(getState());
          // If entered payment details is complete, navigate to the review order page
          if (isPaymentDetailsComplete(order)) {
            goToReviewOrderPage();
          }
          setInProgress(false);
        } else {
          action('notify', {level: ERROR, message: response.error.message});
          setInProgress(false);
        }
      });
    } else if (isPaymentDetailsComplete(props)) {
      goToReviewOrderPage();
    }
  };

  /**
   * This method removes applied payment groups from order which are not applicable
   * @param payments {Array} The payments(from payment context) to be processed
   */
  const removeNotApplicablePaymentGroups = async payments => {
    let isError = false;
    if (payments.some(payment => payment.type === PAYMENT_TYPE_PAY_IN_STORE)) {
      //delete all payments as we are about to add in store payment and there is already non in store payment applied
      if (Object.values(paymentGroups).some(pGroup => pGroup.paymentMethod !== PAYMENT_TYPE_PAY_IN_STORE)) {
        const response = await deleteAppliedPaymentsByTypes(store);
        if (!response.ok) {
          action('notify', {level: ERROR, message: response.error.message});
          isError = true;
        }
      }
    } else {
      //get payment group ids to be deleted
      const paymentGroupsToRemoved = Object.values(paymentGroups)
        .filter(
          pGroup =>
            pGroup.paymentState === PAYMENT_STATE_INITIAL &&
            !compatiblePaymentTypes.includes(pGroup.paymentMethod) &&
            !payments.some(payment => payment.paymentGroupId === pGroup.paymentGroupId)
        )
        .map(pGroup => pGroup.paymentGroupId);

      if (paymentGroupsToRemoved.length) {
        const response = await deleteAppliedPaymentsByIds(action, paymentGroupsToRemoved);
        if (!response.ok) {
          action('notify', {level: ERROR, message: response.error.message});
          isError = true;
        }
      }
    }

    return isError;
  };

  /**
   * Processes the payments in the context
   * Updates the payment group if the payment in the context has an paymentGroupId
   * or calls the apply payments to apply the payment in the context.
   * @param payments Array The payments to be processed
   */
  const processPayments = async payments => {
    const paymentsToApply = [];
    let isError = false;
    isError = await removeNotApplicablePaymentGroups(payments);
    if (isError) {
      setInProgress(false);

      return;
    }
    for (const payment of payments) {
      const {paymentGroupId, ...paymentDetails} = payment;
      const existingPaymentGroup = paymentGroups[paymentGroupId];
      if (paymentGroupId && existingPaymentGroup) {
        // Remove existing applied credit card payment group and reapply if
        // a different saved card has been selected, or
        // selection has been changed from saved card to a newly entered card(not saved) or
        // selection has been changed from newly entered card(not saved) to a saved card
        if (
          (payment.savedCardId &&
            existingPaymentGroup.savedCardId &&
            payment.savedCardId !== existingPaymentGroup.savedCardId) ||
          (!existingPaymentGroup.savedCardId && payment.savedCardId) ||
          (existingPaymentGroup.savedCardId && !payment.savedCardId)
        ) {
          const response = await action('deleteAppliedPayment', {paymentGroupId});
          if (response.ok) {
            paymentsToApply.push(paymentDetails);
          } else {
            action('notify', {level: ERROR, message: response.error.message});
            isError = true;
            setInProgress(false);
            break;
          }
        } else {
          // If there is a payment group with saved card id , only the cvv can be updated
          // Type and seqNum properties are not required for updating an existing payment group
          const {savedCardId, type, seqNum, ...paymentDetailsToUpdate} = paymentDetails;
          // If there is addressType property in billingAddress it can't be patched.
          if (paymentDetailsToUpdate.billingAddress) {
            const {
              billingAddress: {addressType, ...billingAddressDetails}
            } = paymentDetailsToUpdate;
            paymentDetailsToUpdate.billingAddress = billingAddressDetails;
          }
          if (!isEmptyObject(paymentDetailsToUpdate)) {
            const paymentGroupToUpdate = {paymentGroupId, ...paymentDetailsToUpdate};
            const updateAppliedPaymentResponse = await action('updateAppliedPayment', paymentGroupToUpdate);
            if (!updateAppliedPaymentResponse.ok) {
              action('notify', {level: ERROR, message: updateAppliedPaymentResponse.error.message});
              isError = true;
              setInProgress(false);
              break;
            }
          }
        }
      } else {
        paymentsToApply.push(paymentDetails);
      }
    }
    if (!isError) {
      applyPayments(paymentsToApply);
    }
  };

  /**
   * Handler for continue to review order button
   */
  const onContinueToReviewOrder = () => {
    action('notifyClearAll');
    setInProgress(true);
    if (payments.length > 0) {
      processPayments(payments);
    } else if (isPaymentDetailsComplete(props) || selectedPaymentType === PAYMENT_TYPE_PAY_LATER) {
      goToReviewOrderPage();
    }
  };

  /**
   * Returns true if Continue to review order button should be disabled
   * Disable continue to review order button, when
   * Continue to review order is in progress,
   * There are no payments in the payment context when
   * the order is not a zero value order
   * or there are no existing payment groups or there is a default payment group or appliedPaymentGroup
   */
  const isContinueToReviewOrderButtonDisabled = () => {
    return (
      inProgress ||
      (!isZeroValueOrder(props) &&
        (Object.keys(paymentGroups).length === 0 || getAmountRemainingPaymentGroup(props)) &&
        selectedPaymentType !== PAYMENT_TYPE_PAY_LATER &&
        payments.length === 0)
    );
  };

  return (
    <Styled id="CheckoutContinueToReviewOrderButton" css={css}>
      <div className="CheckoutContinueToReviewOrderButton">
        <button
          type="button"
          className="CheckoutContinueToReviewOrderButton__Button"
          disabled={isContinueToReviewOrderButtonDisabled()}
          onClick={onContinueToReviewOrder}
        >
          {actionContinueToReviewOrder}
        </button>
      </div>
    </Styled>
  );
};

CheckoutContinueToReviewOrderButton.propTypes = {
  /**
   * The page address to redirect to on continue to review order click.
   */
  continueToPageAddress: PropTypes.string.isRequired,
  /**
   * The payment groups in the order
   */
  paymentGroups: PropTypes.objectOf(
    PropTypes.shape({
      /**
       * The payment group id
       */
      paymentGroupId: PropTypes.string.isRequired
    })
  )
};

CheckoutContinueToReviewOrderButton.defaultProps = {
  paymentGroups: {}
};

export default connect(getCurrentOrder)(CheckoutContinueToReviewOrderButton);
