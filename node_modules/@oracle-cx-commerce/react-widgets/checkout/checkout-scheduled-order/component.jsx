/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import React, {useCallback, useContext, useEffect, useMemo, useState} from 'react';
import {
  defaultCreateSchedulePayload,
  isScheduleInfoValid,
  scheduleModePatterns,
  scheduleModeValues
} from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/utils';

import {CheckoutShippingContext} from '@oracle-cx-commerce/react-widgets/checkout/checkout-shipping-container/context';
import CreateScheduledOrderForm from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/components/create-scheduled-order-form';
import {ScheduledOrderContext} from '@oracle-cx-commerce/react-ui/contexts';
import Styled from '@oracle-cx-commerce/react-components/styled';
import {connect} from '@oracle-cx-commerce/react-components/provider';
import css from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/styles.css';
import {getComponentData} from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/selectors';
import {isShippingDetailsComplete} from '@oracle-cx-commerce/react-components/utils/shipping';
import {noop} from '@oracle-cx-commerce/utils/generic';
import { ORDER_STATE_QUOTED } from '@oracle-cx-commerce/commerce-utils/constants';

/**
 * Widget to handle when current order is selected to scheduled order
 * @param props
 */
const CheckoutScheduledOrder = props => {
  const [frequency, setFrequency] = useState(scheduleModeValues.SCHEDULE_MODE_ONCE_DAILY);

  const compareNumbers = (a, b) => {
    return a - b;
  };

  /**
   * Function to validate the schedule object for determining frequency mode
   * @returns {boolean} returns true if the schedule object is matched with one of frequency mode
   */
  const validateScheduleMode = useCallback((scheduleMode, schedule) => {
    const matchFound =
      scheduleModePatterns[scheduleMode].occurrenceInDay.test(schedule.occurrenceInDay) &&
      scheduleModePatterns[scheduleMode].daysOfWeek.test(schedule.daysOfWeek.sort(compareNumbers)) &&
      scheduleModePatterns[scheduleMode].daysInMonth.test(schedule.daysInMonth.sort(compareNumbers)) &&
      scheduleModePatterns[scheduleMode].weeksInMonth.test(schedule.weeksInMonth.sort(compareNumbers)) &&
      scheduleModePatterns[scheduleMode].monthsInYear.test(schedule.monthsInYear.sort(compareNumbers));

    return matchFound;
  }, []);

  /**
   * Function to set the frequency mode from schedule object after validating
   */
  const evaluateScheduleFrequency = useCallback(
    schedule => {
      let frequency = '';
      for (const mode in scheduleModeValues) {
        if (validateScheduleMode(scheduleModeValues[mode], schedule)) {
          frequency = scheduleModeValues[mode];
          break;
        }
      }
      setFrequency(frequency);
    },
    [validateScheduleMode]
  );

  // Checkout Shipping Context
  const checkoutShippingContext = useContext(CheckoutShippingContext);
  let shippingStatus = {};
  if (checkoutShippingContext) {
    ({shippingStatus = {}} = checkoutShippingContext);
  }

  // Scheduled Order Context
  const {
    createSchedulePayload = {},
    setCreateSchedulePayload = noop,
    setScheduledInfoStatus = noop,
    editScheduleInfoEnabled = false
  } = useContext(ScheduledOrderContext);

  const {componentScheduleInfo, currentOrder = {}, isB2BUser, isUserLoggedIn} = props;

  // When scheduling current order for first time
  useEffect(() => {
    if (createSchedulePayload && createSchedulePayload['schedule'] === undefined) {
      setCreateSchedulePayload(prevState => {
        return {...prevState, ...defaultCreateSchedulePayload};
      });
    }
  }, [createSchedulePayload, setCreateSchedulePayload]);

  // Load the already scheduled info from component state
  useEffect(() => {
    if (!editScheduleInfoEnabled && componentScheduleInfo !== undefined && componentScheduleInfo.schedule) {
      setCreateSchedulePayload(prevState => {
        return {...prevState, ...componentScheduleInfo, isScheduleCurrentOrder: true};
      });
    }
  }, [componentScheduleInfo, setCreateSchedulePayload, editScheduleInfoEnabled]);

  // To determine the frequency mode from schedule object
  useMemo(() => {
    if (createSchedulePayload.schedule) evaluateScheduleFrequency(createSchedulePayload.schedule);
  }, [createSchedulePayload.schedule, evaluateScheduleFrequency]);

  const isCreateScheduleInfoAvailable = useCallback(() => {
    if (isScheduleInfoValid(createSchedulePayload)) {
      return true;
    }

    return false;
  }, [createSchedulePayload]);

  //Validation in checkout shipping page for show ContinueToPayment button
  useEffect(() => {
    if (createSchedulePayload.isScheduleCurrentOrder) {
      if (isCreateScheduleInfoAvailable()) {
        setScheduledInfoStatus(prevState => {
          return {...prevState, enableScheduleContinue: true};
        });
      } else {
        setScheduledInfoStatus(prevState => {
          return {...prevState, enableScheduleContinue: false};
        });
      }
    } else if (!createSchedulePayload.isScheduleCurrentOrder) {
      setScheduledInfoStatus(prevState => {
        return {...prevState, enableScheduleContinue: true};
      });
    }
  }, [isCreateScheduleInfoAvailable, createSchedulePayload.isScheduleCurrentOrder, setScheduledInfoStatus]);

  return (
    isUserLoggedIn &&
    ((isShippingDetailsComplete(currentOrder, isB2BUser) && shippingStatus.showConinueToPayment) ||
      editScheduleInfoEnabled) &&
      (currentOrder.state !== ORDER_STATE_QUOTED) &&
      (
      <Styled id="CheckoutScheduledOrder" css={css}>
        <div className={!editScheduleInfoEnabled ? 'CheckoutScheduledOrder' : 'CheckoutScheduledOrder__Edit'}>
          <CreateScheduledOrderForm
            createSchedulePayload={createSchedulePayload}
            setCreateSchedulePayload={setCreateSchedulePayload}
            editScheduleInfoEnabled={editScheduleInfoEnabled}
            scheduleFrequency={frequency}
            {...props}
          />
        </div>
      </Styled>
    )
  );
};

export default connect(getComponentData)(CheckoutScheduledOrder);
