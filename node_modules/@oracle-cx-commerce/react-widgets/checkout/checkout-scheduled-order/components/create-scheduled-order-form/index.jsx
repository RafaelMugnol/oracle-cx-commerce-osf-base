/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import Checkbox from '@oracle-cx-commerce/react-components/checkbox';
import React, {useState, useCallback, useMemo, useEffect, useRef} from 'react';
import WarningIcon from '@oracle-cx-commerce/react-components/icons/warning';
import Styled from '@oracle-cx-commerce/react-components/styled';
import {noop} from '@oracle-cx-commerce/utils/generic';
import css from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/components/create-scheduled-order-form/styles.css';
import {
  scheduleShowMonthWeek,
  checkDateTypeSupported,
  REPOSITORY_STRING_MAX_LENGTH
} from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/utils';
import ScheduleFrequencyOptions from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/components/schedule-frequency-options';
import ScheduleFrequencyModes from '@oracle-cx-commerce/react-widgets/checkout/checkout-scheduled-order/components/schedule-frequency-modes';

/**
 * Component to list input fields to schedule an order
 * @param {Object} props the properties object
 */
const CreateScheduledOrderForm = props => {
  const {
    labelScheduleOrder,
    labelScheduleOrderSubscript,
    labelScheduleOrderPaymentSubscript,
    labelScheduleThisOrder,
    labelScheduledOrderName,
    labelStartDate,
    labelEndDate,
    labelFrequency,
    labelSuspendOrder,
    labelSuspendScheduledOrder,
    labelSelectDaysOfWeek,
    labelSelectWeeksOfMonth,
    id,
    actionConfirm,
    actionCancel,
    onConfirm = noop,
    onCancel = noop,
    ...remProps
  } = props;
  // ref for start,end date ui element
  const startDateElementRef = useRef();
  const endDateElementRef = useRef();

  /**
   * Function to get the minimum date for scheduling order
   */
  const getMinDate = () => {
    const date = new Date();

    return `${date.getFullYear()}-${`0${date.getMonth() + 1}`.slice(-2)}-${`0${date.getDate() + 1}`.slice(-2)}`;
  };

  const minDate = getMinDate();

  /**
   * Check whether the browser supports html5 Date input type
   */
  const isDateTypeSupported = useMemo(() => {
    return checkDateTypeSupported();
  }, []);

  const [showWeeksOfMonth, setShowWeeksOfMonth] = useState(false);
  const [showDayOfWeek, setShowDayOfWeek] = useState(false);
  const [selectedFrequency, setSelectedFrequency] = useState();
  const {createSchedulePayload, setCreateSchedulePayload, editScheduleInfoEnabled, scheduleFrequency} = props;

  useEffect(() => {
    if (scheduleFrequency.length > 0) {
      setSelectedFrequency(scheduleFrequency);
      setShowWeeksOfMonth(scheduleShowMonthWeek[scheduleFrequency].showWeeksOfMonth);
      setShowDayOfWeek(scheduleShowMonthWeek[scheduleFrequency].showDayOfWeek);
    }
  }, [scheduleFrequency]);

  const onScheuleConfirm = () => {
    onConfirm(createSchedulePayload);
  };

  const validateRequiredField = (fieldValue, requiredMessage) => {
    let validationMessage = '';
    if (!fieldValue) {
      validationMessage = requiredMessage;
    }

    return validationMessage;
  };

  const validateScheduleFrequency = useCallback(
    (fieldValue, scheduleObj, requiredMessage) => {
      let validationMessage = '';
      if (!fieldValue) {
        validationMessage = requiredMessage;
      } else if (fieldValue === 'weekly') {
        if (!(scheduleObj.daysOfWeek.length > 0)) {
          validationMessage = remProps.textDaysMandatory;
        }
        if (!(scheduleObj.weeksInMonth.length > 0)) {
          validationMessage = remProps.textWeeksMandatory;
        }
      }

      return validationMessage;
    },
    [remProps.textDaysMandatory, remProps.textWeeksMandatory]
  );

  const validateScheduleStartDateField = useCallback(
    (fieldValue, endDateSelected, requiredMessage) => {
      let validationMessage = '';
      if (!isDateTypeSupported) {
        const dateRegex = /^\d{2}\/\d{2}\/\d{4}$/;
        if (!dateRegex.test(fieldValue)) return requiredMessage;
      }
      const startDate = new Date(fieldValue);
      const currentDate = new Date();
      if (!fieldValue || startDate.toString() === 'Invalid Date') {
        validationMessage = requiredMessage;
      } else if (startDate < currentDate) {
        validationMessage = remProps.textScheduleDateInvalid;
      }

      return validationMessage;
    },
    [isDateTypeSupported, remProps.textScheduleDateInvalid]
  );

  const validateScheduleEndDateField = useCallback(
    (fieldValue, startDateSelected, requiredMessage) => {
      let validationMessage = '';
      if (!isDateTypeSupported) {
        const dateRegex = /^\d{2}\/\d{2}\/\d{4}$/;
        if (!dateRegex.test(fieldValue)) return remProps.textEndDateFormatMandatory;
      }
      const endDate = new Date(fieldValue);
      const startDate = new Date(startDateSelected);
      if (endDate <= startDate) {
        validationMessage = requiredMessage;
      }

      return validationMessage;
    },
    [isDateTypeSupported, remProps.textEndDateFormatMandatory]
  );

  const validators = useMemo(
    () => ({
      name: elementValue => validateRequiredField(elementValue, remProps.textNameMandatory),
      startDate: elementValue =>
        validateScheduleStartDateField(elementValue, createSchedulePayload.endDate, remProps.textStartDateMandatory),
      endDate: elementValue =>
        validateScheduleEndDateField(elementValue, createSchedulePayload.startDate, remProps.textEndDateInvalid),
      frequency: elementValue =>
        validateScheduleFrequency(elementValue, createSchedulePayload.schedule, remProps.textFrequencyMandatory)
    }),
    [
      createSchedulePayload.endDate,
      createSchedulePayload.schedule,
      createSchedulePayload.startDate,
      remProps.textEndDateInvalid,
      remProps.textFrequencyMandatory,
      remProps.textNameMandatory,
      remProps.textStartDateMandatory,
      validateScheduleEndDateField,
      validateScheduleFrequency,
      validateScheduleStartDateField
    ]
  );

  /**
   * Validate element to set any custom errors
   * @param {Object} The element to validate
   * @param {function} The function to validate element
   */
  const setElementValidity = useCallback((element, validator) => {
    element.setCustomValidity('');
    element.classList.remove('CreateScheduledOrderForm__Invalid');

    if (validator) {
      element.setCustomValidity(validator(element.value));
    }

    if (element.validationMessage) {
      element.classList.add('CreateScheduledOrderForm__Invalid');
    }

    const errorMessageContainer = element.nextElementSibling.querySelector('.CreateScheduledOrderForm__ErrorMessage');
    if (errorMessageContainer) {
      errorMessageContainer.textContent = element.validationMessage;
    }
  }, []);

  /**
   * Validate EndDate when there is change in StartDate
   */
  useEffect(() => {
    const endDateElement = endDateElementRef.current;
    if (startDateElementRef && startDateElementRef.current && !startDateElementRef.current.validationMessage) {
      if (endDateElement && endDateElement.value) setElementValidity(endDateElementRef.current, validators['endDate']);
    }
  }, [setElementValidity, validators, createSchedulePayload.startDate]);

  /**
   * Validates input on element blur
   * @param {Object} event The event object
   */
  const validateInput = event => {
    const element = event.target;
    const validator = validators[element.name];
    if (validator) {
      setElementValidity(element, validator);
    }
  };

  // Update the schedule options selected from frequency mode to state
  const updateScheduleFrequencyOptions = useCallback(
    (frequencyType, isChecked, v) => {
      const value = parseInt(v, 10);
      setCreateSchedulePayload(prevState => {
        const {schedule} = prevState;
        const typeArray = schedule[frequencyType];
        let newSchedule = {};
        if (isChecked) {
          newSchedule = {...schedule, [frequencyType]: [...typeArray, value]};
        } else {
          newSchedule = {...schedule, [frequencyType]: typeArray.filter(e => e !== value)};
        }

        return {
          ...prevState,
          schedule: newSchedule
        };
      });
    },
    [setCreateSchedulePayload]
  );

  // Handles the change of frequency mode
  const handleFrequencyChange = event => {
    validateInput(event);
    const selectedFrequencyType = event.target.value;
    setSelectedFrequency(selectedFrequencyType);
    setShowWeeksOfMonth(scheduleShowMonthWeek[selectedFrequencyType].showWeeksOfMonth);
    setShowDayOfWeek(scheduleShowMonthWeek[selectedFrequencyType].showDayOfWeek);
  };

  // When change of input field
  const onScheduleInputChange = event => {
    const element = event.target;
    const fieldName = element.name;
    const fieldValue = element.value;

    const validator = validators[fieldName];
    if (validator) {
      setElementValidity(element, validator);
    }

    setCreateSchedulePayload(items => {
      const payload = {
        ...items,
        [fieldName]: fieldValue
      };

      return payload;
    });
  };

  return (
    <Styled id="CreateScheduledOrderForm" css={css}>
      <div className="CreateScheduledOrderForm">
        {editScheduleInfoEnabled !== undefined && !editScheduleInfoEnabled && (
          <div className="showInCheckoutSchedule">
            <h3>{labelScheduleOrder}</h3>
            <div className="CreateScheduledOrderForm__scheduledOrderSubscript">{labelScheduleOrderSubscript}</div>
            <div className="CreateScheduledOrderForm__scheduledOrderPaymentSubscript">
              {labelScheduleOrderPaymentSubscript}
            </div>
          </div>
        )}
        <div className={!editScheduleInfoEnabled ? 'CreateScheduledOrderForm__Data' : 'EditScheduleForm__Data'}>
          {editScheduleInfoEnabled !== undefined && !editScheduleInfoEnabled && (
            <div className="CreateScheduledOrderForm__SelectorRow">
              <Checkbox
                labelText={labelScheduleThisOrder}
                id={`scheduleThisOrder-${id}`}
                name="scheduleThisOrder"
                checked={createSchedulePayload.isScheduleCurrentOrder}
                onChange={() => {
                  setCreateSchedulePayload(prevState => {
                    return {...prevState, isScheduleCurrentOrder: !createSchedulePayload.isScheduleCurrentOrder};
                  });
                }}
              />
            </div>
          )}

          {createSchedulePayload.isScheduleCurrentOrder && (
            <div
              className={editScheduleInfoEnabled ? 'EditScheduleForm__Wrapper' : 'CreateScheduledOrderForm__Wrapper'}
            >
              <div className={editScheduleInfoEnabled ? 'EditScheduleForm__Rows' : 'CreateScheduledOrderForm__Row'}>
                <div
                  className={
                    !editScheduleInfoEnabled
                      ? 'CreateScheduledOrderForm__NameContainer'
                      : 'EditScheduleForm__NameContainer'
                  }
                >
                  <label htmlFor={`name-${id}`}>{labelScheduledOrderName}</label>
                  <input
                    type="text"
                    value={createSchedulePayload.name}
                    onChange={onScheduleInputChange}
                    onBlur={validateInput}
                    id={`name-${id}`}
                    name="name"
                    autoCapitalize="words"
                    maxLength={REPOSITORY_STRING_MAX_LENGTH}
                    required
                  />
                  <div className="CreateScheduledOrderForm__ErrorContainer">
                    <span className="CreateScheduledOrderForm__ErrorMessage"></span>
                    <span className="CreateScheduledOrderForm__ErrorIconContainer">
                      <WarningIcon />
                    </span>
                  </div>
                </div>

                {editScheduleInfoEnabled && (
                  <div className="CreateScheduledOrderForm__Row">
                    <div className="EditScheduleForm__StartDateContainer">
                      <label htmlFor={`startDate-${id}`}>{labelStartDate}</label>
                      <input
                        type={isDateTypeSupported ? 'date' : 'text'}
                        min={isDateTypeSupported ? minDate : ''}
                        value={createSchedulePayload.startDate}
                        onChange={onScheduleInputChange}
                        onBlur={validateInput}
                        id={`startDate-${id}`}
                        name="startDate"
                        placeholder="mm/dd/yyyy"
                        ref={startDateElementRef}
                        required
                      ></input>
                      <div className="CreateScheduledOrderForm__ErrorContainer">
                        <span className="CreateScheduledOrderForm__ErrorMessage"></span>
                        <span className="CreateScheduledOrderForm__ErrorIconContainer">
                          <WarningIcon />
                        </span>
                      </div>
                    </div>
                    <div className="EditScheduleForm__EndDateContainer">
                      <label htmlFor={`endDate-${id}`}>{labelEndDate}</label>
                      <input
                        type={isDateTypeSupported ? 'date' : 'text'}
                        min={isDateTypeSupported ? minDate : ''}
                        value={createSchedulePayload.endDate}
                        onChange={onScheduleInputChange}
                        onBlur={validateInput}
                        id={`endDate-${id}`}
                        name="endDate"
                        placeholder="mm/dd/yyyy"
                        ref={endDateElementRef}
                      ></input>
                      <div className="CreateScheduledOrderForm__ErrorContainer">
                        <span className="CreateScheduledOrderForm__ErrorMessage"></span>
                        <span className="CreateScheduledOrderForm__ErrorIconContainer">
                          <WarningIcon />
                        </span>
                      </div>
                    </div>
                  </div>
                )}
                {!editScheduleInfoEnabled && (
                  <div className="CreateScheduledOrderForm__StartDateContainer">
                    <label htmlFor={`startDate-${id}`}>{labelStartDate}</label>
                    <input
                      type={isDateTypeSupported ? 'date' : 'text'}
                      min={isDateTypeSupported ? minDate : ''}
                      value={createSchedulePayload.startDate}
                      onChange={onScheduleInputChange}
                      onBlur={validateInput}
                      id={`startDate-${id}`}
                      name="startDate"
                      placeholder="mm/dd/yyyy"
                      ref={startDateElementRef}
                      required
                    ></input>
                    <div className="CreateScheduledOrderForm__ErrorContainer">
                      <span className="CreateScheduledOrderForm__ErrorMessage"></span>
                      <span className="CreateScheduledOrderForm__ErrorIconContainer">
                        <WarningIcon />
                      </span>
                    </div>
                  </div>
                )}
                {!editScheduleInfoEnabled && (
                  <div className="CreateScheduledOrderForm__EndDateContainer">
                    <label htmlFor={`endDate-${id}`}>{labelEndDate}</label>
                    <input
                      type={isDateTypeSupported ? 'date' : 'text'}
                      min={isDateTypeSupported ? minDate : ''}
                      value={createSchedulePayload.endDate}
                      onChange={onScheduleInputChange}
                      onBlur={validateInput}
                      id={`endDate-${id}`}
                      name="endDate"
                      placeholder="mm/dd/yyyy"
                      ref={endDateElementRef}
                    ></input>
                    <div className="CreateScheduledOrderForm__ErrorContainer">
                      <span className="CreateScheduledOrderForm__ErrorMessage"></span>
                      <span className="CreateScheduledOrderForm__ErrorIconContainer">
                        <WarningIcon />
                      </span>
                    </div>
                  </div>
                )}

                <div
                  className={
                    !editScheduleInfoEnabled
                      ? 'CreateScheduledOrderForm__FrequencyContainer'
                      : 'EditScheduleForm__FrequencyContainer'
                  }
                >
                  <label htmlFor={`frequency-${id}`}>{labelFrequency}</label>
                  <ScheduleFrequencyModes
                    handleFrequencyChange={handleFrequencyChange}
                    setCreateSchedulePayload={setCreateSchedulePayload}
                    selectedFrequency={selectedFrequency}
                    startDate={createSchedulePayload.startDate}
                    {...props}
                  ></ScheduleFrequencyModes>
                </div>
              </div>

              {showWeeksOfMonth && showDayOfWeek && (
                <div className="Show__Week__Month">
                  <div className="CreateScheduledOrderForm__DaysRow">
                    <div className="CreateScheduledOrderForm__DaysContainer">
                      <label htmlFor="chooseDaysOfWeek">{labelSelectDaysOfWeek}</label>
                      <div className="CreateScheduledOrderForm__DaysRegion">
                        <ScheduleFrequencyOptions
                          createSchedulePayload={createSchedulePayload}
                          updateScheduleFrequencyOptions={updateScheduleFrequencyOptions}
                          frequencyType={'daysOfWeek'}
                          {...props}
                        ></ScheduleFrequencyOptions>
                      </div>
                    </div>
                  </div>
                  <div className="CreateScheduledOrderForm__WeeksRow">
                    <div className="CreateScheduledOrderForm__WeeksContainer">
                      <label htmlFor="chooseWeeksOfMonth">{labelSelectWeeksOfMonth}</label>
                      <div className="CreateScheduledOrderForm__WeeksRegion">
                        <ScheduleFrequencyOptions
                          createSchedulePayload={createSchedulePayload}
                          updateScheduleFrequencyOptions={updateScheduleFrequencyOptions}
                          frequencyType={'weeksInMonth'}
                          {...props}
                        ></ScheduleFrequencyOptions>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              <div className="CreateScheduledOrderForm__SuspendRow">
                <label htmlFor="suspendOrder">{labelSuspendOrder}</label>
                <div className="CreateScheduledOrderForm__SuspendCheckBox">
                  <Checkbox
                    id={`scheduleSuspendOrder-${id}`}
                    name="scheduleSuspendOrder"
                    defaultValue={createSchedulePayload.state}
                    labelText={labelSuspendScheduledOrder}
                    defaultChecked={createSchedulePayload.state !== 'active'}
                    onChange={event => {
                      setCreateSchedulePayload({
                        ...createSchedulePayload,
                        state: event.target.checked ? 'inactive' : 'active'
                      });
                    }}
                  />
                </div>
              </div>
              {editScheduleInfoEnabled && (
                <div className="EditScheduleForm__Row">
                  <div className="EditScheduledOrderModal__ConfirmButton">
                    <button className="EditScheduledOrderModal__ConfirmButton" type="button" onClick={onScheuleConfirm}>
                      {actionConfirm}
                    </button>
                  </div>
                  <div className="EditScheduledOrderModal__CancelButton">
                    <button
                      className="EditScheduledOrderModal__CancelButton secondary"
                      type="button"
                      onClick={onCancel}
                    >
                      {actionCancel}
                    </button>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </Styled>
  );
};

export default CreateScheduledOrderForm;
