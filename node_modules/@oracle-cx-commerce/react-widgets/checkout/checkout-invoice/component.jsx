/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import React, {useContext, useEffect, useState, useRef, useCallback} from 'react';
import {PAYMENT_TYPE_INVOICE} from '@oracle-cx-commerce/commerce-utils/constants';
import CheckoutBillingAddress from '@oracle-cx-commerce/react-widgets/checkout/checkout-credit-card/components/checkout-billing-address';
import Styled from '@oracle-cx-commerce/react-components/styled';
import RadioButton from '@oracle-cx-commerce/react-components/radio';
import css from '@oracle-cx-commerce/react-widgets/checkout/checkout-invoice/styles.css';
import {getComponentData} from '@oracle-cx-commerce/react-widgets/checkout/checkout-invoice/selectors';
import {connect} from '@oracle-cx-commerce/react-components/provider';
import {PaymentsContext} from '@oracle-cx-commerce/react-ui/contexts';
import PropTypes from 'prop-types';
import {validatePaymentsEnabled} from '@oracle-cx-commerce/react-components/utils/payment';

/**
 * This component provides functionality to apply invoice payment while checking out an order
 * It provides UI for entering order purchase number and billing address.
 */
const CheckoutInvoice = props => {
  const {
    id,
    isPaymentDisabled,
    isDisplayCheckoutInvoice,
    labelInvoice,
    labelPurchaseOrderNumber,
    appliedInvoicePaymentGroups,
    isPaymentMethodEnabledForApproval,
    isApprovalEnabled = false,
    PaymentInfoForScheduledOrder,
    ...remainingProps
  } = props;
  const {
    payments = [],
    selectedPaymentType,
    addOrUpdatePaymentToContext,
    isApprovalRequired,
    setSelectedPaymentType,
    removePaymentFromContextByType,
    updateSelectedPaymentType
  } = useContext(PaymentsContext) || {};
  const [paymentDetails, setPaymentDetails] = useState({type: PAYMENT_TYPE_INVOICE});
  const formRef = useRef(null);

  let appliedPaymentGroupBillingAddress;
  if (appliedInvoicePaymentGroups.length) {
    const {billingAddress} = appliedInvoicePaymentGroups[0];
    appliedPaymentGroupBillingAddress = billingAddress;
  }

  // useEffect will set selectedPaymentType (which to set payment radio button as checked) if payment already applied
  useEffect(() => {
    if (appliedInvoicePaymentGroups.length && !isPaymentDisabled) {
      setPaymentDetails(paymentDetails => {
        return {
          ...paymentDetails,
          PONumber: appliedInvoicePaymentGroups[0].PONumber
        };
      });
      setSelectedPaymentType(PAYMENT_TYPE_INVOICE);
    }
  }, [appliedInvoicePaymentGroups, isPaymentDisabled, setSelectedPaymentType]);

  /**
   * Update the payment details with user provided address
   * @param {object} The billing Address
   */
  const updateAddress = useCallback(
    address => {
      setPaymentDetails(paymentDetails => {
        return {...paymentDetails, ...address};
      });
    },
    [setPaymentDetails]
  );

  /**
   * This method gets invoked on selection of current payment's radio button.
   * It sets the current payment as the selected payment type
   */
  const onPayByInvoiceSelection = useCallback(() => {
    updateSelectedPaymentType(PAYMENT_TYPE_INVOICE);
  }, [updateSelectedPaymentType]);

  // this useEffect will add current payment in the payment context
  // on radio button selection and if payment get disable then it reset the selected payment type
  // and removes the applied in store payment
  useEffect(() => {
    if (selectedPaymentType === PAYMENT_TYPE_INVOICE) {
      const existingInvoicePayment = payments.find(payment => payment.type === PAYMENT_TYPE_INVOICE);
      if (!isPaymentDisabled && paymentDetails.billingAddress && paymentDetails.billingAddress.country) {
        const paymentGroupId =
          appliedInvoicePaymentGroups.length !== 0 ? appliedInvoicePaymentGroups[0].paymentGroupId : null;
        const payment = paymentGroupId ? {...paymentDetails, paymentGroupId} : paymentDetails;

        if (existingInvoicePayment) {
          payment.seqNum = existingInvoicePayment.seqNum;
        }
        if (
          !existingInvoicePayment ||
          existingInvoicePayment.billingAddress !== payment.billingAddress ||
          existingInvoicePayment.PONumber !== payment.PONumber
        ) {
          addOrUpdatePaymentToContext(payment);
        }
      } else if (
        isPaymentDisabled ||
        ((!paymentDetails.billingAddress || !paymentDetails.billingAddress.country) && existingInvoicePayment)
      ) {
        removePaymentFromContextByType(PAYMENT_TYPE_INVOICE);
        if (isPaymentDisabled) {
          setSelectedPaymentType('');
        }
      }
    }
  }, [
    selectedPaymentType,
    isPaymentDisabled,
    appliedInvoicePaymentGroups,
    paymentDetails,
    payments,
    addOrUpdatePaymentToContext,
    removePaymentFromContextByType,
    setSelectedPaymentType
  ]);

  return (
    isDisplayCheckoutInvoice &&
    validatePaymentsEnabled(
      isApprovalRequired,
      isApprovalEnabled,
      isPaymentMethodEnabledForApproval,
      PaymentInfoForScheduledOrder
    ) && (
      <Styled id="CheckoutInvoice" css={css}>
        <div className="CheckoutInvoice CheckoutPaymentsGroup">
          <div className="CheckoutInvoice__RadioButtonContainer">
            <RadioButton
              id={`checkout-invoicePayment-${id}`}
              name="CheckoutPayments"
              disabled={isPaymentDisabled}
              checked={selectedPaymentType === PAYMENT_TYPE_INVOICE}
              labelText={labelInvoice}
              value={PAYMENT_TYPE_INVOICE}
              onChange={onPayByInvoiceSelection}
            />
          </div>
          <div
            className={
              selectedPaymentType === PAYMENT_TYPE_INVOICE
                ? 'CheckoutInvoice__DetailsContainer'
                : 'CheckoutInvoice__DetailsContainer--Hidden'
            }
          >
            <form ref={formRef}>
              <div className="CheckoutInvoice__Row">
                <label htmlFor={`poNumber-${id}`}>{labelPurchaseOrderNumber}</label>
                <input
                  id={`poNumber-${id}`}
                  type="text"
                  name="PONumber"
                  maxLength={254}
                  value={paymentDetails.PONumber || ''}
                  onChange={event => {
                    setPaymentDetails({...paymentDetails, [event.target.name]: event.target.value});
                  }}
                />
              </div>
              <CheckoutBillingAddress
                {...remainingProps}
                id={id}
                onInput={updateAddress}
                appliedPaymentGroupBillingAddress={appliedPaymentGroupBillingAddress}
              />
            </form>
          </div>
        </div>
      </Styled>
    )
  );
};

CheckoutInvoice.propTypes = {
  /**
   * The unique id for the component
   */
  id: PropTypes.string.isRequired,

  /**
   * Flag to indicate if order is accepting new payment
   */
  isPaymentDisabled: PropTypes.bool.isRequired,

  /**
   * Flag indicates whether to display component UI or not
   */
  isDisplayCheckoutInvoice: PropTypes.bool.isRequired,

  /**
   * Indicates if payment method is enabled for approval
   */
  isPaymentMethodEnabledForApproval: PropTypes.bool.isRequired,

  /**
   * Indicates if approval is enabled
   */
  isApprovalEnabled: PropTypes.bool,

  /**
   * Invoice payment Groups
   */
  appliedInstorePaymentGroups: PropTypes.arrayOf(
    PropTypes.shape({
      /**
       * paymentGroupId of paymentGroup
       */
      paymentGroupId: PropTypes.string.isRequired,

      /**
       * Payment method of payment Group
       */
      paymentMethod: PropTypes.string.isRequired,

      /**
       * Payment state of payment Group
       */
      paymentState: PropTypes.string.isRequired,

      /**
       * amount of payment Group
       */
      amount: PropTypes.number.isRequired
    })
  )
};

/**
 * Default values for props
 */
CheckoutInvoice.defaultProps = {
  isApprovalEnabled: false,
  appliedInstorePaymentGroups: []
};

export default connect(getComponentData)(CheckoutInvoice);
