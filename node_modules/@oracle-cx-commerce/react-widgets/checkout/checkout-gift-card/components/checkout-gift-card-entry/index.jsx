/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

/* eslint max-lines: ['error', {max: 550, skipBlankLines: true, skipComments: true}] */
import {
  GIFT_CARDS,
  GIFT_CARD_NUMBER_PROP_NAME,
  GIFT_CARD_PIN_PROP_NAME,
  PAYMENT_TYPE_GIFTCARD,
  PAYMENT_TYPE_PAY_IN_STORE,
  ORDER_STATE_PENDING_PAYMENT,
  ORDER_STATE_QUOTED
} from '@oracle-cx-commerce/commerce-utils/constants';
import {PaymentsContext, StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import React, {useCallback, useContext, useMemo, useRef, useState} from 'react';
import {
  deleteAppliedPaymentsByTypes,
  getPaymentGroupsByTypes,
  validateRequiredField,
  handleAddPaymentSuccess,
  handleAddPaymentFailure
} from '@oracle-cx-commerce/react-components/utils/payment';

import {noop, t} from '@oracle-cx-commerce/utils/generic';
import Checkbox from '@oracle-cx-commerce/react-components/checkbox';
import ConfirmationDialog from '@oracle-cx-commerce/react-components/confirmation-dialog';
import Form from '@oracle-cx-commerce/react-components/form';
import Styled from '@oracle-cx-commerce/react-components/styled';
import {connect} from '@oracle-cx-commerce/react-components/provider';
import css from '@oracle-cx-commerce/react-widgets/checkout/checkout-gift-card/components/checkout-gift-card-entry/styles.css';
import {getCheckoutGiftCardEntryData} from '@oracle-cx-commerce/react-widgets/checkout/checkout-gift-card/components/checkout-gift-card-entry/selectors';
import {getCurrentOrder} from '@oracle-cx-commerce/commerce-utils/selector';
import {useNumberFormatter} from '@oracle-cx-commerce/react-components/utils/hooks';
import {useNavigator} from '@oracle-cx-commerce/react-components/link';

//constants
const APPLY = 'apply',
  CHECK_BALANCE = 'checkBalance',
  CURRENCY = 'currency',
  DEFAULT_GIFT_CARD_NUMBER_LENGTH = 19,
  DEFAULT_GIFT_CARD_PIN_LENGTH = 4,
  REMOVE_LINK_ID_PREFIX = 'removeAppliedGiftCardBalance-',
  USE_BALANCE_CHECKBOX_PREFIX = 'useGiftCardBanalce-',
  USE_CHECKBOX_NAME = 'useBalance';

/***
 * Checkout Gift Card Entry component
 * This widget provider functionality to add gift card during checkout of an order
 * @param{Object} props property object
 */
const CheckoutGiftCardEntry = props => {
  const {
    actionApply,
    actionCheckBalance,
    isGiftCardPaymentDisabled,
    giftCardErrorMessage,
    giftCards,
    giftCardPaymentGroups,
    id,
    labelGiftCardNumber,
    labelGiftCardPin,
    textDuplicateGiftCard,
    textNoBalanceGiftCard,
    textRequiredField,
    textYourGiftCardBalance,
    textUseGiftCardBalance,
    textGiftCardPendingPaymentNote,
    applicableOrderAmount,
    setGiftCardErrorMessage,
    actionConfirm,
    headingConflictingPaymentMethods,
    actionCancel,
    alertForGiftCardPaymentWhenInstorePaymentApplied,
    alertDoYouWantToApplyGiftCard,
    closeLinkAltText,
    orderId,
    orderState,
    currentProfileId,
    uuid,
    alertOrderNotPlacedPaymentDeclined,
    alertTechnicalProblemContactUs
  } = props;
  //local state 'giftCard' to hold gift card number and pin
  const [giftCard, setGiftCard] = useState({giftCardNumber: '', giftCardPin: ''});
  //local state 'isInProgress' to disable 'apply' and 'check balance' buttons
  //when an action triggered by either of these button is progress.
  const [isInProgress, setIsInProgress] = useState(false);
  //local state 'clickedButton' to track whether 'apply' or 'check balance' button is clicked
  let clickedButton = '';
  //local state variable
  const [useBalanceEnabled, setUseBalanceEnabled] = useState(true);
  // this variable hold the applicable current gift card details
  const currentGiftCard = giftCards && giftCard.giftCardNumber ? giftCards[giftCard.giftCardNumber] : null;
  const [showConfirmationDialog, setShowConfirmationDialog] = useState(false);
  const applyButtonRef = useRef(null);
  //'formatCurrency' to format gift card amount with prefixed currency symbol
  const formatCurrency = useNumberFormatter({style: CURRENCY});
  const store = useContext(StoreContext);
  const {action, getState} = store;
  const {
    payments = [],
    selectedPaymentType = '',
    setSelectedPaymentType = noop,
    updateSelectedPaymentType = noop
  } = useContext(PaymentsContext) || {};

  /**
   * Map holds 'validators' function declaration for gift card number and pin fields
   */
  const validators = useMemo(
    () => ({
      giftCardNumber: elementValue => validateRequiredField(elementValue, textRequiredField),
      giftCardPin: elementValue => validateRequiredField(elementValue, textRequiredField)
    }),
    [textRequiredField]
  );

  /**
   * This method removes non numeric input chars
   * and returns only numeric chars from input value
   * @param value input value to be filtered
   * @returns numeric input
   */
  const filterInput = value => {
    return value ? value.replace(/\D/g, '') : value;
  };

  /**
   * This method helps in determining whether to disable or not the apply button
   * @returns true if button is supposed to be disabled otherwise false
   */
  const disableApplyButton = () => {
    return isGiftCardPaymentDisabled || !useBalanceEnabled || (currentGiftCard && currentGiftCard.balance === 0);
  };

  /**
   * This method validates value for input fields by triggering respective 'validators'
   * And sets error message (if any) at corresponding ui elements
   * @param {Object} element ui element
   */
  const validateElement = useCallback(
    element => {
      if (element.name === GIFT_CARD_PIN_PROP_NAME && props.isPinRequired === false) return;
      element.setCustomValidity('');
      const elementValidator = validators[element.name];
      //set 'validator' to the element
      if (elementValidator) {
        element.setCustomValidity(elementValidator(filterInput(element.value)));
      }
    },
    [props, validators]
  );

  /**
   * This method validate whether a gift card is already applied
   * @returns true if a gift card already applied otherwise false
   */
  const isGiftCardAlreadyApplied = useCallback(() => {
    if (giftCardPaymentGroups && giftCardPaymentGroups.length > 0) {
      return giftCardPaymentGroups.find(
        giftCardPaymentGroup => giftCardPaymentGroup.giftCardNumber === giftCard.giftCardNumber
      )
        ? true
        : false;
    }

    return false;
  }, [giftCardPaymentGroups, giftCard.giftCardNumber]);

  /**
   * Handler method to apply gift card
   * This method trims the gift card number and pin to remove unnecessary spaces,
   * it validates if the gift card is already applied and if it is not already applied then
   * invokes applyPayments action to apply gift card
   */
  const applyGiftCard = useCallback(() => {
    //trim gift card number and pin
    setGiftCard({giftCardNumber: giftCard.giftCardNumber.trim(), giftCardPin: giftCard.giftCardPin.trim()});
    // check if the gift card has already been applied.
    if (isGiftCardAlreadyApplied()) {
      setGiftCard({...giftCard, giftCardPin: ''});
      setGiftCardErrorMessage(textDuplicateGiftCard);
    } else {
      const payload = {
        items: [
          {
            type: PAYMENT_TYPE_GIFTCARD,
            [GIFT_CARD_NUMBER_PROP_NAME]: giftCard.giftCardNumber,
            [GIFT_CARD_PIN_PROP_NAME]: giftCard.giftCardPin
          }
        ]
      };
      setIsInProgress(true);
      //clear previous error messages
      if (giftCardErrorMessage !== '') {
        setGiftCardErrorMessage('');
      }
      //action to apply gift card
      action('applyPayments', payload)
        .then(response => {
          if (response.ok) {
            setSelectedPaymentType(selectedPaymentType => {
              if (selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE) {
                updateSelectedPaymentType('');

                return '';
              }

              return selectedPaymentType;
            });
            const currentGiftCardNumber = giftCard.giftCardNumber;
            action('clearInquireBalance', {type: GIFT_CARDS, id: giftCard.giftCardNumber});
            setGiftCard({giftCardNumber: '', giftCardPin: ''});
            const giftCardAdded = document.querySelector(`#${REMOVE_LINK_ID_PREFIX}${currentGiftCardNumber}`);
            giftCardAdded && giftCardAdded.focus();
          } else {
            setGiftCard({...giftCard, giftCardPin: ''});
            if (!response.ok) {
              if (response.error && response.error.errors && response.error.errors.length > 0) {
                const errorMessage = response.error.errors.reduce(
                  (errorMessage, error) => `${errorMessage} ${error.message}`,
                  ''
                );
                setGiftCardErrorMessage(errorMessage);
              } else if (response.error && response.error.message) {
                setGiftCardErrorMessage(response.error.message);
              }
            }
          }
        })
        .finally(() => {
          if (selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE) {
            updateSelectedPaymentType('');
          }
          setIsInProgress(false);
        });
    }
  }, [
    action,
    giftCard,
    giftCardErrorMessage,
    isGiftCardAlreadyApplied,
    selectedPaymentType,
    setGiftCardErrorMessage,
    setSelectedPaymentType,
    textDuplicateGiftCard,
    updateSelectedPaymentType
  ]);

  const goToPage = useNavigator();

  const addGiftCard = useCallback(
    (balance, quotedOrder = false) => {
      const amountRemaining = balance;
      const payload = {
        orderId,
        payments: [
          {
            type: PAYMENT_TYPE_GIFTCARD,
            [GIFT_CARD_NUMBER_PROP_NAME]: giftCard.giftCardNumber,
            [GIFT_CARD_PIN_PROP_NAME]: giftCard.giftCardPin,
            seqNum: '0',
            amount: amountRemaining,
            uuid
          }
        ]
      };
      setIsInProgress(true);
      //clear previous error messages
      if (giftCardErrorMessage !== '') {
        setGiftCardErrorMessage('');
      }
      const actionName = quotedOrder ? 'submitQuotedOrder' : 'addPayments';
      action(actionName, payload)
        .then(response => {
          setIsInProgress(false);
          if (response.ok === true) {
            setSelectedPaymentType(selectedPaymentType => {
              if (selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE) {
                updateSelectedPaymentType('');

                return '';
              }

              return selectedPaymentType;
            });
            const currentGiftCardNumber = giftCard.giftCardNumber;
            action('clearInquireBalance', {type: GIFT_CARDS, id: giftCard.giftCardNumber});
            setGiftCard({giftCardNumber: '', giftCardPin: ''});
            const giftCardAdded = document.querySelector(`#${REMOVE_LINK_ID_PREFIX}${currentGiftCardNumber}`);
            giftCardAdded && giftCardAdded.focus();
            const messages = {alertOrderNotPlacedPaymentDeclined, alertTechnicalProblemContactUs};
            handleAddPaymentSuccess(orderId, goToPage, response, action, messages);
          } else {
            setGiftCard({...giftCard, giftCardPin: ''});
            handleAddPaymentFailure(action, goToPage, response);
          }
        })
        .finally(() => {
          if (selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE) {
            updateSelectedPaymentType('');
          }
          setIsInProgress(false);
        });
    },
    [
      action,
      alertOrderNotPlacedPaymentDeclined,
      alertTechnicalProblemContactUs,
      giftCard,
      giftCardErrorMessage,
      goToPage,
      orderId,
      selectedPaymentType,
      setGiftCardErrorMessage,
      setSelectedPaymentType,
      updateSelectedPaymentType,
      uuid
    ]
  );

  /**
   * Handler method to check balance of gift card
   * This method trims the gift card number and pin to remove unnecessary spaces,
   * it invokes inquireBalance action to get gift card balance
   */
  const checkGiftCardBalance = useCallback(() => {
    //trim gift card number and pin to remove unnecessary spaces
    setGiftCard({giftCardNumber: giftCard.giftCardNumber.trim(), giftCardPin: giftCard.giftCardPin.trim()});
    if (giftCard.giftCardNumber && giftCard.giftCardNumber !== '') {
      const payload = {
        payments: [
          {
            type: PAYMENT_TYPE_GIFTCARD,
            [GIFT_CARD_NUMBER_PROP_NAME]: giftCard.giftCardNumber,
            [GIFT_CARD_PIN_PROP_NAME]: giftCard.giftCardPin
          }
        ]
      };
      setIsInProgress(true);
      // clear previous error message
      if (giftCardErrorMessage !== '') {
        setGiftCardErrorMessage('');
      }
      //action to inquire gift card balance
      action('inquireBalance', payload)
        .then(response => {
          if (response.ok) {
            const useBalanceCheckBox = document.querySelector(
              `#${USE_BALANCE_CHECKBOX_PREFIX}${id}${USE_CHECKBOX_NAME}`
            );
            useBalanceCheckBox && useBalanceCheckBox.focus();
          } else if (!response.ok) {
            setGiftCard({...giftCard, giftCardPin: ''});
            if (response.error && response.error.errors && response.error.errors.length > 0) {
              const errorMessage = response.error.errors.reduce(
                (errorMessage, error) => `${errorMessage} ${error.message}`,
                ''
              );
              setGiftCardErrorMessage(errorMessage);
            } else if (response.error && response.error.message) {
              setGiftCardErrorMessage(response.error.message);
            }
          }
        })
        .finally(() => {
          setIsInProgress(false);
        });
    }
  }, [action, giftCard, giftCardErrorMessage, id, setGiftCardErrorMessage]);

  /**
   * Invokes inquire balance and add action on the entered gift card.
   */
  const inquireAndAddGiftCard = useCallback(
    (quotedOrder = false) => {
      //trim gift card number and pin
      setGiftCard({giftCardNumber: giftCard.giftCardNumber.trim(), giftCardPin: giftCard.giftCardPin.trim()});
      // check if the gift card has already been applied.
      if (isGiftCardAlreadyApplied()) {
        setGiftCard({...giftCard, giftCardPin: ''});
        setGiftCardErrorMessage(textDuplicateGiftCard);
      } else if (giftCard.giftCardNumber && giftCard.giftCardNumber !== '') {
        const inquireBalancePayload = {
          payments: [
            {
              type: PAYMENT_TYPE_GIFTCARD,
              [GIFT_CARD_NUMBER_PROP_NAME]: giftCard.giftCardNumber,
              [GIFT_CARD_PIN_PROP_NAME]: giftCard.giftCardPin
            }
          ]
        };
        setIsInProgress(true);
        action('inquireBalance', inquireBalancePayload).then(response => {
          if (response.ok) {
            const {delta: {profileRepository: {inquireBalanceResponses} = {}} = {}} = response;
            const {giftCards} = inquireBalanceResponses[currentProfileId];
            const currentGiftCardNumber = giftCard.giftCardNumber;
            const giftCardResponse = giftCards[currentGiftCardNumber];
            const balance = Math.abs(giftCardResponse.balance);
            if (balance <= 0.0) {
              setGiftCardErrorMessage(textNoBalanceGiftCard);
            } else {
              const amountToBeAuthorize = Math.min(balance, applicableOrderAmount);
              addGiftCard(amountToBeAuthorize, quotedOrder);
            }
          } else if (!response.ok) {
            setIsInProgress(false);
          }
        });
      }
    },
    [
      action,
      addGiftCard,
      applicableOrderAmount,
      currentProfileId,
      giftCard,
      isGiftCardAlreadyApplied,
      setGiftCardErrorMessage,
      textDuplicateGiftCard,
      textNoBalanceGiftCard
    ]
  );

  const handlePendingPayment = useCallback(() => {
    if (currentGiftCard && currentGiftCard.balance > 0) {
      const amountToBeAuthorize = Math.min(currentGiftCard.balance, applicableOrderAmount);
      addGiftCard(amountToBeAuthorize);
    } else {
      inquireAndAddGiftCard();
    }
  }, [addGiftCard, applicableOrderAmount, currentGiftCard, inquireAndAddGiftCard]);

  const handleQuotedOrder = useCallback(() => {
    const quotedOrder = true;
    if (currentGiftCard && currentGiftCard.balance > 0) {
      const amountToBeAuthorize = Math.min(currentGiftCard.balance, applicableOrderAmount);
      addGiftCard(amountToBeAuthorize, quotedOrder);
    } else {
      inquireAndAddGiftCard(quotedOrder);
    }
  }, [addGiftCard, applicableOrderAmount, currentGiftCard, inquireAndAddGiftCard]);

  /**
   * This method get invoke on click of apply button, if any payments conflict occurs then
   * it opens conflicting payments dialog otherwise calls apply gift card method
   */
  const onApplyGiftCardClick = useCallback(() => {
    //todo, put 'quoted' as constant
    if (
      orderState !== ORDER_STATE_QUOTED &&
      (getPaymentGroupsByTypes(getCurrentOrder(getState()), [PAYMENT_TYPE_PAY_IN_STORE]).length ||
        payments.some(payment => payment.type === PAYMENT_TYPE_PAY_IN_STORE))
    ) {
      setShowConfirmationDialog(true);
    } else if (orderState === ORDER_STATE_PENDING_PAYMENT) {
      handlePendingPayment();
    } else if (orderState === ORDER_STATE_QUOTED) {
      handleQuotedOrder();
    } else {
      applyGiftCard();
    }
  }, [applyGiftCard, getState, handlePendingPayment, handleQuotedOrder, orderState, payments]);

  /**
   * Handler method to handler form submission
   */
  const onSubmit = useCallback(
    event => {
      event.preventDefault();

      if (clickedButton === APPLY) {
        onApplyGiftCardClick();
      } else if (clickedButton === CHECK_BALANCE) {
        checkGiftCardBalance();
      }
    },
    [checkGiftCardBalance, clickedButton, onApplyGiftCardClick]
  );

  /**
   * This method to be passed as confirm call back function to the confirmation dialog
   */
  const confirmCallback = useCallback(async () => {
    const response = await deleteAppliedPaymentsByTypes(store, [PAYMENT_TYPE_PAY_IN_STORE]);
    setShowConfirmationDialog(false);
    //set focus on apply button once confirmation dialog is closed
    applyButtonRef && applyButtonRef.current && applyButtonRef.current.focus();
    if (response.ok) {
      if (selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE) {
        updateSelectedPaymentType('');
      }
      if (orderState === ORDER_STATE_PENDING_PAYMENT) {
        handlePendingPayment();
      } else {
        applyGiftCard();
      }
    } else {
      setGiftCardErrorMessage(response.error.message);
    }
  }, [
    applyGiftCard,
    handlePendingPayment,
    orderState,
    selectedPaymentType,
    setGiftCardErrorMessage,
    store,
    updateSelectedPaymentType
  ]);

  /**
   * This method to be passed as cancel call back function to the confirmation dialog
   */
  const cancelCallback = useCallback(() => {
    setShowConfirmationDialog(false);
    //set focus on apply button once confirmation dialog is closed
    applyButtonRef && applyButtonRef.current && applyButtonRef.current.focus();
  }, []);

  const renderGiftCardBalanceContainer = () => (
    <div className="CheckoutGiftCardEntry__BalanceContainer">
      <div role="tab" id={`giftCardBalanceDetails-${id}`} aria-live="polite">
        <span className="CheckoutGiftCardEntry__BalanceText">{textYourGiftCardBalance}</span>
        <span className="CheckoutGiftCardEntry__BalanceAmount">
          {formatCurrency(Math.abs(currentGiftCard.balance))}
        </span>
      </div>
      <div>
        {!isGiftCardPaymentDisabled && currentGiftCard.balance > 0 && (
          <div>
            <Checkbox
              checked={useBalanceEnabled}
              onChange={() => setUseBalanceEnabled(!useBalanceEnabled)}
              name={USE_CHECKBOX_NAME}
              id={`${USE_BALANCE_CHECKBOX_PREFIX}${id}`}
              labelText={t(textUseGiftCardBalance, {
                useGiftCardBalance: formatCurrency(Math.abs(Math.min(currentGiftCard.balance, applicableOrderAmount)))
              })}
            ></Checkbox>
          </div>
        )}
      </div>
    </div>
  );

  // enter and apply gift card UI also have confirmation dialog reference
  return (
    <Styled id="CheckoutGiftCardEntry" css={css}>
      <ConfirmationDialog
        id={id}
        title={headingConflictingPaymentMethods}
        closeAriaLabel={closeLinkAltText}
        closeIconTitle={closeLinkAltText}
        alertMessage={alertForGiftCardPaymentWhenInstorePaymentApplied}
        confirmMessage={alertDoYouWantToApplyGiftCard}
        labelConfirm={actionConfirm}
        labelCancel={actionCancel}
        confirmCallback={confirmCallback}
        cancelCallback={cancelCallback}
        closeCallback={cancelCallback}
        show={showConfirmationDialog}
      />
      <div className="CheckoutGiftCardEntry">
        <Form onSubmit={onSubmit} setCustomValidity={validateElement} noValidate={true}>
          <div className="CheckoutGiftCardEntry__InputContainer">
            <div className="CheckoutGiftCardEntry__NumberContainer">
              <label htmlFor={`giftCardNumber-${id}`}>{labelGiftCardNumber}</label>
              <input
                name="giftCardNumber"
                type="text"
                required
                autoComplete="cc-number"
                inputMode="numeric"
                maxLength={
                  props.giftCardGatewaySettings
                    ? props.giftCardGatewaySettings.giftCardMaxLength
                    : DEFAULT_GIFT_CARD_NUMBER_LENGTH
                }
                className="CheckoutGiftCardEntry__Number"
                value={giftCard.giftCardNumber}
                onChange={event => {
                  setGiftCard({...giftCard, [event.target.name]: filterInput(event.target.value)});
                  if (!useBalanceEnabled) setUseBalanceEnabled(true);
                }}
                id={`giftCardNumber-${id}`}
              ></input>
              <span className="validationMessage"></span>
            </div>
            <div className="CheckoutGiftCardEntry__PinContainer">
              <label htmlFor={`giftCardPin-${id}`}>{labelGiftCardPin}</label>
              <input
                name="giftCardPin"
                type="password"
                maxLength={
                  props.giftCardGatewaySettings
                    ? props.giftCardGatewaySettings.giftCardPinMaxLength
                    : DEFAULT_GIFT_CARD_PIN_LENGTH
                }
                className="CheckoutGiftCardEntry__Pin"
                value={giftCard.giftCardPin}
                onChange={event => {
                  setGiftCard({...giftCard, [event.target.name]: filterInput(event.target.value)});
                  if (!useBalanceEnabled) setUseBalanceEnabled(true);
                }}
                id={`giftCardPin-${id}`}
              ></input>
              <span className="validationMessage"></span>
            </div>
          </div>
          {orderState === ORDER_STATE_PENDING_PAYMENT && <span>{textGiftCardPendingPaymentNote}</span>}
          {currentGiftCard && !isInProgress && renderGiftCardBalanceContainer()}
          <div className="CheckoutGiftCardEntry__ButtonContainer">
            <button
              type="submit"
              name={APPLY}
              ref={applyButtonRef}
              className="CheckoutGiftCardEntry__ApplyButton"
              onClick={event => {
                clickedButton = event.target.name;
              }}
              disabled={disableApplyButton() || isInProgress}
            >
              {actionApply}
            </button>
            <button
              type="submit"
              name={CHECK_BALANCE}
              onClick={event => {
                clickedButton = event.target.name;
              }}
              className="CheckoutGiftCardEntry__CheckBalanceButton secondary"
              disabled={isInProgress}
            >
              {actionCheckBalance}
            </button>
          </div>
        </Form>
      </div>
    </Styled>
  );
};

export default connect(getCheckoutGiftCardEntryData)(CheckoutGiftCardEntry);
