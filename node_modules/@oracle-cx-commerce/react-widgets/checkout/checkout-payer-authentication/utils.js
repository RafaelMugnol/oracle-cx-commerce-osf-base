/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import {
  ORDER_STATE_SUBMITTED,
  ORDER_STATE_FAILED,
  ORDER_STATE_PENDING_PAYMENT,
  PAYMENT_STATE_INITIAL,
  PAYMENT_STATE_AUTHORIZED,
  PAYMENT_STATE_SETTLED,
  PAYMENT_STATE_REMOVED,
  PAYMENT_REVERSAL_FAILED,
  PAYMENT_AUTH_TIMED_OUT,
  PAYMENT_AUTH_SUCCESS,
  PAYMENT_AUTH_DECLINED,
  PAYMENT_AUTHORIZATION_DEFAULT_TRIES,
  PAYMENT_AUTHORIZATION_DEFAULT_INTERVAL
} from '@oracle-cx-commerce/commerce-utils/constants';
import {getOrder, getCurrentOrder} from '@oracle-cx-commerce/commerce-utils/selector';

//constants
const FILTER_KEYS = 'id,amountAuthorized,stateAsString,orderStatus,customPaymentProperties';

/**
 * Call the getPaymentGroup end-point to get payment group details.
 * Continue retrying the call until order details with updated payment groups is received or maximum retries has been reached.
 * @param {string} orderId the order id
 * @param {number} tryCount the current retry count
 * @param {string} paymentGroupId the payment group id
 * @param {number} numOfRetries the number of retries to be done
 * @param {number} delay the delay b/w two successive tries
 * @param {function} action action method
 * @param {function} getState getState method
 * @param {function} callback callback method
 */
const checkForAuthorization = (orderId, paymentGroupId, tryCount, numOfRetries, delay, action, getState, callback) => {
  /**
   * Wrap the authorization check into a function in order to recursively re-run on a timeout until
   * max retries has been reached.
   */
  const checkAndResubmit = () => {
    if (tryCount <= numOfRetries) {
      setTimeout(() => {
        checkForAuthorization(orderId, paymentGroupId, tryCount + 1, numOfRetries, delay, action, getState, callback);
      }, delay);
    } else {
      const order = orderId ? getOrder(getState(), {id: orderId}) : getCurrentOrder(getState());
      const {state, paymentGroups = {}} = order;
      const paymentGroup = paymentGroups[paymentGroupId];
      //call callback method in case of timeout
      callback({status: PAYMENT_AUTH_TIMED_OUT, paymentState: paymentGroup.paymentState, orderState: state});
    }
  };

  //trigger endpoint to fetch payment group
  action('getPaymentGroup', {paymentGroupId, orderId, fields: FILTER_KEYS}).then(response => {
    //success callback
    if (response.ok) {
      //get order and payment group from response data
      const order = orderId ? response.delta.orderRepository.orders[orderId] : getCurrentOrder(getState());
      const {paymentGroups = {}} = order;
      const paymentGroup = paymentGroups[paymentGroupId];
      if (paymentGroup.paymentState && order.state) {
        if (paymentGroup.paymentState === PAYMENT_STATE_INITIAL) {
          checkAndResubmit();
        } else if (paymentGroup.paymentState === PAYMENT_STATE_REMOVED) {
          callback({
            status: PAYMENT_STATE_REMOVED,
            paymentState: paymentGroup.paymentState,
            orderState: order.state
          });
        } else if (
          paymentGroup.paymentState === PAYMENT_STATE_AUTHORIZED ||
          paymentGroup.paymentState === PAYMENT_STATE_SETTLED
        ) {
          if (order.state === ORDER_STATE_FAILED) {
            callback({
              status: PAYMENT_REVERSAL_FAILED,
              paymentState: paymentGroup.paymentState,
              orderState: order.state
            });
          } else if (order.state === ORDER_STATE_SUBMITTED) {
            callback({
              status: PAYMENT_AUTH_SUCCESS,
              paymentState: paymentGroup.paymentState,
              orderState: order.state
            });
          } else if (order.state === ORDER_STATE_PENDING_PAYMENT) {
            if (Object.values(paymentGroups).some(pGroup => pGroup.paymentState === PAYMENT_STATE_INITIAL)) {
              callback({
                status: PAYMENT_AUTH_SUCCESS,
                paymentState: paymentGroup.paymentState,
                orderState: order.state
              });
            } else {
              checkAndResubmit();
            }
          } else {
            checkAndResubmit();
          }
        } else {
          //Merchants should ensure customPaymentProperties includes
          //responseCode and responseDescription to display to the shopper on UI
          callback({
            status: PAYMENT_AUTH_DECLINED,
            paymentState: paymentGroup.paymentState,
            orderState: order.state,
            responseData: paymentGroup.customPaymentProperties
          });
        }
      } else {
        checkAndResubmit();
      }
    } else {
      // log the error
      if (response.error && response.error.message) {
        // error message received, i18n occurs on server
        console.log(`checkForAuthorization - error -${response.error.message}`);
      } else {
        // unknown error - use generic fail message
        console.log('checkForAuthorization - unknown error returned');
      }
      // try again is it is inside the limit of tries.
      checkAndResubmit();
    }
  });
};

/**
 * Make call to checkForAuthorization method with current try, numOfRetries and delay params specified with other provided params
 * @param {Object} data the object which contains properties orderId, paymentGroupId, numOfRetries, delay, action getState, callback method.
 * action, getState are store methods and callback is call back method.
 * In case numOfRetries and delay properties are not provided then default values of these properties will be used.
 *
 */
export const verifyPaymentAuthorization = data => {
  //get the default values for delay and numOfRetries in case they are not provided
  const delay = data[0].delay ? Number(data[0].delay) : PAYMENT_AUTHORIZATION_DEFAULT_INTERVAL;
  const numOfRetries = data[0].numOfRetries ? Number(data[0].numOfRetries) : PAYMENT_AUTHORIZATION_DEFAULT_TRIES;

  checkForAuthorization(
    data[0].orderId,
    data[0].paymentGroupId,
    0,
    numOfRetries,
    delay,
    data[0].action,
    data[0].getState,
    data[0].callback
  );
};
