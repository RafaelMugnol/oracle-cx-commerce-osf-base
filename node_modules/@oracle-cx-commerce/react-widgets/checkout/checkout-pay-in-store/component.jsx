/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {
  PAYMENT_TYPE_GIFTCARD,
  PAYMENT_TYPE_LOYALTYPOINTS,
  PAYMENT_TYPE_PAY_IN_STORE,
  PAYMENT_TYPE_STORECREDIT
} from '@oracle-cx-commerce/commerce-utils/constants';
import {PaymentsContext, StoreContext} from '@oracle-cx-commerce/react-ui/contexts';
import React, {useCallback, useContext, useEffect, useRef, useState} from 'react';
import {
  deleteAppliedPaymentsByTypes,
  getPaymentGroupsByTypes,
  validatePaymentsEnabled
} from '@oracle-cx-commerce/react-components/utils/payment';

import ConfirmationDialog from '@oracle-cx-commerce/react-components/confirmation-dialog';
import RadioButton from '@oracle-cx-commerce/react-components/radio';
import Styled from '@oracle-cx-commerce/react-components/styled';
import {connect} from '@oracle-cx-commerce/react-components/provider';
import css from '@oracle-cx-commerce/react-widgets/checkout/checkout-pay-in-store/styles.css';
import {getComponentData} from '@oracle-cx-commerce/react-widgets/checkout/checkout-pay-in-store/selectors';
import {getCurrentOrder} from '@oracle-cx-commerce/commerce-utils/selector';
import {noop} from '@oracle-cx-commerce/utils/generic';
import PropTypes from 'prop-types';

const ERROR = 'error';

/**
 * This component provide functionality for applying pay in store payment while checking out an order.
 * It is a radio button for pay in store which appears if all the cart items are being picked up
 * in single store and a store has been selected
 * @param {Object} props properties object
 */
const CheckoutPayInStore = props => {
  const {
    actionCancel,
    actionConfirm,
    alertDoYouWantToPayInStore,
    alertForInstorePaymentWhenOtherPaymentsApplied,
    closeLinkAltText,
    headingConflictingPaymentMethods,
    id,
    isPaymentDisabled,
    isDisplayCheckoutPayInStore,
    appliedInstorePaymentGroups,
    labelPayInStore,
    textPaymentPickupAtStore,
    isApprovalEnabled = false,
    isPaymentMethodEnabledForApproval,
    PaymentInfoForScheduledOrder
  } = props;

  //payment types which should be consider to be removed while selecting pay in store radio
  const paymentTypesToBeDeleted = [PAYMENT_TYPE_GIFTCARD, PAYMENT_TYPE_LOYALTYPOINTS, PAYMENT_TYPE_STORECREDIT];
  const [showConfirmationDialog, setShowConfirmationDialog] = useState(false);
  const payInStoreRadioRef = useRef(null);

  const {
    payments,
    selectedPaymentType,
    isApprovalRequired,
    setPaymentsAlertMessage = noop,
    setSelectedPaymentType = noop,
    updateSelectedPaymentType = noop,
    addOrUpdatePaymentToContext = noop,
    removePaymentFromContextByType = noop
  } = useContext(PaymentsContext) || {};

  const store = useContext(StoreContext);
  const {getState} = store;

  // this useEffect will add current payment in the payment context
  // on radio button selection and if payment get disable then it reset the selected payment type
  // and removes the applied in store payment
  useEffect(() => {
    if (selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE) {
      if (!payments.some(payment => payment.type === PAYMENT_TYPE_PAY_IN_STORE)) {
        const paymentGroupId =
          appliedInstorePaymentGroups.length !== 0 ? appliedInstorePaymentGroups[0].paymentGroupId : null;
        const payment = paymentGroupId
          ? {paymentGroupId, type: PAYMENT_TYPE_PAY_IN_STORE}
          : {type: PAYMENT_TYPE_PAY_IN_STORE};
        addOrUpdatePaymentToContext(payment);
      } else if (isPaymentDisabled) {
        removePaymentFromContextByType(PAYMENT_TYPE_PAY_IN_STORE);
        setSelectedPaymentType('');
      }
    }
  }, [
    addOrUpdatePaymentToContext,
    selectedPaymentType,
    setSelectedPaymentType,
    appliedInstorePaymentGroups,
    removePaymentFromContextByType,
    payments,
    isPaymentDisabled
  ]);

  // useEffect will set selectedPaymentType (which to set payment radio button as checked) if payment already applied
  useEffect(() => {
    if (appliedInstorePaymentGroups.length && !isPaymentDisabled) {
      setSelectedPaymentType(PAYMENT_TYPE_PAY_IN_STORE);
    }
  }, [appliedInstorePaymentGroups, isPaymentDisabled, setSelectedPaymentType]);

  /**
   * This method gets invoked on selection of current payment's radio button.
   * It will open conflicting payments dialog if any payment conflict occurs
   * otherwise set radio button as selected.
   */
  const onPayInStoreSelection = useCallback(() => {
    if (getPaymentGroupsByTypes(getCurrentOrder(getState()), paymentTypesToBeDeleted).length) {
      setShowConfirmationDialog(true);
    } else {
      updateSelectedPaymentType(PAYMENT_TYPE_PAY_IN_STORE);
    }
  }, [getState, paymentTypesToBeDeleted, updateSelectedPaymentType]);

  /**
   * This is success call back method to be passed to the conflicting payment dialog
   * @param {Object} the response object
   */
  const confirmCallback = useCallback(async () => {
    //close dialog
    const response = await deleteAppliedPaymentsByTypes(store);
    setShowConfirmationDialog(false);
    //set focus on radio button once confirmation dialog is closed
    payInStoreRadioRef && payInStoreRadioRef.current && payInStoreRadioRef.current.focus();
    if (response.ok) {
      //update selected payment type to the context
      updateSelectedPaymentType(PAYMENT_TYPE_PAY_IN_STORE);
    } else {
      //notify error if it occurred
      setPaymentsAlertMessage({type: ERROR, message: response.error.message});
    }
  }, [setPaymentsAlertMessage, store, updateSelectedPaymentType]);

  /**
   * This is cancel call back method to be passed to the conflicting payment dialog
   */
  const cancelCallback = useCallback(() => {
    //close dialog
    setShowConfirmationDialog(false);
    //set focus on radio button once confirmation dialog is closed
    payInStoreRadioRef && payInStoreRadioRef.current && payInStoreRadioRef.current.focus();
  }, []);

  //Pay in store radio button UI
  return (
    isDisplayCheckoutPayInStore &&
    validatePaymentsEnabled(
      isApprovalRequired,
      isApprovalEnabled,
      isPaymentMethodEnabledForApproval,
      PaymentInfoForScheduledOrder
    ) && (
      <Styled id="CheckoutPayInStore" css={css}>
        <ConfirmationDialog
          id={id}
          title={headingConflictingPaymentMethods}
          closeAriaLabel={closeLinkAltText}
          closeIconTitle={closeLinkAltText}
          alertMessage={alertForInstorePaymentWhenOtherPaymentsApplied}
          confirmMessage={alertDoYouWantToPayInStore}
          labelConfirm={actionConfirm}
          labelCancel={actionCancel}
          confirmCallback={confirmCallback}
          cancelCallback={cancelCallback}
          closeCallback={cancelCallback}
          show={showConfirmationDialog}
        />
        <div className="CheckoutPayInStore CheckoutPaymentsGroup">
          <div className="CheckoutPayInStore__RadioButtonContainer">
            <RadioButton
              id={`checkout-inStorePayment-${id}`}
              name="CheckoutPayments"
              optionInputRef={payInStoreRadioRef}
              disabled={isPaymentDisabled}
              checked={selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE}
              labelText={labelPayInStore}
              value={PAYMENT_TYPE_PAY_IN_STORE}
              onChange={onPayInStoreSelection}
            />
          </div>
          {selectedPaymentType === PAYMENT_TYPE_PAY_IN_STORE && (
            <div role="region" aria-live="polite" className="CheckoutPayInStore__TextContainer">
              <span>{textPaymentPickupAtStore}</span>
            </div>
          )}
        </div>
      </Styled>
    )
  );
};

CheckoutPayInStore.propTypes = {
  /**
   * The unique id for the component
   */
  id: PropTypes.string.isRequired,

  /**
   * Flag to indicate if order is accepting new payment
   */
  isPaymentDisabled: PropTypes.bool.isRequired,

  /**
   * Flag indicates whether to display component UI or not
   */
  isDisplayCheckoutPayInStore: PropTypes.bool.isRequired,

  /**
   * Indicates if payment method is enabled for approval
   */
  isPaymentMethodEnabledForApproval: PropTypes.bool.isRequired,

  /**
   * Indicates if approval is enabled
   */
  isApprovalEnabled: PropTypes.bool,

  /**
   * In store payment Groups
   */
  appliedInstorePaymentGroups: PropTypes.arrayOf(
    PropTypes.shape({
      /**
       * PaymentGroupId of paymentGroup
       */
      paymentGroupId: PropTypes.string.isRequired,

      /**
       * Payment method of payment Group
       */
      paymentMethod: PropTypes.string.isRequired,

      /**
       * Payment State of payment Group
       */
      paymentState: PropTypes.string.isRequired,

      /**
       * amount of payment Group
       */
      amount: PropTypes.number.isRequired
    })
  )
};

/**
 * Default values for props
 */
CheckoutPayInStore.defaultProps = {
  appliedInstorePaymentGroups: [],
  isApprovalEnabled: false
};

export default connect(getComponentData)(CheckoutPayInStore);
