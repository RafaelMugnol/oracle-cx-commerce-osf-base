/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const {Request} = require('node-fetch');
const initCacheManager = require('@oracle-cx-commerce/http-client/cache-manager');
const createCachingFetch = require('@oracle-cx-commerce/http-client/caching-fetch');
const {getAdditionalForwardingHeaders} = require('@oracle-cx-commerce/express-app/middleware/fetch/utils');

/*
  Create context aware fetcher for this request.
 */
module.exports = app => {
  const {options} = app.locals;

  const fetch = createCachingFetch(app);

  if (options.cacheEnabled) {
    const cacheManager = initCacheManager(options);

    Object.assign(options, {cacheManager});
  }

  const saveLastPublishedTime = response => {
    const {lastPublishedTime = 0} = app.locals;

    const newLastPublishedTime = response.headers.get('lastpublishedtime');

    if (newLastPublishedTime && newLastPublishedTime > lastPublishedTime) {
      app.locals.lastPublishedTime = newLastPublishedTime;
    }
  };

  const additionalForwardingHeaders = getAdditionalForwardingHeaders();

  const setFetch = (req, res) => {
    const fetched = (res.locals.fetched = []);

    res.locals.fetch = async (url, options = {}) => {
      const request = url instanceof Request ? url : new Request(url, options);

      const saveFetched = (request, response) => {
        fetched.push({request, response});
      };

      const setHeader = name => {
        const value = res.locals[name] || req.get(name);

        if (value && !request.headers.has(name)) {
          request.headers.set(name, value);
        }
      };

      setHeader('Accept-Language');
      setHeader('Authorization');
      setHeader('Cookie');
      setHeader('User-Agent');
      setHeader('Origin');
      setHeader('Referer');
      setHeader('Forwarded');
      setHeader('X-Forwarded-For');
      setHeader('X-Forwarded-Host');
      setHeader('X-Forwarded-Proto');
      setHeader('CLIENT_IP');
      setHeader('X-ThousandEyes-Agent');
      setHeader('WL-Proxy-SSL');
      setHeader('X-CC-Client');

      additionalForwardingHeaders.forEach(name => setHeader(name));

      const response = await fetch(request);

      saveLastPublishedTime(response);

      /*
        Save all fetched request/responses for the current SSR request
      */
      saveFetched(request, response);

      return response;
    };
  };

  return {
    fetch(req, res, next) {
      // Make fetch available to the middleware chain
      setFetch(req, res);

      next();
    }
  };
};
