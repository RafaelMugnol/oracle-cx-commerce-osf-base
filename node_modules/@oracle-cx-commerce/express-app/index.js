/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const express = require('express');
const {createProxyMiddleware} = require('http-proxy-middleware');
const escapeHtml = require('escape-html');
const reload = require('reload');
const {getHttpAgent} = require('@oracle-cx-commerce/http-client/utils');
const logger = require('@oracle-cx-commerce/logger/server');
const {resolveBoolean} = require('@oracle-cx-commerce/tools-util');
const createMiddleware = require('./middleware');
const {loadApp, loadBuilder} = require('./utils');

const dummyMiddleware = (req, res, next) => next();

function debounce(fn, interval) {
  let waiting;

  return (...args) => {
    clearTimeout(waiting);

    waiting = setTimeout(fn, interval, ...args);
  };
}

const createApp = async options => {
  console.info(`baseURI is '${options.baseURI}'`);

  // routingURI var reflects the uri that will be used to route requests to be handled
  // by this application's express routes.
  //
  // It is calculated based on the baseURI and if running in a clustered environment.
  // e.g.  could be '' or  '/occ-live'  or '/storefront' or '/b2b-cluster'

  let routingURI = options.baseURI === '/' ? '' : options.baseURI;

  //This env var is something ops sets for when running in a clustered environment.
  const clusterName = process.env.CLUSTER_ID;

  // when running in a clustered environment and the baseURI isn't already on a specific route such as /occ-live,
  // such requests will be routed by cluster name.
  if (clusterName) {
    console.log(`OCC cluster name is: '${clusterName}'`);

    if (options.baseURI === '/') {
      routingURI = `/${clusterName}`;
    }
  }

  // The publicBaseUrl is the path to serving static files from the app. This value is added to state
  // so it can be used in the application to generate links to static files.
  // It's added to the options bucket here which will later added to the global state.
  options.publicBaseUrl = `${routingURI}/occ-public`;

  console.log(`public static file route is:  '${options.publicBaseUrl}'`);

  const appDir = path.resolve(options.appDir);

  // Create express app
  const app = express();

  // Disable express header
  app.disable('x-powered-by');

  // Enable `etag` generation (for SSR pages)
  app.set('etag', 'strong');

  let appMiddleware;

  if (process.env.OCC_BUILDER) {
    // Initialize automatic browser reload
    const reloadReturned = await reload(app);

    // Load app manifests and package.json
    const {serverBuild, clientBuild, packageJson} = await loadBuilder(appDir, options);

    const reloadServer = debounce(() => {
      reloadReturned.reload();
    }, 1000);

    const refreshServerApp = async () => {
      if (serverBuild.error) {
        app.locals.serverBuildError = serverBuild.error;

        // Force browser reload to show error stacktrace in browser
        setImmediate(reloadServer);

        return;
      }

      delete app.locals.serverBuildError;

      const {
        default: {components, endpoints, middleware, meta}
      } = await serverBuild.importEntry();

      // Make available to all middleware (to avoid passing repeatedly as arguments)
      Object.assign(app.locals, {
        components,
        endpoints,
        manifests: {
          get modern() {
            return {base: '/occ-public', ...clientBuild.manifest};
          }
        },
        meta,
        options,
        packageJson
      });

      // setStateFromRequest = dummyMiddleware, // ???
      app.locals.serveApp = (await middleware[1](app)).serveApp;

      // Force browser reload to clear previos error stacktrace from browser
      setImmediate(reloadServer);
    };

    serverBuild.subscribe(refreshServerApp);

    await refreshServerApp(serverBuild);

    const reloadClient = debounce(() => {
      if (!app.locals.serverBuildError) {
        reloadReturned.reload();
      }
    }, 1000);

    const refreshClientApp = async () => {
      if (clientBuild.error) {
        app.locals.clientBuildError = clientBuild.error;

        // Force browser reload to show error stacktrace from browser
        setImmediate(reloadClient);

        return;
      }

      delete app.locals.clientBuildError;

      // Force browser reload to clear previous error stacktrace from browser
      setImmediate(reloadClient);
    };

    clientBuild.subscribe(refreshClientApp);

    // Create osf app middleware
    appMiddleware = await createMiddleware(app);
  } else {
    // Load app manifests and package.json
    const {components, endpoints, middleware, meta, manifests, packageJson} = loadApp(appDir, options);

    // Make available to all middleware (to avoid passing repeatedly as arguments)
    Object.assign(app.locals, {
      components,
      endpoints,
      manifests,
      meta,
      options,
      packageJson
    });

    // Create osf app middleware
    appMiddleware = await createMiddleware(app, middleware);

    app.locals.serveApp = appMiddleware.serveApp;
  }

  // Ensure this user supplied middleware has a default value `dummyMiddleware`
  appMiddleware.setStateFromRequest = appMiddleware.setStateFromRequest || dummyMiddleware;

  // Express app will log via middleware.
  app.use(logger.middleware(options.production ? 'combined' : 'dev'));

  // Make request context aware fetch available to subsequent middleware
  app.use(appMiddleware.fetch);

  // Log the incoming requests
  app.use(appMiddleware.requestLogger);

  // Capture request metrics
  app.use(appMiddleware.metrics);

  // Ensure 'Authorization' token is set (if present)
  app.use(appMiddleware.setAuthorization);

  if (!options.live) {
    // Preview mode needs a valid admin server auth token in the 'Authorization' header
    app.use(appMiddleware.preview);
  }

  if (!options.skipProxy) {
    const proxyRouter = new express.Router();

    proxyRouter.use((req, res, next) => {
      const injectForwardedHeader = (req /*, res, next*/) => {
        // This filter function is a workaround until the bug
        // https://github.com/chimurai/http-proxy-middleware/issues/472 gets fixed.
        // Use `proxy({..., onProxyReq(proxyReq, req, res) {}, ...)` then.
        if (!req.get('Forwarded')) {
          const byId = '_Oracle_OCX_OSF';
          const host = req.get('Host');
          const proto = req.protocol;

          // OSF server receives incorrect data about the source IP address,
          // which is always set to 'localhost'.
          //const forId = req.ip;
          //req.headers['Forwarded'] = `by=${byId};for=${forId};host=${host};proto=${proto}`;
          req.headers['Forwarded'] = `by=${byId};host=${host};proto=${proto}`;
        }
      };

      injectForwardedHeader(req, res, next);

      next();
    });

    // Proxy these request to the occ app server
    proxyRouter.use(
      createProxyMiddleware({
        secure:
          process.env.NODE_TLS_REJECT_UNAUTHORIZED !== undefined
            ? resolveBoolean(process.env.NODE_TLS_REJECT_UNAUTHORIZED)
            : true,
        target: options.appServerURL,
        changeOrigin: true,
        ws: true,
        // Create http Agent to tunnel through corporate proxy (null if no corporate proxy detected)
        agent: getHttpAgent(options.appServerURL),
        headers: {
          origin: null, // ??
          'X-CC-Client': null // ??
        },
        /*
          Responses with 304 (not modified), a "content-length" and no message body will wait (for a
          message body that never arrives) until aborted. The workaround will manually end the response
          stream for these 304s. This workaround can be removed when the underlying node issue is resolved
          -- https://github.com/nodejs/node/pull/34835.
        */
        onProxyRes(proxyRes) {
          // Scheduling with setTimeout allows the headers to be written before the stream is ended
          setTimeout(() => {
            if (
              proxyRes.statusCode === 304 &&
              (proxyRes.headers['content-length'] || proxyRes.headers['Content-Length'])
            ) {
              // Manually end the response stream for these 304s
              proxyRes.emit('end');
            }
          });
        }
      })
    );

    app.use(['/ccstore', '/ccstorex', '/favicon.ico', '/file', '/img'], proxyRouter);
  }

  // Serve static files from '{app}/public' directory
  // For multi-app, this is being left here for backward compatibility with customer apps that have links
  // to the own static content in the public folder. The app would only have to change to start using the
  // publicBaseUrl when multiple clusters/apps are in the mix.
  app.use('/occ-public', express.static(path.resolve(appDir, 'public'), {etag: false, dotfiles: 'allow'}));

  // In local render mode, serve static files f rom '{app}/assets' directory
  if (options.dsAssetMode === 'local') {
    app.use(`/occ-assets`, express.static(path.resolve(appDir, 'assets'), {etag: false, dotfiles: 'allow'}));
  }

  // Temporary fix to allow Object Edge to resolve ApplePay file.
  app.use(
    `/.well-known`,
    express.static(path.resolve(appDir, 'public', '.well-known'), {etag: false, dotfiles: 'allow'})
  );

  // Parse json in request body
  app.use(express.json());

  // Parse form values in request body
  app.use(express.urlencoded({extended: false}));

  // Determine the browser capabilities from user agent
  app.use(appMiddleware.browserCapabilities);

  const appRouter = new express.Router();

  // The appRouter will be mounted on the baseURI path. The app express routes are relative to that.
  //
  // expressRouteBaseURI is used to qualify the path for the express routes below based on how those
  // requests will be routed to the application.
  //
  // Examples
  // baseURI : '/occ-preview/storefront', expressRouteBaseURI: '',              final route:  /occ-preview/storefront/occ-public
  // baseURI : '/'  on cluster storefront, expressRouteBaseURI: '/storefront',  final route:  /storefront/occ-public
  // baseURI : '/occ-live'  on cluster storefront,  expressRouteBaseURI: '',    final route:  /occ-public

  const expressRouteBaseURI = options.baseURI === '/' ? routingURI : '';

  console.log(`Express route base uri is:  '${expressRouteBaseURI}'`);
  // Serve static files from '{app}/dist' directory
  appRouter.use(
    `${expressRouteBaseURI}/occ-public`,
    express.static(path.resolve(appDir, 'dist'), {etag: false, maxAge: '1y'})
  );
  // Serve static files from '{app}/public' directory
  appRouter.use(
    `${expressRouteBaseURI}/occ-public`,
    express.static(path.resolve(appDir, 'public'), {etag: false, dotfiles: 'allow'})
  );

  // TODO enable when NODE_ENV=development? That way can enable with `--debugMode`?
  if (process.env.OCC_MEMORY_DEBUGGING) {
    // eslint-disable-next-line spellcheck/spell-checker
    // If doing memory debugging, add endpoints for getting a heap dump (technically .heapsnapshot)
    let heapHalt = false;
    const v8 = require('v8');

    appRouter.use(`${expressRouteBaseURI}/_occ/heapdump`, (req, res) => {
      // TODO double check if this is necessary. Some Node.js changelogs mentioned preventing simultaneous heapsnapshots,
      // need to investigate if Node has this protection builtin.
      if (heapHalt) {
        res.status(429).send('Current heapdump stream is ongoing');

        return;
      }

      heapHalt = true;

      res.setHeader('Content-Type', 'text/html; charset=utf-8');

      res.setHeader('Transfer-Encoding', 'chunked');

      const heapStream = v8.getHeapSnapshot();

      heapStream.pipe(res);

      heapStream.once('end', () => {
        logger.debug('heapEnd');

        res.end();

        heapHalt = false;
      });

      heapStream.once('error', () => {
        logger.error('heapError');

        res.end();

        heapHalt = false;
      });
    });

    // Also add route for getting general heap statistics
    appRouter.use(`${expressRouteBaseURI}/_occ/heapstats`, (req, res) => {
      res.send(v8.getHeapStatistics());
    });
  }

  // Liveness probe endpoint
  appRouter.use(`${expressRouteBaseURI}/_occ`, appMiddleware.statusCheckRouter);

  // Requests for static files that don't exist will reach here - send 404
  appRouter.get([`${expressRouteBaseURI}/occ-public/*`, `${expressRouteBaseURI}/occ-assets/*`], (req, res) => {
    res.status(404).send('Not found');
  });

  // Requests for static files that don't exist will reach here - send 404
  appRouter.get(['/occ-public/*', '/occ-assets/*', '/.well-known/*'], (req, res) => {
    res.status(404).send('Not found');
  });

  // Service workers a special case and must be mounted to the root path because of scoping constraints.
  appRouter.get([`/sw.js`], (req, res) => {
    res.sendFile(path.resolve(appDir, 'public/sw.js'));
  });

  const serveApp = (req, res, next) => {
    app.locals.serveApp(req, res, next);
  };

  if (process.env.OCC_BUILDER) {
    appRouter.all(['*'], (req, res, next) => {
      if (app.locals.serverBuildError) {
        next(app.locals.serverBuildError);
      } else if (app.locals.clientBuildError) {
        next(app.locals.clientBuildError);
      } else {
        next();
      }
    });
  }

  // SSR (GET)
  appRouter.get(['*'], appMiddleware.setStateFromRequest, serveApp);

  // SSR (POST)
  appRouter.post(
    ['*'],
    appMiddleware.punchout,
    appMiddleware.obo,
    appMiddleware.sso,
    appMiddleware.dynBasicAuthentication,
    appMiddleware.setStateFromRequest,
    serveApp
  );

  // Mount app router
  if (options.baseURI) {
    app.use(options.baseURI, appRouter);
  } else {
    app.use('/', appRouter);
  }

  if (process.env.OCC_BUILDER) {
    app.use((err, req, res, next) => {
      if (res.headersSent) {
        return next(err);
      }

      res
        .status(500)
        .send(
          `<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Error</title></head><body><pre>${escapeHtml(
            err.stack
          )
            .split('\n')
            .join('<br>')}</pre><script src="/reload/reload.js"></script></body></html>`
        );
    });
  }

  return app;
};

module.exports = {createApp};
