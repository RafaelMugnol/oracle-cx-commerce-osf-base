/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const express = require('express');
const {createProxyMiddleware} = require('http-proxy-middleware');
const {getHttpAgent} = require('@oracle-cx-commerce/http-client/utils');
const logger = require('@oracle-cx-commerce/logger/server');
const {resolveBoolean} = require('@oracle-cx-commerce/tools-util');
const createMiddleware = require('./middleware');
const {loadApp} = require('./utils');

const createApp = async options => {
  console.info(`baseURI is '${options.baseURI}'`);

  // routingURI var reflects the uri that will be used to route requests to be handled
  // by this application's express routes.
  //
  // It is calculated based on the baseURI and if running in a clustered environment.
  // e.g.  could be '' or  '/occ-live'  or '/storefront' or '/b2b-cluster'

  let routingURI = options.baseURI === '/' ? '' : options.baseURI;

  //This env var is something ops sets for when running in a clustered environment.
  const clusterName = process.env.CLUSTER_ID;

  // when running in a clustered environment and the baseURI isn't already on a specific route such as /occ-live,
  // such requests will be routed by cluster name.
  if (clusterName) {
    console.log(`OCC cluster name is: '${clusterName}'`);
    if (options.baseURI === '/') {
      routingURI = `/${clusterName}`;
    }
  }

  // The publicBaseUrl is the path to serving static files from the app. This value is added to state
  // so it can be used in the application to generate links to static files.
  // It's added to the options bucket here which will later added to the global state.
  options.publicBaseUrl = `${routingURI}/occ-public`;
  console.log(`public static file route is:  '${options.publicBaseUrl}'`);

  const appDir = path.resolve(options.appDir);

  // Create express app
  const app = express();
  app.disable('x-powered-by');

  // Load app manifests and package.json
  const {components, endpoints, middleware, meta, manifests, packageJson} = loadApp(appDir, options);

  // Make available to all middleware (to avoid passing repeatedly as arguments)
  Object.assign(app.locals, {
    components,
    endpoints,
    manifests,
    meta,
    options,
    packageJson
  });

  const dummyMiddleware = (req, res, next) => next();

  // Create osf app middleware
  const {
    metrics,
    setAuthorization,
    preview,
    browserCapabilities,
    fetch,
    sso,
    dynBasicAuthentication,
    serveApp,
    obo,
    punchout,
    setStateFromRequest = dummyMiddleware,
    statusCheckRouter,
    requestLogger
  } = await createMiddleware(app, middleware);

  // Make request context aware fetch available to subsequent middleware
  app.use(fetch);

  // Enable `etag` generation (for SSR pages)
  app.set('etag', 'strong');

  // Express app will log via middleware.
  app.use(logger.middleware(options.production ? 'combined' : 'dev'));

  // Log the incoming requests
  app.use(requestLogger);

  // Capture request metrics
  app.use(metrics);

  // Ensure 'Authorization' token is set (if present)
  app.use(setAuthorization);

  if (!options.live) {
    // Preview mode needs a valid admin server auth token in the 'Authorization' header
    app.use(preview);
  }

  if (!options.skipProxy) {
    const proxyRouter = new express.Router();

    proxyRouter.use((req, res, next) => {
      const injectForwardedHeader = (req /*, res, next*/) => {
        // This filter function is a workaround until the bug
        // https://github.com/chimurai/http-proxy-middleware/issues/472 gets fixed.
        // Use `proxy({..., onProxyReq(proxyReq, req, res) {}, ...)` then.
        if (!req.get('Forwarded')) {
          const byId = '_Oracle_OCX_OSF';
          const host = req.get('Host');
          const proto = req.protocol;
          // OSF server receives incorrect data about the source IP address,
          // which is always set to 'localhost'.
          //const forId = req.ip;
          //req.headers['Forwarded'] = `by=${byId};for=${forId};host=${host};proto=${proto}`;
          req.headers['Forwarded'] = `by=${byId};host=${host};proto=${proto}`;
        }
      };
      injectForwardedHeader(req, res, next);

      next();
    });

    // Proxy these request to the occ app server
    proxyRouter.use(
      createProxyMiddleware({
        secure:
          process.env.NODE_TLS_REJECT_UNAUTHORIZED !== undefined
            ? resolveBoolean(process.env.NODE_TLS_REJECT_UNAUTHORIZED)
            : true,
        target: options.appServerURL,
        changeOrigin: true,
        ws: true,
        // Create http Agent to tunnel through corporate proxy (null if no corporate proxy detected)
        agent: getHttpAgent(options.appServerURL),
        headers: {
          origin: null, // ??
          'X-CC-Client': null // ??
        },
        /*
          Responses with 304 (not modified), a "content-length" and no message body will wait (for a
          message body that never arrives) until aborted. The workaround will manually end the response
          stream for these 304s. This workaround can be removed when the underlying node issue is resolved
          -- https://github.com/nodejs/node/pull/34835.
        */
        onProxyRes(proxyRes) {
          // Scheduling with setTimeout allows the headers to be written before the stream is ended
          setTimeout(() => {
            if (
              proxyRes.statusCode === 304 &&
              (proxyRes.headers['content-length'] || proxyRes.headers['Content-Length'])
            ) {
              // Manually end the response stream for these 304s
              proxyRes.emit('end');
            }
          });
        }
      })
    );

    app.use(['/ccstore', '/ccstorex', '/favicon.ico', '/file', '/img'], proxyRouter);
  }

  // Serve static files from '{app}/public' directory
  // For multi-app, this is being left here for backward compatibility with customer apps that have links
  // to the own static content in the public folder. The app would only have to change to start using the
  // publicBaseUrl when multiple clusters/apps are in the mix.
  app.use('/occ-public', express.static(path.resolve(appDir, 'public'), {etag: false, dotfiles: 'allow'}));

  // In local render mode, serve static files f rom '{app}/assets' directory
  if (options.dsAssetMode === 'local') {
    app.use(`/occ-assets`, express.static(path.resolve(appDir, 'assets'), {etag: false, dotfiles: 'allow'}));
  }

  // Temporary fix to allow Object Edge to resolve ApplePay file.
  app.use(
    `/.well-known`,
    express.static(path.resolve(appDir, 'public', '.well-known'), {etag: false, dotfiles: 'allow'})
  );

  // Parse json in request body
  app.use(express.json());

  // Parse form values in request body
  app.use(express.urlencoded({extended: false}));

  // Determine the browser capabilities from user agent
  app.use(browserCapabilities);

  const appRouter = new express.Router();

  // The appRouter will be mounted on the baseURI path. The app express routes are relative to that.
  //
  // expressRouteBaseURI is used to qualify the path for the express routes below based on how those
  // requests will be routed to the application.
  //
  // Examples
  // baseURI : '/occ-preview/storefront', expressRouteBaseURI: '',              final route:  /occ-preview/storefront/occ-public
  // baseURI : '/'  on cluster storefront, expressRouteBaseURI: '/storefront',  final route:  /storefront/occ-public
  // baseURI : '/occ-live'  on cluster storefront,  expressRouteBaseURI: '',    final route:  /occ-public

  const expressRouteBaseURI = options.baseURI === '/' ? routingURI : '';

  console.log(`Express route base uri is:  '${expressRouteBaseURI}'`);
  // Serve static files from '{app}/dist' directory
  appRouter.use(
    `${expressRouteBaseURI}/occ-public`,
    express.static(path.resolve(appDir, 'dist'), {etag: false, maxAge: '1y'})
  );
  // Serve static files from '{app}/public' directory
  appRouter.use(
    `${expressRouteBaseURI}/occ-public`,
    express.static(path.resolve(appDir, 'public'), {etag: false, dotfiles: 'allow'})
  );

  // TODO enable when NODE_ENV=development? That way can enable with `--debugMode`?
  if (process.env.OCC_MEMORY_DEBUGGING) {
    // eslint-disable-next-line spellcheck/spell-checker
    // If doing memory debugging, add endpoints for getting a heap dump (technically .heapsnapshot)
    let heapHalt = false;
    const v8 = require('v8');
    appRouter.use(`${expressRouteBaseURI}/_occ/heapdump`, (req, res) => {
      // TODO double check if this is necessary. Some Node.js changelogs mentioned preventing simultaneous heapsnapshots,
      // need to investigate if Node has this protection builtin.
      if (heapHalt) {
        res.status(429).send('Current heapdump stream is ongoing');

        return;
      }
      heapHalt = true;
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      res.setHeader('Transfer-Encoding', 'chunked');
      const heapStream = v8.getHeapSnapshot();
      heapStream.pipe(res);
      heapStream.once('end', () => {
        logger.debug('heapEnd');
        res.end();
        heapHalt = false;
      });
      heapStream.once('error', () => {
        logger.error('heapError');
        res.end();
        heapHalt = false;
      });
    });

    // Also add route for getting general heap statistics
    appRouter.use(`${expressRouteBaseURI}/_occ/heapstats`, (req, res) => {
      res.send(v8.getHeapStatistics());
    });
  }

  // Liveness probe endpoint
  appRouter.use(`${expressRouteBaseURI}/_occ`, statusCheckRouter);

  // Requests for static files that don't exist will reach here - send 404
  appRouter.get([`${expressRouteBaseURI}/occ-public/*`, `${expressRouteBaseURI}/occ-assets/*`], (req, res) => {
    res.status(404).send('Not found');
  });

  // Requests for static files that don't exist will reach here - send 404
  appRouter.get(['/occ-public/*', '/occ-assets/*', '/.well-known/*'], (req, res) => {
    res.status(404).send('Not found');
  });

  // Service workers a special case and must be mounted to the root path because of scoping constraints.
  appRouter.get([`/sw.js`], (req, res) => {
    res.sendFile(path.resolve(appDir, 'public/sw.js'));
  });
  // SSR (GET)
  appRouter.get(['*'], setStateFromRequest, serveApp);

  // SSR (POST)
  appRouter.post(['*'], punchout, obo, sso, dynBasicAuthentication, setStateFromRequest, serveApp);

  // Mount app router
  if (options.baseURI) {
    app.use(options.baseURI, appRouter);
  } else {
    app.use('/', appRouter);
  }

  return app;
};

module.exports = {createApp};
