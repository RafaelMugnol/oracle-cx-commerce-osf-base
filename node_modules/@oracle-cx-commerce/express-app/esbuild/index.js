/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

const path = require('path');
const express = require('express');
const {createProxyMiddleware} = require('http-proxy-middleware');
const {getHttpAgent} = require('@oracle-cx-commerce/http-client/utils');
const logger = require('@oracle-cx-commerce/logger/server');
const {resolveBoolean} = require('@oracle-cx-commerce/tools-util');
const reload = require('reload');
const escapeHtml = require('escape-html');
const createMiddleware = require('../middleware');
const {loadApp, loadBuilder} = require('../utils');

const dummyMiddleware = (req, res, next) => next();

function debounce(fn, interval) {
  let waiting;

  return (...args) => {
    clearTimeout(waiting);

    waiting = setTimeout(fn, interval, ...args);
  };
}

const createApp = async options => {
  const appDir = path.resolve(options.appDir);

  // Create express app
  const app = express();

  // Disable express header
  app.disable('x-powered-by');

  // Enable `etag` generation (for SSR pages)
  app.set('etag', 'strong');

  let appMiddleware;

  if (process.env.OCC_BUILDER) {
    // Initialize automatic browser reload
    const reloadReturned = await reload(app);

    // Load app manifests and package.json
    const {serverBuild, clientBuild, packageJson} = await loadBuilder(appDir, options);

    const reloadServer = debounce(() => {
      reloadReturned.reload();
    }, 1000);

    const refreshServerApp = async () => {
      if (serverBuild.error) {
        app.locals.serverBuildError = serverBuild.error;

        // Force browser reload to show error stacktrace in browser
        setImmediate(reloadServer);

        return;
      }

      delete app.locals.serverBuildError;

      const {
        default: {components, endpoints, middleware, meta}
      } = await serverBuild.importEntry();

      // Make available to all middleware (to avoid passing repeatedly as arguments)
      Object.assign(app.locals, {
        components,
        endpoints,
        manifests: {
          get modern() {
            return {base: '/occ-public', ...clientBuild.manifest};
          }
        },
        meta,
        options,
        packageJson
      });

      // setStateFromRequest = dummyMiddleware, // ???
      app.locals.serveApp = (await middleware[1](app)).serveApp;

      // Force browser reload to clear previos error stacktrace from browser
      setImmediate(reloadServer);
    };

    serverBuild.subscribe(refreshServerApp);

    await refreshServerApp(serverBuild);

    const reloadClient = debounce(() => {
      if (!app.locals.serverBuildError) {
        reloadReturned.reload();
      }
    }, 1000);

    const refreshClientApp = async () => {
      if (clientBuild.error) {
        app.locals.clientBuildError = clientBuild.error;

        // Force browser reload to show error stacktrace from browser
        setImmediate(reloadClient);

        return;
      }

      delete app.locals.clientBuildError;

      // Force browser reload to clear previous error stacktrace from browser
      setImmediate(reloadClient);
    };

    clientBuild.subscribe(refreshClientApp);

    // Create osf app middleware
    appMiddleware = await createMiddleware(app);
  } else {
    // Load app manifests and package.json
    const {components, endpoints, middleware, meta, manifests, packageJson} = loadApp(appDir);

    // Make available to all middleware (to avoid passing repeatedly as arguments)
    Object.assign(app.locals, {
      components,
      endpoints,
      manifests,
      meta,
      options,
      packageJson
    });

    // Create osf app middleware
    appMiddleware = await createMiddleware(app, middleware);

    app.locals.serveApp = appMiddleware.serveApp;
  }

  // Ensure this user supplied middleware has a default value `dummyMiddleware`
  appMiddleware.setStateFromRequest = appMiddleware.setStateFromRequest || dummyMiddleware;

  // Express app will log via middleware.
  app.use(logger.middleware(options.production ? 'combined' : 'dev'));

  // Make request context aware fetch available to subsequent middleware
  app.use(appMiddleware.fetch);

  // Log the incoming requests
  app.use(appMiddleware.requestLogger);

  // Liveness probe endpoint
  app.use('/_occ', appMiddleware.statusCheckRouter);

  // Capture request metrics
  app.use(appMiddleware.metrics);

  // Ensure 'Authorization' token is set (if present)
  app.use(appMiddleware.setAuthorization);

  if (!options.live) {
    // Preview mode needs a valid admin server auth token in the 'Authorization' header
    app.use(appMiddleware.preview);
  }

  if (!options.skipProxy) {
    const proxyRouter = new express.Router();

    proxyRouter.use((req, res, next) => {
      const injectForwardedHeader = (req /*, res, next*/) => {
        // This filter function is a workaround until the bug
        // https://github.com/chimurai/http-proxy-middleware/issues/472 gets fixed.
        // Use `proxy({..., onProxyReq(proxyReq, req, res) {}, ...)` then.
        if (!req.get('Forwarded')) {
          const byId = '_Oracle_OCX_OSF';
          const host = req.get('Host');
          const proto = req.protocol;
          // OSF server receives incorrect data about the source IP address,
          // which is always set to 'localhost'.
          //const forId = req.ip;
          //req.headers['Forwarded'] = `by=${byId};for=${forId};host=${host};proto=${proto}`;
          req.headers['Forwarded'] = `by=${byId};host=${host};proto=${proto}`;
        }
      };
      injectForwardedHeader(req, res, next);

      next();
    });

    // Proxy these request to the occ app server
    proxyRouter.use(
      createProxyMiddleware({
        secure:
          process.env.NODE_TLS_REJECT_UNAUTHORIZED !== undefined
            ? resolveBoolean(process.env.NODE_TLS_REJECT_UNAUTHORIZED)
            : true,
        target: options.appServerURL,
        changeOrigin: true,
        ws: true,
        // Create http Agent to tunnel through corporate proxy (null if no corporate proxy detected)
        agent: getHttpAgent(options.appServerURL),
        headers: {
          origin: null, // ??
          'X-CC-Client': null // ??
        },
        /*
           Responses with 304 (not modified), a "content-length" and no message body will wait (for a
           message body that never arrives) until aborted. The workaround will manually end the response
           stream for these 304s. This workaround can be removed when the underlying node issue is resolved
           -- https://github.com/nodejs/node/pull/34835.
         */
        onProxyRes(proxyRes) {
          // Scheduling with setTimeout allows the headers to be written before the stream is ended
          setTimeout(() => {
            if (
              proxyRes.statusCode === 304 &&
              (proxyRes.headers['content-length'] || proxyRes.headers['Content-Length'])
            ) {
              // Manually end the response stream for these 304s
              proxyRes.emit('end');
            }
          });
        }
      })
    );

    app.use(['/ccstore', '/ccstorex', '/favicon.ico', '/file', '/img'], proxyRouter);
  }

  // Serve static files from '{app}/dist' directory
  app.use('/occ-public', express.static(path.resolve(appDir, 'dist'), {etag: false, maxAge: '1y'}));

  // Serve static files from '{app}/public' directory
  app.use('/occ-public', express.static(path.resolve(appDir, 'public'), {etag: false, dotfiles: 'allow'}));

  // In local render mode, serve static files from '{app}/assets' directory
  if (options.dsAssetMode === 'local') {
    app.use('/occ-assets', express.static(path.resolve(appDir, 'assets'), {etag: false, dotfiles: 'allow'}));
  }

  // Temporary fix to allow Object Edge to resolve ApplePay file.
  app.use(
    '/.well-known',
    express.static(path.resolve(appDir, 'public', '.well-known'), {etag: false, dotfiles: 'allow'})
  );

  // Parse json in request body
  app.use(express.json());

  // Parse form values in request body
  app.use(express.urlencoded({extended: false}));

  // Determine the browser capabilities from user agent
  app.use(appMiddleware.browserCapabilities);

  const appRouter = new express.Router();

  // Service workers a special case and must be mounted to the root path because of scoping constraints.
  appRouter.get(['/sw.js'], (req, res) => {
    res.sendFile(path.resolve(appDir, 'public/sw.js'));
  });

  // Requests for static files that don't exist will reach here - send 404
  appRouter.get(['/occ-public/*', '/occ-assets/*', '/.well-known/*'], (req, res) => {
    res.status(404).send('Not found');
  });

  const serveApp = (req, res, next) => {
    app.locals.serveApp(req, res, next);
  };

  if (process.env.OCC_BUILDER) {
    appRouter.all(['*'], (req, res, next) => {
      if (app.locals.serverBuildError) {
        next(app.locals.serverBuildError);
      } else if (app.locals.clientBuildError) {
        next(app.locals.clientBuildError);
      } else {
        next();
      }
    });
  }

  // SSR (GET)
  appRouter.get(['*'], appMiddleware.setStateFromRequest, serveApp);

  // SSR (POST)
  appRouter.post(
    ['*'],
    appMiddleware.punchout,
    appMiddleware.obo,
    appMiddleware.sso,
    appMiddleware.dynBasicAuthentication,
    appMiddleware.setStateFromRequest,
    serveApp
  );

  // Mount app router
  if (options.baseURI) {
    console.info(`Using baseURI of ${options.baseURI}`);

    app.use(options.baseURI, appRouter);
  } else {
    app.use('/', appRouter);
  }

  if (process.env.OCC_BUILDER) {
    app.use((err, req, res, next) => {
      if (res.headersSent) {
        return next(err);
      }

      res
        .status(500)
        .send(
          `<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Error</title></head><body><pre>${escapeHtml(
            err.stack
          )
            .split('\n')
            .join('<br>')}</pre><script src="/reload/reload.js"></script></body></html>`
        );
    });
  }

  return app;
};

module.exports = {createApp};
