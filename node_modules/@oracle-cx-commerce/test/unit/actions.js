/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {runSaga, stdChannel} from 'redux-saga';

export const createBaselineActionTests = options => {
  const {actions, exportedActions} = options;

  const expectedActions = [
    '__esModule', // Babel transpilation artifact
    ...options.expectedActions
  ].sort();

  test('Named exports correspond (1-to-1) with Actions and no unexpected named exports', () => {
    expect(Object.keys(exportedActions).sort()).toEqual(expectedActions);
  });

  for (const [name, action] of Object.entries(exportedActions)) {
    if (name === '__esModule') {
      // Ignore the babel artifact
      continue;
    }

    test(`export {${name}} is a function`, async () => {
      expect(typeof action).toBe('function');
      expect((await action()).default).toBe(actions);
    });

    test(`${name}() returns default export from './actions.js'`, async () => {
      expect(typeof action).toBe('function');
      expect((await action()).default).toBe(actions);
    });
  }

  const {saga} = actions;

  // Ensure running task is canceled after each test.
  let task;
  afterEach(() => {
    if (task) {
      task.cancel();
    }
  });

  // Test each exported action.
  for (const action of Object.keys(exportedActions)) {
    if (action === '__esModule') {
      // Ignore the babel artifact
      continue;
    }

    test(`Successful "${action}" action returns a success response`, async () => {
      const output = [];
      const input = stdChannel();

      task = runSaga(
        {
          channel: input,
          dispatch: action => output.push(action),
          getState: () => ({thisIsTheState: true}),
          context: {
            wapi: {
              endpoint: (endpointId, payload, state) =>
                Promise.resolve({
                  ok: true,
                  status: 200,
                  getJson: () => Promise.resolve({endpointId, payload, state})
                })
            }
          }
        },
        saga
      );

      const response = await new Promise((resolve, reject) => {
        input.put({
          type: action,
          payload: {thisIsThePayload: true},
          meta: {resolve, reject}
        });
      });

      expect(response).toEqual({
        ok: true,
        status: 200,
        delta: {
          endpointId: action,
          payload: {thisIsThePayload: true},
          state: {thisIsTheState: true}
        },
        error: undefined
      });
    });

    test(`Failed "${action}" action returns an error response`, async () => {
      const output = [];
      const input = stdChannel();

      task = runSaga(
        {
          channel: input,
          dispatch: action => output.push(action),
          getState: () => ({thisIsTheState: true}),
          context: {
            wapi: {
              endpoint: (endpointId, payload, state) =>
                Promise.resolve({
                  ok: false,
                  status: 500,
                  getJson: () =>
                    Promise.resolve({
                      endpointId,
                      payload,
                      state,
                      error: {errorCode: '100001', message: 'Error! Error! Error!'}
                    })
                })
            }
          }
        },
        saga
      );

      const response = await new Promise((resolve, reject) => {
        input.put({
          type: action,
          payload: {thisIsThePayload: true},
          meta: {resolve, reject}
        });
      });

      expect(response).toEqual({
        ok: false,
        status: 500,
        delta: {
          endpointId: action,
          payload: {thisIsThePayload: true},
          state: {thisIsTheState: true}
        },
        error: {
          errorCode: '100001',
          message: 'Error! Error! Error!'
        }
      });
    });

    test(`Runtime exception during "${action}" action are caught with a try...catch`, async () => {
      const output = [];
      const input = stdChannel();
      // Mock Saga Error Handler
      const onError = jest.fn();

      task = runSaga(
        {
          channel: input,
          dispatch: action => output.push(action),
          getState: () => ({thisIsTheState: true}),
          context: {
            wapi: {
              endpoint: () =>
                Promise.resolve({
                  ok: false,
                  status: 500,
                  getJson: async () => {
                    throw new Error('Error! Error! Error!');
                  }
                })
            }
          },
          onError
        },
        saga
      );

      try {
        await new Promise((resolve, reject) => {
          input.put({
            type: action,
            payload: {thisIsThePayload: true},
            meta: {resolve, reject}
          });
        });
      } catch (error) {
        expect(error.message).toBe('Error! Error! Error!');
        expect(onError.mock.calls[0][0]).toBe(error);
      }
    });
  }
};
