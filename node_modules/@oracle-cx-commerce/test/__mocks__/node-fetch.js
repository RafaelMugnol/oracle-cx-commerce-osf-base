/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {Request} from 'node-fetch';
import {EOL} from 'os';

export {Request, Response} from 'node-fetch';

const __MOCK_RESPONSES__ = {};

function hashRequest(method, url, body) {
  const elements = [method || 'GET', url];
  if (body) {
    let bodyAsString;
    switch (body.constructor.name) {
      case 'String':
        bodyAsString = body;
        break;

      case 'Object':
        bodyAsString = JSON.stringify(body);
        break;

      case 'Buffer':
        bodyAsString = Buffer.from(body).toString();
        break;

      default:
    }

    if (bodyAsString) {
      elements.push(bodyAsString);
    }
  }
  const hash = elements.join(' ');

  return hash;
}

function missingMockedResponseError(originalRequest) {
  const request = originalRequest.clone();
  const requestDescription = JSON.stringify(
    {method: request.method, url: request.url, body: String(request.body)},
    null,
    2
  );
  const message = [
    'This request has not been mocked or was already consumed:',
    requestDescription,
    'You could use the next snippet:',
    '',
    '(coming soon in TechnicolorÂ®)'
  ].join(EOL);

  return new Error(message);
}

export const mockFetchResponse = (url, response, requestOptions = {}) => {
  const key = hashRequest(requestOptions.method, url, requestOptions.body);

  if (!__MOCK_RESPONSES__[key]) {
    __MOCK_RESPONSES__[key] = [];
  }
  __MOCK_RESPONSES__[key].push(response);
};

export const unmockFetchResponse = url => {
  delete __MOCK_RESPONSES__[url];
};

export const clearMockResponses = () => {
  for (const key in __MOCK_RESPONSES__) {
    delete __MOCK_RESPONSES__[key];
  }
};

export default async (urlOrRequest, options) => {
  const request = urlOrRequest instanceof Request ? urlOrRequest : new Request(urlOrRequest, options);

  const key = hashRequest(request.method, request.url, request.body);

  const response = (__MOCK_RESPONSES__[key] || []).shift();

  if (response && (response.constructor.name === 'AsyncFunction' || response.constructor.name === 'Function')) {
    await response();
  }

  if (!response) {
    /* eslint-disable-next-line no-debugger */
    debugger;
    throw missingMockedResponseError(request);
  }

  return response;
};

export const responseOptions = {
  origin: origin => ({
    path: path => ({
      responses: {
        200: {
          json: {
            url: `${origin}${path}`,
            ok: true,
            status: 200,
            statusText: 'OK',
            headers: {'Content-Type': 'application/json'}
          }
        },
        201: {
          json: {
            url: `${origin}${path}`,
            ok: true,
            status: 201,
            statusText: 'Created',
            headers: {'Content-Type': 'application/json'}
          }
        },
        202: {
          json: {
            url: `${origin}${path}`,
            ok: true,
            status: 202,
            statusText: 'Accepted',
            headers: {'Content-Type': 'application/json'}
          }
        },
        400: {
          json: {
            url: `${origin}${path}`,
            ok: false,
            status: 400,
            statusText: 'Bad Request',
            headers: {'Content-Type': 'application/json'}
          }
        },
        401: {
          json: {
            url: `${origin}${path}`,
            ok: false,
            status: 401,
            statusText: 'Unauthorized',
            headers: {'Content-Type': 'application/json'}
          }
        },
        404: {
          json: {
            url: `${origin}${path}`,
            ok: false,
            status: 404,
            statusText: 'Not Found',
            headers: {'Content-Type': 'application/json'}
          }
        },
        500: {
          plain: {
            url: `${origin}${path}`,
            ok: false,
            status: 500,
            statusText: 'Internal Server Error',
            headers: {'Content-Type': 'text/plain'}
          }
        },
        502: {
          html: {
            url: `${origin}${path}`,
            ok: false,
            status: 502,
            statusText: 'notresolvable',
            headers: {
              'Content-Type': 'text/html',
              'Cache-Control': 'no-cache',
              'Content-Length': '2818',
              'Proxy-Connection': 'Keep-Alive',
              Via: '1.1 10.23.226.14 (McAfee Web Gateway 9.2.4.34298)',
              'X-Frame-Options': 'deny'
            }
          }
        }
      }
    })
  })
};
