/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import log from './logger';

const OCC_QA_STATE_CHANGE_TIMEOUT = 5000;

/**
 * Subscribe to provided store, listen to events till there are changes to state
 * Return the race result between configured timeout and changes to state
 * @param store - redux store to subscribe
 * @param timeout - can be configured in test / defaults to 7 seconds.
 * @param rejectOnEndpointError - does not reject if endpoint errors are found, user can wait for final state and validate errors in resolved data
 *
 * @returns {Promise<any>}
 *
 */
const storeListener = (store, subscriptionTopic, timeout = OCC_QA_STATE_CHANGE_TIMEOUT) => {
  let timeoutId = null;
  let unsubscribe = null;
  const endpointErrors = {};

  /**
   * time to wait before returning a Promise Rejection
   * @param timeout
   * @returns {Promise<any>}
   */
  const actionTimeout = (timeout = OCC_QA_STATE_CHANGE_TIMEOUT) => {
    const promise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(() => {
        unsubscribe();
        clearTimeout(timeoutId);
        const message = {
          message: `did not see any changes to STATE within configured timeout ${OCC_QA_STATE_CHANGE_TIMEOUT} milliseconds`,
          endpointErrors
        };
        reject(message);
      }, timeout);
    });

    return promise;
  };

  /**
   * Resolves the promise if gets a subscription event on store and results in a state change.
   *
   * @param store
   * @returns {Promise<any>}
   */
  const watchStoreStateChanges = store =>
    new Promise(resolve => {
      if (typeof store === 'undefined') {
        throw new Error('storeListener requires store to be passed to watch on state changes');
      }

      if (typeof subscriptionTopic === 'undefined' && subscriptionTopic === '') {
        throw new Error('subscriptionTopic is required and should be passed from test cases');
      }
      // Refer to "Communications - Events, Status and Notifications" Wiki page
      try {
        unsubscribe = store.subscribeDispatch(action => {
          const {type} = action;
          if (type === subscriptionTopic) {
            unsubscribe();
            clearTimeout(timeoutId);
            unsubscribe = null;
            const message = {action}; // Final action object
            resolve(message);
          } else {
            log.verbose('skipped watching ', type);
          }
        });
      } catch (e) {
        log.error('found error in listener', e);
      }
    });

  /**
   * Return the race result between timeout and actual event of interest coming in.
   */
  return Promise.race([watchStoreStateChanges(store), actionTimeout(timeout)]);
};

export default storeListener;
