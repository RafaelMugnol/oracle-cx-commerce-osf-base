/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */
import {log} from '@oracle-cx-commerce/test/api';

const {Request, Headers} = require('node-fetch');
const __fetch = require('@oracle-cx-commerce/http-client');

// Assumes a very long expiry time for cookie and does not try to refresh the cookie, should be good enough for API tests.
let dynAuthCookie;

// wrapper around OOTB http-client fetch to support basic auth and cookies for API tests.
export const createBasicAuthFetch = (basicAuth = {}, headers = {}) => {
  const {username = 'admin', password = 'admin'} = basicAuth;

  const fetch = async (url, options = {}) => {
    let response;
    const method = url instanceof Request ? url.method || 'GET' : options.method || 'GET';
    const pageURL = url instanceof Request ? new URL(url.url, url.url) : new URL(url, url);
    const pagePath = pageURL.pathname;

    if (url.headers instanceof Headers) {
      Object.entries(headers).forEach(([key, value]) => {
        url.headers.set(key, value);
      });
    } else {
      options.headers = {
        ...options.headers,
        ...headers
      };
    }

    // Cookie stored from previous logins.
    if (dynAuthCookie) {
      if (url instanceof Request) {
        url = new Request(url, {
          ...url,
          headers: {
            ...url.headers,
            cookie: `dynChallengeResponse=${dynAuthCookie};`
          }
        });
      } else if (options.headers && options.headers.cookie) {
        options.headers.cookie = `${options.headers.cookie};dynChallengeResponse=${dynAuthCookie}`;
      } else {
        options.headers.cookie = `dynChallengeResponse=${dynAuthCookie}`;
      }

      try {
        response = await __fetch(url, options);
      } catch (e) {
        log.error(`caught error ${e}`);
      }
      log.verbose(`FETCH resposne for ${pageURL} is ${response.status}`);

      return response;
    }

    response = await __fetch(url, options);

    if (
      method.toUpperCase() === 'GET' &&
      pagePath.startsWith('/ccstore/v1/clientApplications/') &&
      response.status === 401
    ) {
      log.error(
        `API - FETCH response for ${method} - ${pageURL} is ${response.status},
        retrying with basicAuth creds ${username}:${password}`
      );
      const authString = `Basic ${Buffer.from([username, password].join(':')).toString('base64')}`;
      // log.verbose(`options is ${JSON.stringify({...options, headers: {Authorization: authString}})}`);
      response = await __fetch(new Request(url, {...options, headers: {Authorization: authString}}));
      log.info(`response with basic auth credentials is ${pageURL} - ${response.status}`);
      if (response.status >= 200 && response.status <= 400) {
        // log.error(response.headers.raw()['set-cookie']);
        response.headers.raw()['set-cookie'].forEach(kuki => {
          if (kuki.trim().startsWith('dynChallengeResponse=')) {
            [dynAuthCookie] = kuki.trim().slice('dynChallengeResponse='.length).split(';');
            // log.error(`dynAuthCookie is dynChallengeResponse=${dynAuthCookie}`);
          }
        });
        log.info(`Storing dynChallengeResponse cookie for further use`);
      } else {
        log.error(` Server seem to be behind basic auth, you can try one of the below options
        1. Pass basicAuth params to configureStore
        2. Check if basicAuth credentails passed are correct\n\n`);
        // sleep for a second to process logs and console.
        await new Promise(resolve => setTimeout(resolve, 1000));
        process.exit(1);
      }
    }

    return response;
  };

  return fetch;
};
