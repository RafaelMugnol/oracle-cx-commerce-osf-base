/*
 ** Copyright (c) 2020 Oracle and/or its affiliates.
 */

import {updateState} from '@oracle-cx-commerce/utils/store';

const defaultPromise = Promise.resolve({ok: true, status: 200, delta: {}, json: {}});

export const createMockStore = (initialState = {}, initialPromises = {}) => {
  if (typeof initialPromises.then === 'function') {
    // TODO: Remove this temporary check to ensure old signature is not encouraged.
    console.error(`createMockstore second argument should not be a promise.`);
    throw new Error(`createMockstore second argument should not be a promise.`);
  }

  const store = {};
  let listeners = [];
  let state = initialState || {};
  let promises = initialPromises;

  const configurePromises = newPromises => {
    promises = {...promises, ...newPromises};
  };

  /**
   * Takes the delta object and merges it to existing state to 3 levels
   * Uses @oracle-cx-commerce/store updateState util to merge.
   * @param delta
   * @returns {Merged State}
   */
  const mutateState = (delta = {}) => {
    state = updateState(state, delta);

    // TODO: Include a mechanism to flatten the delta and store in a file to compliance and coverage checks?

    return {...state};
  };

  const resolveCallback = value => {
    if (value && value.state) {
      state = {...value.state};
    } else {
      // update the state to help in re-renders.
      mutateState((value && value.delta) || {});
    }

    // notify the listeners... essentially enforcing the provider to re-render
    listeners.forEach(listener => listener());

    return Promise.resolve(value || {});
  };

  const rejectCallback = e => {
    return Promise.reject(e);
  };

  /**
   * Mocked action from @oracle-cx-commerce/store
   */
  const action = type => {
    let promise = promises[`action-${type}`];
    if (!promise) {
      // console.log(`promise not defined for action ${type}, falling back to defaultPromise`);
      promise = defaultPromise;
    }
    if (promise) {
      return promise.then(resolveCallback, rejectCallback);
    }
  };

  /**
   * Mocked endpoint from @oracle-cx-commerce/store
   */
  const endpoint = type => {
    const promise = promises[`endpoint-${type}`];

    if (promise) {
      return promise.then(resolveCallback, rejectCallback);
    }
  };

  /**
   * Returns existing state member
   * @returns {state}
   */
  const getState = () => {
    return {...state};
  };

  /**
   * Mocked redux subscribe that returns a unsubscribe method.
   * @returns {fn}
   */
  const subscribe = listener => {
    listeners.push(listener);

    return () => {
      listeners = listeners.filter(l => l !== listener);
    };
  };

  /**
   * TODO: Implement middleware to subscribe store listener with args.
   * Mocked subscribeDispatch from @oracle-cx-commerce/store
   */
  const subscribeDispatch = () => {};

  /**
   * Mocked Dispatch from @oracle-cx-commerce/store
   */
  const dispatch = () => {};

  /**
   * Mocked replaceReducer from @oracle-cx-commerce/store
   */
  const replaceReducer = () => {};

  /**
   * return mockStore for user to consume and use in tests
   */
  return Object.assign(store, {
    action,
    endpoint,
    getState,
    dispatch,
    replaceReducer,
    subscribe,
    subscribeDispatch,
    mutateState,
    configurePromises
  });
};
